#ifndef __CAVM_CSRS_GSERC_H__
#define __CAVM_CSRS_GSERC_H__
/* This file is auto-generated. Do not edit */

/***********************license start***********************************
* Copyright (C) 2018-2022 Marvell
* SPDX-License-Identifier: BSD-3-Clause
* https://spdx.org/licenses
***********************license end**************************************/


/**
 * @file
 *
 * Configuration and status register (CSR) address and type definitions for
 * OcteonTX GSERC.
 *
 * This file is auto generated. Do not edit.
 *
 */

/**
 * Enumeration gserc_bar_e
 *
 * GSERC Base Address Register Enumeration
 * Enumerates the base address registers.
 */
#define CAVM_GSERC_BAR_E_GSERCX_PF_BAR0(a) (0x87e0a8000000ll + 0x1000000ll * (a))
#define CAVM_GSERC_BAR_E_GSERCX_PF_BAR0_SIZE 0x100000ull

/**
 * Enumeration gserc_psb_acc_e
 *
 * GSERC Power Serial Bus Accumulator Enumeration
 * Enumerates the GSERC accumulators for LMC slaves, which correspond to index {b} of
 * PSBS_SYS()_ACCUM().
 */
#define CAVM_GSERC_PSB_ACC_E_TBD0 (0)
#define CAVM_GSERC_PSB_ACC_E_TBD1 (1)
#define CAVM_GSERC_PSB_ACC_E_TBD2 (2)
#define CAVM_GSERC_PSB_ACC_E_TBD3 (3)

/**
 * Enumeration gserc_psb_event_e
 *
 * GSERC Power Serial Bus Event Enumeration
 * Enumerates the event numbers for GSERC slaves, which correspond to index {b} of
 * PSBS_SYS()_EVENT()_CFG.
 */
#define CAVM_GSERC_PSB_EVENT_E_CYCLE_COUNT (0xc)
#define CAVM_GSERC_PSB_EVENT_E_LANEX_LANE_UP(a) (2 + 3 * (a))
#define CAVM_GSERC_PSB_EVENT_E_LANEX_PLL_TX_UP(a) (1 + 3 * (a))
#define CAVM_GSERC_PSB_EVENT_E_LANEX_PLL_UP(a) (0 + 3 * (a))

/**
 * Register (RSL32b) gserc#_cm0_feature_cal_en_cfg1_rsvd
 *
 * GSERC Cm0 Feature Cal En Cfg1 Register
 */
union cavm_gsercx_cm0_feature_cal_en_cfg1_rsvd
{
    uint32_t u;
    struct cavm_gsercx_cm0_feature_cal_en_cfg1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t ple_blw_en            : 1;  /**< [  5:  5](R/W/H) Reserved. */
        uint32_t tx_term_en            : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t calcomp_high2_en      : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t calcomp_low2_en       : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t calcomp_high1_en      : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t calcomp_low1_en       : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t calcomp_low1_en       : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t calcomp_high1_en      : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t calcomp_low2_en       : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t calcomp_high2_en      : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t tx_term_en            : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t ple_blw_en            : 1;  /**< [  5:  5](R/W/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_cm0_feature_cal_en_cfg1_rsvd_s cn; */
};
typedef union cavm_gsercx_cm0_feature_cal_en_cfg1_rsvd cavm_gsercx_cm0_feature_cal_en_cfg1_rsvd_t;

static inline uint64_t CAVM_GSERCX_CM0_FEATURE_CAL_EN_CFG1_RSVD(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_CM0_FEATURE_CAL_EN_CFG1_RSVD(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800e008ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_CM0_FEATURE_CAL_EN_CFG1_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_CM0_FEATURE_CAL_EN_CFG1_RSVD(a) cavm_gsercx_cm0_feature_cal_en_cfg1_rsvd_t
#define bustype_CAVM_GSERCX_CM0_FEATURE_CAL_EN_CFG1_RSVD(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_CM0_FEATURE_CAL_EN_CFG1_RSVD(a) "GSERCX_CM0_FEATURE_CAL_EN_CFG1_RSVD"
#define device_bar_CAVM_GSERCX_CM0_FEATURE_CAL_EN_CFG1_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_CM0_FEATURE_CAL_EN_CFG1_RSVD(a) (a)
#define arguments_CAVM_GSERCX_CM0_FEATURE_CAL_EN_CFG1_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_feature_pll_cal_en_cfg1_rsvd
 *
 * GSERC Cm0 Feature Pll Cal En Cfg1 Register
 */
union cavm_gsercx_cm0_feature_pll_cal_en_cfg1_rsvd
{
    uint32_t u;
    struct cavm_gsercx_cm0_feature_pll_cal_en_cfg1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t vco_dosc_temp_skew    : 1;  /**< [  2:  2](R/W/H) VCO DOSC temperature skew control.
                                                                 Set to 1 to enable. */
        uint32_t vco_freq3_en          : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t vco_freq2_en          : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t vco_freq2_en          : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t vco_freq3_en          : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t vco_dosc_temp_skew    : 1;  /**< [  2:  2](R/W/H) VCO DOSC temperature skew control.
                                                                 Set to 1 to enable. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_cm0_feature_pll_cal_en_cfg1_rsvd_s cn; */
};
typedef union cavm_gsercx_cm0_feature_pll_cal_en_cfg1_rsvd cavm_gsercx_cm0_feature_pll_cal_en_cfg1_rsvd_t;

static inline uint64_t CAVM_GSERCX_CM0_FEATURE_PLL_CAL_EN_CFG1_RSVD(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_CM0_FEATURE_PLL_CAL_EN_CFG1_RSVD(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800e018ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_CM0_FEATURE_PLL_CAL_EN_CFG1_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_CM0_FEATURE_PLL_CAL_EN_CFG1_RSVD(a) cavm_gsercx_cm0_feature_pll_cal_en_cfg1_rsvd_t
#define bustype_CAVM_GSERCX_CM0_FEATURE_PLL_CAL_EN_CFG1_RSVD(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_CM0_FEATURE_PLL_CAL_EN_CFG1_RSVD(a) "GSERCX_CM0_FEATURE_PLL_CAL_EN_CFG1_RSVD"
#define device_bar_CAVM_GSERCX_CM0_FEATURE_PLL_CAL_EN_CFG1_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_CM0_FEATURE_PLL_CAL_EN_CFG1_RSVD(a) (a)
#define arguments_CAVM_GSERCX_CM0_FEATURE_PLL_CAL_EN_CFG1_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_feature_spare_cfg5_rsvd
 *
 * GSERC Cm0 Feature Spare Cfg5 Register
 */
union cavm_gsercx_cm0_feature_spare_cfg5_rsvd
{
    uint32_t u;
    struct cavm_gsercx_cm0_feature_spare_cfg5_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_cm0_feature_spare_cfg5_rsvd_s cn9; */
    /* struct cavm_gsercx_cm0_feature_spare_cfg5_rsvd_s f95o; */
    struct cavm_gsercx_cm0_feature_spare_cfg5_rsvd_loki
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Data. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Data. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } loki;
};
typedef union cavm_gsercx_cm0_feature_spare_cfg5_rsvd cavm_gsercx_cm0_feature_spare_cfg5_rsvd_t;

static inline uint64_t CAVM_GSERCX_CM0_FEATURE_SPARE_CFG5_RSVD(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_CM0_FEATURE_SPARE_CFG5_RSVD(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a800e0a8ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800e0a8ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_CM0_FEATURE_SPARE_CFG5_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_CM0_FEATURE_SPARE_CFG5_RSVD(a) cavm_gsercx_cm0_feature_spare_cfg5_rsvd_t
#define bustype_CAVM_GSERCX_CM0_FEATURE_SPARE_CFG5_RSVD(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_CM0_FEATURE_SPARE_CFG5_RSVD(a) "GSERCX_CM0_FEATURE_SPARE_CFG5_RSVD"
#define device_bar_CAVM_GSERCX_CM0_FEATURE_SPARE_CFG5_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_CM0_FEATURE_SPARE_CFG5_RSVD(a) (a)
#define arguments_CAVM_GSERCX_CM0_FEATURE_SPARE_CFG5_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_afe_clkdiv_ctrl0
 *
 * GSERC Cm0 Pll Afe Clkdiv Ctrl0 Register
 */
union cavm_gsercx_cm0_pll_afe_clkdiv_ctrl0
{
    uint32_t u;
    struct cavm_gsercx_cm0_pll_afe_clkdiv_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t cmpll_ndiv            : 7;  /**< [  6:  0](R/W/H) PLL Feedback path programmable integer divider division control.

                                                                 Division ratio = register value + 2.
                                                                 Valid range of division ratios is from 4 to 129 */
#else /* Word 0 - Little Endian */
        uint32_t cmpll_ndiv            : 7;  /**< [  6:  0](R/W/H) PLL Feedback path programmable integer divider division control.

                                                                 Division ratio = register value + 2.
                                                                 Valid range of division ratios is from 4 to 129 */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_cm0_pll_afe_clkdiv_ctrl0_s cn; */
};
typedef union cavm_gsercx_cm0_pll_afe_clkdiv_ctrl0 cavm_gsercx_cm0_pll_afe_clkdiv_ctrl0_t;

static inline uint64_t CAVM_GSERCX_CM0_PLL_AFE_CLKDIV_CTRL0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_CM0_PLL_AFE_CLKDIV_CTRL0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a800c818ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c818ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_CM0_PLL_AFE_CLKDIV_CTRL0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_CM0_PLL_AFE_CLKDIV_CTRL0(a) cavm_gsercx_cm0_pll_afe_clkdiv_ctrl0_t
#define bustype_CAVM_GSERCX_CM0_PLL_AFE_CLKDIV_CTRL0(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_CM0_PLL_AFE_CLKDIV_CTRL0(a) "GSERCX_CM0_PLL_AFE_CLKDIV_CTRL0"
#define device_bar_CAVM_GSERCX_CM0_PLL_AFE_CLKDIV_CTRL0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_CM0_PLL_AFE_CLKDIV_CTRL0(a) (a)
#define arguments_CAVM_GSERCX_CM0_PLL_AFE_CLKDIV_CTRL0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_afe_int_ctrl3_rsvd
 *
 * INTERNAL: GSERC Cm0 Pll Afe Int Ctrl3 Register
 */
union cavm_gsercx_cm0_pll_afe_int_ctrl3_rsvd
{
    uint32_t u;
    struct cavm_gsercx_cm0_pll_afe_int_ctrl3_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t cmpll_ikvco           : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t cmpll_ikvco           : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_cm0_pll_afe_int_ctrl3_rsvd_s cn; */
};
typedef union cavm_gsercx_cm0_pll_afe_int_ctrl3_rsvd cavm_gsercx_cm0_pll_afe_int_ctrl3_rsvd_t;

static inline uint64_t CAVM_GSERCX_CM0_PLL_AFE_INT_CTRL3_RSVD(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_CM0_PLL_AFE_INT_CTRL3_RSVD(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a800c8a0ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c8a0ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_CM0_PLL_AFE_INT_CTRL3_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_CM0_PLL_AFE_INT_CTRL3_RSVD(a) cavm_gsercx_cm0_pll_afe_int_ctrl3_rsvd_t
#define bustype_CAVM_GSERCX_CM0_PLL_AFE_INT_CTRL3_RSVD(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_CM0_PLL_AFE_INT_CTRL3_RSVD(a) "GSERCX_CM0_PLL_AFE_INT_CTRL3_RSVD"
#define device_bar_CAVM_GSERCX_CM0_PLL_AFE_INT_CTRL3_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_CM0_PLL_AFE_INT_CTRL3_RSVD(a) (a)
#define arguments_CAVM_GSERCX_CM0_PLL_AFE_INT_CTRL3_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_afe_rpll_ctrl0
 *
 * GSERC Cm0 Pll Afe Rpll Ctrl0 Register
 */
union cavm_gsercx_cm0_pll_afe_rpll_ctrl0
{
    uint32_t u;
    struct cavm_gsercx_cm0_pll_afe_rpll_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t cmpll_ndiv_ref        : 7;  /**< [  6:  0](R/W/H) Second LCPLL Feedback path programmable integer divider division control.

                                                                 Division ratio = register value + 2.
                                                                 This leads to a possible division ratios from 2 to 129

                                                                 Note that LCPLL prescaler setting needs to be determined by rate1. Since there
                                                                 is only one common pre-scaler.
                                                                 The second identical programmable integer divider is intended to provide
                                                                 increased flexibility for the reference clock rate of the RPLL. The highest
                                                                 possible internal reference clock rate is best in terms of RPLL jitter
                                                                 performance. */
#else /* Word 0 - Little Endian */
        uint32_t cmpll_ndiv_ref        : 7;  /**< [  6:  0](R/W/H) Second LCPLL Feedback path programmable integer divider division control.

                                                                 Division ratio = register value + 2.
                                                                 This leads to a possible division ratios from 2 to 129

                                                                 Note that LCPLL prescaler setting needs to be determined by rate1. Since there
                                                                 is only one common pre-scaler.
                                                                 The second identical programmable integer divider is intended to provide
                                                                 increased flexibility for the reference clock rate of the RPLL. The highest
                                                                 possible internal reference clock rate is best in terms of RPLL jitter
                                                                 performance. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_cm0_pll_afe_rpll_ctrl0_s cn; */
};
typedef union cavm_gsercx_cm0_pll_afe_rpll_ctrl0 cavm_gsercx_cm0_pll_afe_rpll_ctrl0_t;

static inline uint64_t CAVM_GSERCX_CM0_PLL_AFE_RPLL_CTRL0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_CM0_PLL_AFE_RPLL_CTRL0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a800c8c0ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c8c0ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_CM0_PLL_AFE_RPLL_CTRL0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_CM0_PLL_AFE_RPLL_CTRL0(a) cavm_gsercx_cm0_pll_afe_rpll_ctrl0_t
#define bustype_CAVM_GSERCX_CM0_PLL_AFE_RPLL_CTRL0(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_CM0_PLL_AFE_RPLL_CTRL0(a) "GSERCX_CM0_PLL_AFE_RPLL_CTRL0"
#define device_bar_CAVM_GSERCX_CM0_PLL_AFE_RPLL_CTRL0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_CM0_PLL_AFE_RPLL_CTRL0(a) (a)
#define arguments_CAVM_GSERCX_CM0_PLL_AFE_RPLL_CTRL0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_afe_vco_ctrl0
 *
 * GSERC Cm0 Pll Afe Vco Ctrl0 Register
 */
union cavm_gsercx_cm0_pll_afe_vco_ctrl0
{
    uint32_t u;
    struct cavm_gsercx_cm0_pll_afe_vco_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t cmpll_vco_select      : 1;  /**< [  0:  0](R/W/H) Selects one of the two LC-VCO cores depending on the desired data rate

                                                                 0x0 = select VCO0
                                                                 0x1 = select VCO1

                                                                 For 30G cores, VCO0 is used for 20-24.9Gbps data rates and VCO1 for 25-30Gbps data rates.
                                                                 For 16G cores, VCO0 is used for 9.8-12.0Gbps data rates and VCO1 for 13.5-16.0Gbps data rates. */
#else /* Word 0 - Little Endian */
        uint32_t cmpll_vco_select      : 1;  /**< [  0:  0](R/W/H) Selects one of the two LC-VCO cores depending on the desired data rate

                                                                 0x0 = select VCO0
                                                                 0x1 = select VCO1

                                                                 For 30G cores, VCO0 is used for 20-24.9Gbps data rates and VCO1 for 25-30Gbps data rates.
                                                                 For 16G cores, VCO0 is used for 9.8-12.0Gbps data rates and VCO1 for 13.5-16.0Gbps data rates. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_cm0_pll_afe_vco_ctrl0_s cn; */
};
typedef union cavm_gsercx_cm0_pll_afe_vco_ctrl0 cavm_gsercx_cm0_pll_afe_vco_ctrl0_t;

static inline uint64_t CAVM_GSERCX_CM0_PLL_AFE_VCO_CTRL0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_CM0_PLL_AFE_VCO_CTRL0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a800c848ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c848ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_CM0_PLL_AFE_VCO_CTRL0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_CM0_PLL_AFE_VCO_CTRL0(a) cavm_gsercx_cm0_pll_afe_vco_ctrl0_t
#define bustype_CAVM_GSERCX_CM0_PLL_AFE_VCO_CTRL0(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_CM0_PLL_AFE_VCO_CTRL0(a) "GSERCX_CM0_PLL_AFE_VCO_CTRL0"
#define device_bar_CAVM_GSERCX_CM0_PLL_AFE_VCO_CTRL0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_CM0_PLL_AFE_VCO_CTRL0(a) (a)
#define arguments_CAVM_GSERCX_CM0_PLL_AFE_VCO_CTRL0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_fracn_ctrl0
 *
 * GSERC Cm0 Pll Fracn Ctrl0 Register
 */
union cavm_gsercx_cm0_pll_fracn_ctrl0
{
    uint32_t u;
    struct cavm_gsercx_cm0_pll_fracn_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t en                    : 1;  /**< [  0:  0](R/W/H) Fractional division and SSC enable. */
#else /* Word 0 - Little Endian */
        uint32_t en                    : 1;  /**< [  0:  0](R/W/H) Fractional division and SSC enable. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_cm0_pll_fracn_ctrl0_s cn; */
};
typedef union cavm_gsercx_cm0_pll_fracn_ctrl0 cavm_gsercx_cm0_pll_fracn_ctrl0_t;

static inline uint64_t CAVM_GSERCX_CM0_PLL_FRACN_CTRL0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_CM0_PLL_FRACN_CTRL0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a800caa0ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800caa0ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_CM0_PLL_FRACN_CTRL0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_CM0_PLL_FRACN_CTRL0(a) cavm_gsercx_cm0_pll_fracn_ctrl0_t
#define bustype_CAVM_GSERCX_CM0_PLL_FRACN_CTRL0(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_CM0_PLL_FRACN_CTRL0(a) "GSERCX_CM0_PLL_FRACN_CTRL0"
#define device_bar_CAVM_GSERCX_CM0_PLL_FRACN_CTRL0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_CM0_PLL_FRACN_CTRL0(a) (a)
#define arguments_CAVM_GSERCX_CM0_PLL_FRACN_CTRL0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_fracn_ctrl1
 *
 * GSERC Cm0 Pll Fracn Ctrl1 Register
 */
union cavm_gsercx_cm0_pll_fracn_ctrl1
{
    uint32_t u;
    struct cavm_gsercx_cm0_pll_fracn_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t fdiv_7_0              : 8;  /**< [  7:  0](R/W/H) Fractional division value bits 7-0 of 20-bit value.
                                                                 Value is a 2's compliment number.
                                                                 Note that if SSC is also enabled then this is the center frequency around which
                                                                 SSC modulation occurs. */
#else /* Word 0 - Little Endian */
        uint32_t fdiv_7_0              : 8;  /**< [  7:  0](R/W/H) Fractional division value bits 7-0 of 20-bit value.
                                                                 Value is a 2's compliment number.
                                                                 Note that if SSC is also enabled then this is the center frequency around which
                                                                 SSC modulation occurs. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_cm0_pll_fracn_ctrl1_s cn; */
};
typedef union cavm_gsercx_cm0_pll_fracn_ctrl1 cavm_gsercx_cm0_pll_fracn_ctrl1_t;

static inline uint64_t CAVM_GSERCX_CM0_PLL_FRACN_CTRL1(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_CM0_PLL_FRACN_CTRL1(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a800caa8ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800caa8ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_CM0_PLL_FRACN_CTRL1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_CM0_PLL_FRACN_CTRL1(a) cavm_gsercx_cm0_pll_fracn_ctrl1_t
#define bustype_CAVM_GSERCX_CM0_PLL_FRACN_CTRL1(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_CM0_PLL_FRACN_CTRL1(a) "GSERCX_CM0_PLL_FRACN_CTRL1"
#define device_bar_CAVM_GSERCX_CM0_PLL_FRACN_CTRL1(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_CM0_PLL_FRACN_CTRL1(a) (a)
#define arguments_CAVM_GSERCX_CM0_PLL_FRACN_CTRL1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_fracn_ctrl2
 *
 * GSERC Cm0 Pll Fracn Ctrl2 Register
 */
union cavm_gsercx_cm0_pll_fracn_ctrl2
{
    uint32_t u;
    struct cavm_gsercx_cm0_pll_fracn_ctrl2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t fdiv_15_8             : 8;  /**< [  7:  0](R/W/H) Fractional division value bits 15-8 L of 20-bit value.
                                                                 Value is a 2's compliment number.
                                                                 Note that if SSC is also enabled then this is the center frequency around which
                                                                 SSC modulation occurs. */
#else /* Word 0 - Little Endian */
        uint32_t fdiv_15_8             : 8;  /**< [  7:  0](R/W/H) Fractional division value bits 15-8 L of 20-bit value.
                                                                 Value is a 2's compliment number.
                                                                 Note that if SSC is also enabled then this is the center frequency around which
                                                                 SSC modulation occurs. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_cm0_pll_fracn_ctrl2_s cn; */
};
typedef union cavm_gsercx_cm0_pll_fracn_ctrl2 cavm_gsercx_cm0_pll_fracn_ctrl2_t;

static inline uint64_t CAVM_GSERCX_CM0_PLL_FRACN_CTRL2(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_CM0_PLL_FRACN_CTRL2(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a800cab0ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800cab0ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_CM0_PLL_FRACN_CTRL2", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_CM0_PLL_FRACN_CTRL2(a) cavm_gsercx_cm0_pll_fracn_ctrl2_t
#define bustype_CAVM_GSERCX_CM0_PLL_FRACN_CTRL2(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_CM0_PLL_FRACN_CTRL2(a) "GSERCX_CM0_PLL_FRACN_CTRL2"
#define device_bar_CAVM_GSERCX_CM0_PLL_FRACN_CTRL2(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_CM0_PLL_FRACN_CTRL2(a) (a)
#define arguments_CAVM_GSERCX_CM0_PLL_FRACN_CTRL2(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_fracn_ctrl3
 *
 * GSERC Cm0 Pll Fracn Ctrl3 Register
 */
union cavm_gsercx_cm0_pll_fracn_ctrl3
{
    uint32_t u;
    struct cavm_gsercx_cm0_pll_fracn_ctrl3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t fdiv_19_16            : 4;  /**< [  3:  0](R/W/H) Fractional division value 19-16 of 20-bit value.
                                                                 Value is a 2's compliment number.
                                                                 Note that if SSC is also enabled then this is the center frequency around which
                                                                 SSC modulation occurs. */
#else /* Word 0 - Little Endian */
        uint32_t fdiv_19_16            : 4;  /**< [  3:  0](R/W/H) Fractional division value 19-16 of 20-bit value.
                                                                 Value is a 2's compliment number.
                                                                 Note that if SSC is also enabled then this is the center frequency around which
                                                                 SSC modulation occurs. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_cm0_pll_fracn_ctrl3_s cn; */
};
typedef union cavm_gsercx_cm0_pll_fracn_ctrl3 cavm_gsercx_cm0_pll_fracn_ctrl3_t;

static inline uint64_t CAVM_GSERCX_CM0_PLL_FRACN_CTRL3(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_CM0_PLL_FRACN_CTRL3(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a800cab8ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800cab8ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_CM0_PLL_FRACN_CTRL3", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_CM0_PLL_FRACN_CTRL3(a) cavm_gsercx_cm0_pll_fracn_ctrl3_t
#define bustype_CAVM_GSERCX_CM0_PLL_FRACN_CTRL3(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_CM0_PLL_FRACN_CTRL3(a) "GSERCX_CM0_PLL_FRACN_CTRL3"
#define device_bar_CAVM_GSERCX_CM0_PLL_FRACN_CTRL3(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_CM0_PLL_FRACN_CTRL3(a) (a)
#define arguments_CAVM_GSERCX_CM0_PLL_FRACN_CTRL3(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_lockdet_status
 *
 * GSERC Cm0 Pll Lockdet Status Register
 */
union cavm_gsercx_cm0_pll_lockdet_status
{
    uint32_t u;
    struct cavm_gsercx_cm0_pll_lockdet_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t toggled               : 1;  /**< [  1:  1](RO/H) Reserved. */
        uint32_t locked                : 1;  /**< [  0:  0](RO/H) PLL lock detection status signal
                                                                 0 = lock detection logic indicates that PLL is not locked
                                                                 1 = lock detection logic indicates that PLL is locked */
#else /* Word 0 - Little Endian */
        uint32_t locked                : 1;  /**< [  0:  0](RO/H) PLL lock detection status signal
                                                                 0 = lock detection logic indicates that PLL is not locked
                                                                 1 = lock detection logic indicates that PLL is locked */
        uint32_t toggled               : 1;  /**< [  1:  1](RO/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_cm0_pll_lockdet_status_s cn; */
};
typedef union cavm_gsercx_cm0_pll_lockdet_status cavm_gsercx_cm0_pll_lockdet_status_t;

static inline uint64_t CAVM_GSERCX_CM0_PLL_LOCKDET_STATUS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_CM0_PLL_LOCKDET_STATUS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a800ca30ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800ca30ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_CM0_PLL_LOCKDET_STATUS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_CM0_PLL_LOCKDET_STATUS(a) cavm_gsercx_cm0_pll_lockdet_status_t
#define bustype_CAVM_GSERCX_CM0_PLL_LOCKDET_STATUS(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_CM0_PLL_LOCKDET_STATUS(a) "GSERCX_CM0_PLL_LOCKDET_STATUS"
#define device_bar_CAVM_GSERCX_CM0_PLL_LOCKDET_STATUS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_CM0_PLL_LOCKDET_STATUS(a) (a)
#define arguments_CAVM_GSERCX_CM0_PLL_LOCKDET_STATUS(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_ssc_ctrl0
 *
 * GSERC Cm0 Pll Ssc Ctrl0 Register
 */
union cavm_gsercx_cm0_pll_ssc_ctrl0
{
    uint32_t u;
    struct cavm_gsercx_cm0_pll_ssc_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t en                    : 1;  /**< [  0:  0](R/W/H) Spread Spectrum Clocking SSC enable
                                                                 Note that to enable SSC the fractional division enable also needs to be asserted
                                                                 fracn_ctrl0 field en needs to be asserted. */
#else /* Word 0 - Little Endian */
        uint32_t en                    : 1;  /**< [  0:  0](R/W/H) Spread Spectrum Clocking SSC enable
                                                                 Note that to enable SSC the fractional division enable also needs to be asserted
                                                                 fracn_ctrl0 field en needs to be asserted. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_cm0_pll_ssc_ctrl0_s cn; */
};
typedef union cavm_gsercx_cm0_pll_ssc_ctrl0 cavm_gsercx_cm0_pll_ssc_ctrl0_t;

static inline uint64_t CAVM_GSERCX_CM0_PLL_SSC_CTRL0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_CM0_PLL_SSC_CTRL0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a800ca80ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800ca80ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_CM0_PLL_SSC_CTRL0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_CM0_PLL_SSC_CTRL0(a) cavm_gsercx_cm0_pll_ssc_ctrl0_t
#define bustype_CAVM_GSERCX_CM0_PLL_SSC_CTRL0(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_CM0_PLL_SSC_CTRL0(a) "GSERCX_CM0_PLL_SSC_CTRL0"
#define device_bar_CAVM_GSERCX_CM0_PLL_SSC_CTRL0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_CM0_PLL_SSC_CTRL0(a) (a)
#define arguments_CAVM_GSERCX_CM0_PLL_SSC_CTRL0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_ssc_ctrl1
 *
 * GSERC Cm0 Pll Ssc Ctrl1 Register
 */
union cavm_gsercx_cm0_pll_ssc_ctrl1
{
    uint32_t u;
    struct cavm_gsercx_cm0_pll_ssc_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t magnitude             : 8;  /**< [  7:  0](R/W/H) SSC modulation magnitude in units of Parts Per Million PPM.
                                                                 Register value is intepreted as PPM magnitude in steps of 20ppm 1LSB = 20ppm. */
#else /* Word 0 - Little Endian */
        uint32_t magnitude             : 8;  /**< [  7:  0](R/W/H) SSC modulation magnitude in units of Parts Per Million PPM.
                                                                 Register value is intepreted as PPM magnitude in steps of 20ppm 1LSB = 20ppm. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_cm0_pll_ssc_ctrl1_s cn; */
};
typedef union cavm_gsercx_cm0_pll_ssc_ctrl1 cavm_gsercx_cm0_pll_ssc_ctrl1_t;

static inline uint64_t CAVM_GSERCX_CM0_PLL_SSC_CTRL1(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_CM0_PLL_SSC_CTRL1(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a800ca88ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800ca88ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_CM0_PLL_SSC_CTRL1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_CM0_PLL_SSC_CTRL1(a) cavm_gsercx_cm0_pll_ssc_ctrl1_t
#define bustype_CAVM_GSERCX_CM0_PLL_SSC_CTRL1(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_CM0_PLL_SSC_CTRL1(a) "GSERCX_CM0_PLL_SSC_CTRL1"
#define device_bar_CAVM_GSERCX_CM0_PLL_SSC_CTRL1(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_CM0_PLL_SSC_CTRL1(a) (a)
#define arguments_CAVM_GSERCX_CM0_PLL_SSC_CTRL1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_ssc_ctrl2
 *
 * GSERC Cm0 Pll Ssc Ctrl2 Register
 */
union cavm_gsercx_cm0_pll_ssc_ctrl2
{
    uint32_t u;
    struct cavm_gsercx_cm0_pll_ssc_ctrl2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t freq                  : 8;  /**< [  7:  0](R/W/H) SSC modulation frequency.
                                                                 Sets the SSC modulation frequency in steps of 250Hz 1LSB = 250Hz. */
#else /* Word 0 - Little Endian */
        uint32_t freq                  : 8;  /**< [  7:  0](R/W/H) SSC modulation frequency.
                                                                 Sets the SSC modulation frequency in steps of 250Hz 1LSB = 250Hz. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_cm0_pll_ssc_ctrl2_s cn; */
};
typedef union cavm_gsercx_cm0_pll_ssc_ctrl2 cavm_gsercx_cm0_pll_ssc_ctrl2_t;

static inline uint64_t CAVM_GSERCX_CM0_PLL_SSC_CTRL2(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_CM0_PLL_SSC_CTRL2(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a800ca90ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800ca90ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_CM0_PLL_SSC_CTRL2", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_CM0_PLL_SSC_CTRL2(a) cavm_gsercx_cm0_pll_ssc_ctrl2_t
#define bustype_CAVM_GSERCX_CM0_PLL_SSC_CTRL2(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_CM0_PLL_SSC_CTRL2(a) "GSERCX_CM0_PLL_SSC_CTRL2"
#define device_bar_CAVM_GSERCX_CM0_PLL_SSC_CTRL2(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_CM0_PLL_SSC_CTRL2(a) (a)
#define arguments_CAVM_GSERCX_CM0_PLL_SSC_CTRL2(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_ssc_ctrl3
 *
 * GSERC Cm0 Pll Ssc Ctrl3 Register
 */
union cavm_gsercx_cm0_pll_ssc_ctrl3
{
    uint32_t u;
    struct cavm_gsercx_cm0_pll_ssc_ctrl3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t updown                : 1;  /**< [  0:  0](R/W/H) SSC modulation spreading type.
                                                                 0 = down spreading only SSC modulation is only below the center frequency
                                                                 1 = both up and down spreading SSC modulation spreads equally above and below the center frequency */
#else /* Word 0 - Little Endian */
        uint32_t updown                : 1;  /**< [  0:  0](R/W/H) SSC modulation spreading type.
                                                                 0 = down spreading only SSC modulation is only below the center frequency
                                                                 1 = both up and down spreading SSC modulation spreads equally above and below the center frequency */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_cm0_pll_ssc_ctrl3_s cn; */
};
typedef union cavm_gsercx_cm0_pll_ssc_ctrl3 cavm_gsercx_cm0_pll_ssc_ctrl3_t;

static inline uint64_t CAVM_GSERCX_CM0_PLL_SSC_CTRL3(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_CM0_PLL_SSC_CTRL3(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a800ca98ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800ca98ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_CM0_PLL_SSC_CTRL3", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_CM0_PLL_SSC_CTRL3(a) cavm_gsercx_cm0_pll_ssc_ctrl3_t
#define bustype_CAVM_GSERCX_CM0_PLL_SSC_CTRL3(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_CM0_PLL_SSC_CTRL3(a) "GSERCX_CM0_PLL_SSC_CTRL3"
#define device_bar_CAVM_GSERCX_CM0_PLL_SSC_CTRL3(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_CM0_PLL_SSC_CTRL3(a) (a)
#define arguments_CAVM_GSERCX_CM0_PLL_SSC_CTRL3(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_afe_clkdiv_ctrl0
 *
 * GSERC Cm0 Rpll Afe Clkdiv Ctrl0 Register
 */
union cavm_gsercx_cm0_rpll_afe_clkdiv_ctrl0
{
    uint32_t u;
    struct cavm_gsercx_cm0_rpll_afe_clkdiv_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t cmpll2_ndiv           : 7;  /**< [  6:  0](R/W/H) PLL2 Feedback path programmable integer divider division control.

                                                                 Division ratio = register value + 2.
                                                                 Valid range of division ratios is from 4 to 129 */
#else /* Word 0 - Little Endian */
        uint32_t cmpll2_ndiv           : 7;  /**< [  6:  0](R/W/H) PLL2 Feedback path programmable integer divider division control.

                                                                 Division ratio = register value + 2.
                                                                 Valid range of division ratios is from 4 to 129 */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_cm0_rpll_afe_clkdiv_ctrl0_s cn; */
};
typedef union cavm_gsercx_cm0_rpll_afe_clkdiv_ctrl0 cavm_gsercx_cm0_rpll_afe_clkdiv_ctrl0_t;

static inline uint64_t CAVM_GSERCX_CM0_RPLL_AFE_CLKDIV_CTRL0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_CM0_RPLL_AFE_CLKDIV_CTRL0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a800d028ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d028ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_CM0_RPLL_AFE_CLKDIV_CTRL0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_CM0_RPLL_AFE_CLKDIV_CTRL0(a) cavm_gsercx_cm0_rpll_afe_clkdiv_ctrl0_t
#define bustype_CAVM_GSERCX_CM0_RPLL_AFE_CLKDIV_CTRL0(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_CM0_RPLL_AFE_CLKDIV_CTRL0(a) "GSERCX_CM0_RPLL_AFE_CLKDIV_CTRL0"
#define device_bar_CAVM_GSERCX_CM0_RPLL_AFE_CLKDIV_CTRL0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_CM0_RPLL_AFE_CLKDIV_CTRL0(a) (a)
#define arguments_CAVM_GSERCX_CM0_RPLL_AFE_CLKDIV_CTRL0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_afe_clock_ctrl0
 *
 * GSERC Cm0 Rpll Afe Clock Ctrl0 Register
 */
union cavm_gsercx_cm0_rpll_afe_clock_ctrl0
{
    uint32_t u;
    struct cavm_gsercx_cm0_rpll_afe_clock_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t cmpll2_refclk_sel     : 1;  /**< [  0:  0](R/W/H) Reference clock input source selection for RPLL.
                                                                 0 = external refclk
                                                                 1 = divided refclk from LCPLL */
#else /* Word 0 - Little Endian */
        uint32_t cmpll2_refclk_sel     : 1;  /**< [  0:  0](R/W/H) Reference clock input source selection for RPLL.
                                                                 0 = external refclk
                                                                 1 = divided refclk from LCPLL */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_cm0_rpll_afe_clock_ctrl0_s cn; */
};
typedef union cavm_gsercx_cm0_rpll_afe_clock_ctrl0 cavm_gsercx_cm0_rpll_afe_clock_ctrl0_t;

static inline uint64_t CAVM_GSERCX_CM0_RPLL_AFE_CLOCK_CTRL0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_CM0_RPLL_AFE_CLOCK_CTRL0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a800d018ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d018ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_CM0_RPLL_AFE_CLOCK_CTRL0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_CM0_RPLL_AFE_CLOCK_CTRL0(a) cavm_gsercx_cm0_rpll_afe_clock_ctrl0_t
#define bustype_CAVM_GSERCX_CM0_RPLL_AFE_CLOCK_CTRL0(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_CM0_RPLL_AFE_CLOCK_CTRL0(a) "GSERCX_CM0_RPLL_AFE_CLOCK_CTRL0"
#define device_bar_CAVM_GSERCX_CM0_RPLL_AFE_CLOCK_CTRL0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_CM0_RPLL_AFE_CLOCK_CTRL0(a) (a)
#define arguments_CAVM_GSERCX_CM0_RPLL_AFE_CLOCK_CTRL0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_fracn_ctrl0
 *
 * GSERC Cm0 Rpll Fracn Ctrl0 Register
 */
union cavm_gsercx_cm0_rpll_fracn_ctrl0
{
    uint32_t u;
    struct cavm_gsercx_cm0_rpll_fracn_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t en                    : 1;  /**< [  0:  0](R/W/H) Fractional division and SSC enable. */
#else /* Word 0 - Little Endian */
        uint32_t en                    : 1;  /**< [  0:  0](R/W/H) Fractional division and SSC enable. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_cm0_rpll_fracn_ctrl0_s cn; */
};
typedef union cavm_gsercx_cm0_rpll_fracn_ctrl0 cavm_gsercx_cm0_rpll_fracn_ctrl0_t;

static inline uint64_t CAVM_GSERCX_CM0_RPLL_FRACN_CTRL0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_CM0_RPLL_FRACN_CTRL0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a800d2a0ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d2a0ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_CM0_RPLL_FRACN_CTRL0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_CM0_RPLL_FRACN_CTRL0(a) cavm_gsercx_cm0_rpll_fracn_ctrl0_t
#define bustype_CAVM_GSERCX_CM0_RPLL_FRACN_CTRL0(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_CM0_RPLL_FRACN_CTRL0(a) "GSERCX_CM0_RPLL_FRACN_CTRL0"
#define device_bar_CAVM_GSERCX_CM0_RPLL_FRACN_CTRL0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_CM0_RPLL_FRACN_CTRL0(a) (a)
#define arguments_CAVM_GSERCX_CM0_RPLL_FRACN_CTRL0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_fracn_ctrl1
 *
 * GSERC Cm0 Rpll Fracn Ctrl1 Register
 */
union cavm_gsercx_cm0_rpll_fracn_ctrl1
{
    uint32_t u;
    struct cavm_gsercx_cm0_rpll_fracn_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t fdiv_7_0              : 8;  /**< [  7:  0](R/W/H) Fractional division value bits 7-0 of 20-bit value.
                                                                 Value is a 2's compliment number.
                                                                 Note that if SSC is also enabled then this is the center frequency around which
                                                                 SSC modulation occurs. */
#else /* Word 0 - Little Endian */
        uint32_t fdiv_7_0              : 8;  /**< [  7:  0](R/W/H) Fractional division value bits 7-0 of 20-bit value.
                                                                 Value is a 2's compliment number.
                                                                 Note that if SSC is also enabled then this is the center frequency around which
                                                                 SSC modulation occurs. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_cm0_rpll_fracn_ctrl1_s cn; */
};
typedef union cavm_gsercx_cm0_rpll_fracn_ctrl1 cavm_gsercx_cm0_rpll_fracn_ctrl1_t;

static inline uint64_t CAVM_GSERCX_CM0_RPLL_FRACN_CTRL1(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_CM0_RPLL_FRACN_CTRL1(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a800d2a8ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d2a8ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_CM0_RPLL_FRACN_CTRL1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_CM0_RPLL_FRACN_CTRL1(a) cavm_gsercx_cm0_rpll_fracn_ctrl1_t
#define bustype_CAVM_GSERCX_CM0_RPLL_FRACN_CTRL1(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_CM0_RPLL_FRACN_CTRL1(a) "GSERCX_CM0_RPLL_FRACN_CTRL1"
#define device_bar_CAVM_GSERCX_CM0_RPLL_FRACN_CTRL1(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_CM0_RPLL_FRACN_CTRL1(a) (a)
#define arguments_CAVM_GSERCX_CM0_RPLL_FRACN_CTRL1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_fracn_ctrl2
 *
 * GSERC Cm0 Rpll Fracn Ctrl2 Register
 */
union cavm_gsercx_cm0_rpll_fracn_ctrl2
{
    uint32_t u;
    struct cavm_gsercx_cm0_rpll_fracn_ctrl2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t fdiv_15_8             : 8;  /**< [  7:  0](R/W/H) Fractional division value bits 15-8 L of 20-bit value.
                                                                 Value is a 2's compliment number.
                                                                 Note that if SSC is also enabled then this is the center frequency around which
                                                                 SSC modulation occurs. */
#else /* Word 0 - Little Endian */
        uint32_t fdiv_15_8             : 8;  /**< [  7:  0](R/W/H) Fractional division value bits 15-8 L of 20-bit value.
                                                                 Value is a 2's compliment number.
                                                                 Note that if SSC is also enabled then this is the center frequency around which
                                                                 SSC modulation occurs. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_cm0_rpll_fracn_ctrl2_s cn; */
};
typedef union cavm_gsercx_cm0_rpll_fracn_ctrl2 cavm_gsercx_cm0_rpll_fracn_ctrl2_t;

static inline uint64_t CAVM_GSERCX_CM0_RPLL_FRACN_CTRL2(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_CM0_RPLL_FRACN_CTRL2(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a800d2b0ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d2b0ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_CM0_RPLL_FRACN_CTRL2", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_CM0_RPLL_FRACN_CTRL2(a) cavm_gsercx_cm0_rpll_fracn_ctrl2_t
#define bustype_CAVM_GSERCX_CM0_RPLL_FRACN_CTRL2(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_CM0_RPLL_FRACN_CTRL2(a) "GSERCX_CM0_RPLL_FRACN_CTRL2"
#define device_bar_CAVM_GSERCX_CM0_RPLL_FRACN_CTRL2(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_CM0_RPLL_FRACN_CTRL2(a) (a)
#define arguments_CAVM_GSERCX_CM0_RPLL_FRACN_CTRL2(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_fracn_ctrl3
 *
 * GSERC Cm0 Rpll Fracn Ctrl3 Register
 */
union cavm_gsercx_cm0_rpll_fracn_ctrl3
{
    uint32_t u;
    struct cavm_gsercx_cm0_rpll_fracn_ctrl3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t fdiv_19_16            : 4;  /**< [  3:  0](R/W/H) Fractional division value 19-16 of 20-bit value.
                                                                 Value is a 2's compliment number.
                                                                 Note that if SSC is also enabled then this is the center frequency around which
                                                                 SSC modulation occurs. */
#else /* Word 0 - Little Endian */
        uint32_t fdiv_19_16            : 4;  /**< [  3:  0](R/W/H) Fractional division value 19-16 of 20-bit value.
                                                                 Value is a 2's compliment number.
                                                                 Note that if SSC is also enabled then this is the center frequency around which
                                                                 SSC modulation occurs. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_cm0_rpll_fracn_ctrl3_s cn; */
};
typedef union cavm_gsercx_cm0_rpll_fracn_ctrl3 cavm_gsercx_cm0_rpll_fracn_ctrl3_t;

static inline uint64_t CAVM_GSERCX_CM0_RPLL_FRACN_CTRL3(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_CM0_RPLL_FRACN_CTRL3(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a800d2b8ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d2b8ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_CM0_RPLL_FRACN_CTRL3", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_CM0_RPLL_FRACN_CTRL3(a) cavm_gsercx_cm0_rpll_fracn_ctrl3_t
#define bustype_CAVM_GSERCX_CM0_RPLL_FRACN_CTRL3(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_CM0_RPLL_FRACN_CTRL3(a) "GSERCX_CM0_RPLL_FRACN_CTRL3"
#define device_bar_CAVM_GSERCX_CM0_RPLL_FRACN_CTRL3(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_CM0_RPLL_FRACN_CTRL3(a) (a)
#define arguments_CAVM_GSERCX_CM0_RPLL_FRACN_CTRL3(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_lockdet_status
 *
 * GSERC Cm0 Rpll Lockdet Status Register
 */
union cavm_gsercx_cm0_rpll_lockdet_status
{
    uint32_t u;
    struct cavm_gsercx_cm0_rpll_lockdet_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t toggled               : 1;  /**< [  1:  1](RO/H) Reserved. */
        uint32_t locked                : 1;  /**< [  0:  0](RO/H) PLL2 lock detection status signal
                                                                 0 = lock detection logic indicates that PLL is not locked
                                                                 1 = lock detection logic indicates that PLL is locked */
#else /* Word 0 - Little Endian */
        uint32_t locked                : 1;  /**< [  0:  0](RO/H) PLL2 lock detection status signal
                                                                 0 = lock detection logic indicates that PLL is not locked
                                                                 1 = lock detection logic indicates that PLL is locked */
        uint32_t toggled               : 1;  /**< [  1:  1](RO/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_cm0_rpll_lockdet_status_s cn; */
};
typedef union cavm_gsercx_cm0_rpll_lockdet_status cavm_gsercx_cm0_rpll_lockdet_status_t;

static inline uint64_t CAVM_GSERCX_CM0_RPLL_LOCKDET_STATUS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_CM0_RPLL_LOCKDET_STATUS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a800d230ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d230ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_CM0_RPLL_LOCKDET_STATUS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_CM0_RPLL_LOCKDET_STATUS(a) cavm_gsercx_cm0_rpll_lockdet_status_t
#define bustype_CAVM_GSERCX_CM0_RPLL_LOCKDET_STATUS(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_CM0_RPLL_LOCKDET_STATUS(a) "GSERCX_CM0_RPLL_LOCKDET_STATUS"
#define device_bar_CAVM_GSERCX_CM0_RPLL_LOCKDET_STATUS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_CM0_RPLL_LOCKDET_STATUS(a) (a)
#define arguments_CAVM_GSERCX_CM0_RPLL_LOCKDET_STATUS(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_ssc_ctrl0
 *
 * GSERC Cm0 Rpll Ssc Ctrl0 Register
 */
union cavm_gsercx_cm0_rpll_ssc_ctrl0
{
    uint32_t u;
    struct cavm_gsercx_cm0_rpll_ssc_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t en                    : 1;  /**< [  0:  0](R/W/H) Spread Spectrum Clocking SSC enable
                                                                 Note that to enable SSC the fractional division enable also needs to be asserted
                                                                 fracn_ctrl0 field en needs to be asserted. */
#else /* Word 0 - Little Endian */
        uint32_t en                    : 1;  /**< [  0:  0](R/W/H) Spread Spectrum Clocking SSC enable
                                                                 Note that to enable SSC the fractional division enable also needs to be asserted
                                                                 fracn_ctrl0 field en needs to be asserted. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_cm0_rpll_ssc_ctrl0_s cn; */
};
typedef union cavm_gsercx_cm0_rpll_ssc_ctrl0 cavm_gsercx_cm0_rpll_ssc_ctrl0_t;

static inline uint64_t CAVM_GSERCX_CM0_RPLL_SSC_CTRL0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_CM0_RPLL_SSC_CTRL0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a800d280ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d280ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_CM0_RPLL_SSC_CTRL0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_CM0_RPLL_SSC_CTRL0(a) cavm_gsercx_cm0_rpll_ssc_ctrl0_t
#define bustype_CAVM_GSERCX_CM0_RPLL_SSC_CTRL0(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_CM0_RPLL_SSC_CTRL0(a) "GSERCX_CM0_RPLL_SSC_CTRL0"
#define device_bar_CAVM_GSERCX_CM0_RPLL_SSC_CTRL0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_CM0_RPLL_SSC_CTRL0(a) (a)
#define arguments_CAVM_GSERCX_CM0_RPLL_SSC_CTRL0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_ssc_ctrl1
 *
 * GSERC Cm0 Rpll Ssc Ctrl1 Register
 */
union cavm_gsercx_cm0_rpll_ssc_ctrl1
{
    uint32_t u;
    struct cavm_gsercx_cm0_rpll_ssc_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t magnitude             : 8;  /**< [  7:  0](R/W/H) SSC modulation magnitude in units of Parts Per Million PPM.
                                                                 Register value is intepreted as PPM magnitude in steps of 20ppm 1LSB = 20ppm. */
#else /* Word 0 - Little Endian */
        uint32_t magnitude             : 8;  /**< [  7:  0](R/W/H) SSC modulation magnitude in units of Parts Per Million PPM.
                                                                 Register value is intepreted as PPM magnitude in steps of 20ppm 1LSB = 20ppm. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_cm0_rpll_ssc_ctrl1_s cn; */
};
typedef union cavm_gsercx_cm0_rpll_ssc_ctrl1 cavm_gsercx_cm0_rpll_ssc_ctrl1_t;

static inline uint64_t CAVM_GSERCX_CM0_RPLL_SSC_CTRL1(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_CM0_RPLL_SSC_CTRL1(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a800d288ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d288ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_CM0_RPLL_SSC_CTRL1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_CM0_RPLL_SSC_CTRL1(a) cavm_gsercx_cm0_rpll_ssc_ctrl1_t
#define bustype_CAVM_GSERCX_CM0_RPLL_SSC_CTRL1(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_CM0_RPLL_SSC_CTRL1(a) "GSERCX_CM0_RPLL_SSC_CTRL1"
#define device_bar_CAVM_GSERCX_CM0_RPLL_SSC_CTRL1(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_CM0_RPLL_SSC_CTRL1(a) (a)
#define arguments_CAVM_GSERCX_CM0_RPLL_SSC_CTRL1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_ssc_ctrl2
 *
 * GSERC Cm0 Rpll Ssc Ctrl2 Register
 */
union cavm_gsercx_cm0_rpll_ssc_ctrl2
{
    uint32_t u;
    struct cavm_gsercx_cm0_rpll_ssc_ctrl2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t freq                  : 8;  /**< [  7:  0](R/W/H) SSC modulation frequency.
                                                                 Sets the SSC modulation frequency in steps of 250Hz 1LSB = 250Hz. */
#else /* Word 0 - Little Endian */
        uint32_t freq                  : 8;  /**< [  7:  0](R/W/H) SSC modulation frequency.
                                                                 Sets the SSC modulation frequency in steps of 250Hz 1LSB = 250Hz. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_cm0_rpll_ssc_ctrl2_s cn; */
};
typedef union cavm_gsercx_cm0_rpll_ssc_ctrl2 cavm_gsercx_cm0_rpll_ssc_ctrl2_t;

static inline uint64_t CAVM_GSERCX_CM0_RPLL_SSC_CTRL2(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_CM0_RPLL_SSC_CTRL2(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a800d290ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d290ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_CM0_RPLL_SSC_CTRL2", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_CM0_RPLL_SSC_CTRL2(a) cavm_gsercx_cm0_rpll_ssc_ctrl2_t
#define bustype_CAVM_GSERCX_CM0_RPLL_SSC_CTRL2(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_CM0_RPLL_SSC_CTRL2(a) "GSERCX_CM0_RPLL_SSC_CTRL2"
#define device_bar_CAVM_GSERCX_CM0_RPLL_SSC_CTRL2(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_CM0_RPLL_SSC_CTRL2(a) (a)
#define arguments_CAVM_GSERCX_CM0_RPLL_SSC_CTRL2(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_ssc_ctrl3
 *
 * GSERC Cm0 Rpll Ssc Ctrl3 Register
 */
union cavm_gsercx_cm0_rpll_ssc_ctrl3
{
    uint32_t u;
    struct cavm_gsercx_cm0_rpll_ssc_ctrl3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t updown                : 1;  /**< [  0:  0](R/W/H) SSC modulation spreading type.
                                                                 0 = down spreading only SSC modulation is only below the center frequency
                                                                 1 = both up and down spreading SSC modulation spreads equally above and below the center frequency */
#else /* Word 0 - Little Endian */
        uint32_t updown                : 1;  /**< [  0:  0](R/W/H) SSC modulation spreading type.
                                                                 0 = down spreading only SSC modulation is only below the center frequency
                                                                 1 = both up and down spreading SSC modulation spreads equally above and below the center frequency */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_cm0_rpll_ssc_ctrl3_s cn; */
};
typedef union cavm_gsercx_cm0_rpll_ssc_ctrl3 cavm_gsercx_cm0_rpll_ssc_ctrl3_t;

static inline uint64_t CAVM_GSERCX_CM0_RPLL_SSC_CTRL3(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_CM0_RPLL_SSC_CTRL3(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a800d298ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d298ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_CM0_RPLL_SSC_CTRL3", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_CM0_RPLL_SSC_CTRL3(a) cavm_gsercx_cm0_rpll_ssc_ctrl3_t
#define bustype_CAVM_GSERCX_CM0_RPLL_SSC_CTRL3(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_CM0_RPLL_SSC_CTRL3(a) "GSERCX_CM0_RPLL_SSC_CTRL3"
#define device_bar_CAVM_GSERCX_CM0_RPLL_SSC_CTRL3(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_CM0_RPLL_SSC_CTRL3(a) (a)
#define arguments_CAVM_GSERCX_CM0_RPLL_SSC_CTRL3(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_top_afe_cmcp_ctrl0
 *
 * GSERC Cm0 Top Afe Cmcp Ctrl0 Register
 */
union cavm_gsercx_cm0_top_afe_cmcp_ctrl0
{
    uint32_t u;
    struct cavm_gsercx_cm0_top_afe_cmcp_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t cmcp_clkdiv_pll_div2  : 1;  /**< [  2:  2](R/W/H) CMU clock path CMCP PLL word clock to DPL DIV1/DIV2 pre-scaler division control.
                                                                 0x0 = DIV1
                                                                 0x1 = DIV2 */
        uint32_t cmcp_clkdiv           : 2;  /**< [  1:  0](R/W/H) CMU clock path CMCP PLL post-divider division control. This division setting
                                                                 applies to all PLL aka rate1, LCPLL clock paths.
                                                                 0x0 = DIV1
                                                                 0x1 = DIV2
                                                                 0x2 = DIV4
                                                                 0x3 = reserved */
#else /* Word 0 - Little Endian */
        uint32_t cmcp_clkdiv           : 2;  /**< [  1:  0](R/W/H) CMU clock path CMCP PLL post-divider division control. This division setting
                                                                 applies to all PLL aka rate1, LCPLL clock paths.
                                                                 0x0 = DIV1
                                                                 0x1 = DIV2
                                                                 0x2 = DIV4
                                                                 0x3 = reserved */
        uint32_t cmcp_clkdiv_pll_div2  : 1;  /**< [  2:  2](R/W/H) CMU clock path CMCP PLL word clock to DPL DIV1/DIV2 pre-scaler division control.
                                                                 0x0 = DIV1
                                                                 0x1 = DIV2 */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_cm0_top_afe_cmcp_ctrl0_s cn; */
};
typedef union cavm_gsercx_cm0_top_afe_cmcp_ctrl0 cavm_gsercx_cm0_top_afe_cmcp_ctrl0_t;

static inline uint64_t CAVM_GSERCX_CM0_TOP_AFE_CMCP_CTRL0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_CM0_TOP_AFE_CMCP_CTRL0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a800c100ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c100ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_CM0_TOP_AFE_CMCP_CTRL0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_CM0_TOP_AFE_CMCP_CTRL0(a) cavm_gsercx_cm0_top_afe_cmcp_ctrl0_t
#define bustype_CAVM_GSERCX_CM0_TOP_AFE_CMCP_CTRL0(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_CM0_TOP_AFE_CMCP_CTRL0(a) "GSERCX_CM0_TOP_AFE_CMCP_CTRL0"
#define device_bar_CAVM_GSERCX_CM0_TOP_AFE_CMCP_CTRL0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_CM0_TOP_AFE_CMCP_CTRL0(a) (a)
#define arguments_CAVM_GSERCX_CM0_TOP_AFE_CMCP_CTRL0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_top_afe_cmcp_ctrl1
 *
 * GSERC Cm0 Top Afe Cmcp Ctrl1 Register
 */
union cavm_gsercx_cm0_top_afe_cmcp_ctrl1
{
    uint32_t u;
    struct cavm_gsercx_cm0_top_afe_cmcp_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t cmcp_clkdiv_plldiv    : 4;  /**< [  7:  4](R/W/H) CMU clock path CMCP PLL word clock to DPL additional programmable divider
                                                                 division control. This divider affecs the output clock clk_plldiv.
                                                                 0x0 = DIV1
                                                                 0x1 = DIV2
                                                                 0x2 = DIV4
                                                                 0x3 = DIV5
                                                                 0x4 = DIV8
                                                                 0x5 = DIV10
                                                                 0x6 = DIV16
                                                                 0x7 = DIV 16.5
                                                                 0x8 = DIV 20 default for 40-bit parallel interface via gearbox
                                                                 0x9 = DIV 32
                                                                 0xA = DIV 33
                                                                 0xB = DIV 40
                                                                 0xC = DIV 66
                                                                 0xD = DIV 80
                                                                 0xE = DIV 90
                                                                 others = reserved */
        uint32_t cmcp_clkdiv_pll       : 4;  /**< [  3:  0](R/W/H) CMU clock path CMCP PLL word clock to DPL programmable divider division control.
                                                                 This divider affecs the output clock clk_pll.
                                                                 0x0 = DIV1
                                                                 0x1 = DIV2
                                                                 0x2 = DIV4
                                                                 0x3 = DIV5
                                                                 0x4 = DIV8
                                                                 0x5 = DIV10
                                                                 0x6 = DIV16 default for 32-bit parallel interface
                                                                 0x7 = DIV 16.5
                                                                 0x8 = DIV 20
                                                                 0x9 = DIV 32
                                                                 0xA = DIV 33
                                                                 0xB = DIV 40
                                                                 0xC = DIV 66
                                                                 0xD = DIV 80
                                                                 0xE = DIV 90
                                                                 others = reserved */
#else /* Word 0 - Little Endian */
        uint32_t cmcp_clkdiv_pll       : 4;  /**< [  3:  0](R/W/H) CMU clock path CMCP PLL word clock to DPL programmable divider division control.
                                                                 This divider affecs the output clock clk_pll.
                                                                 0x0 = DIV1
                                                                 0x1 = DIV2
                                                                 0x2 = DIV4
                                                                 0x3 = DIV5
                                                                 0x4 = DIV8
                                                                 0x5 = DIV10
                                                                 0x6 = DIV16 default for 32-bit parallel interface
                                                                 0x7 = DIV 16.5
                                                                 0x8 = DIV 20
                                                                 0x9 = DIV 32
                                                                 0xA = DIV 33
                                                                 0xB = DIV 40
                                                                 0xC = DIV 66
                                                                 0xD = DIV 80
                                                                 0xE = DIV 90
                                                                 others = reserved */
        uint32_t cmcp_clkdiv_plldiv    : 4;  /**< [  7:  4](R/W/H) CMU clock path CMCP PLL word clock to DPL additional programmable divider
                                                                 division control. This divider affecs the output clock clk_plldiv.
                                                                 0x0 = DIV1
                                                                 0x1 = DIV2
                                                                 0x2 = DIV4
                                                                 0x3 = DIV5
                                                                 0x4 = DIV8
                                                                 0x5 = DIV10
                                                                 0x6 = DIV16
                                                                 0x7 = DIV 16.5
                                                                 0x8 = DIV 20 default for 40-bit parallel interface via gearbox
                                                                 0x9 = DIV 32
                                                                 0xA = DIV 33
                                                                 0xB = DIV 40
                                                                 0xC = DIV 66
                                                                 0xD = DIV 80
                                                                 0xE = DIV 90
                                                                 others = reserved */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_cm0_top_afe_cmcp_ctrl1_s cn; */
};
typedef union cavm_gsercx_cm0_top_afe_cmcp_ctrl1 cavm_gsercx_cm0_top_afe_cmcp_ctrl1_t;

static inline uint64_t CAVM_GSERCX_CM0_TOP_AFE_CMCP_CTRL1(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_CM0_TOP_AFE_CMCP_CTRL1(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a800c108ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c108ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_CM0_TOP_AFE_CMCP_CTRL1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_CM0_TOP_AFE_CMCP_CTRL1(a) cavm_gsercx_cm0_top_afe_cmcp_ctrl1_t
#define bustype_CAVM_GSERCX_CM0_TOP_AFE_CMCP_CTRL1(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_CM0_TOP_AFE_CMCP_CTRL1(a) "GSERCX_CM0_TOP_AFE_CMCP_CTRL1"
#define device_bar_CAVM_GSERCX_CM0_TOP_AFE_CMCP_CTRL1(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_CM0_TOP_AFE_CMCP_CTRL1(a) (a)
#define arguments_CAVM_GSERCX_CM0_TOP_AFE_CMCP_CTRL1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_top_afe_cmcp_ctrl2
 *
 * GSERC Cm0 Top Afe Cmcp Ctrl2 Register
 */
union cavm_gsercx_cm0_top_afe_cmcp_ctrl2
{
    uint32_t u;
    struct cavm_gsercx_cm0_top_afe_cmcp_ctrl2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t cmcp_clkdiv_pll3_div2 : 1;  /**< [  3:  3](R/W/H) CMU clock path CMCP PLL3 word clock to DPL DIV1/DIV2 pre-scaler division control.
                                                                 0x0 = DIV1
                                                                 0x1 = DIV2 */
        uint32_t cmcp_clkdiv_pll2_div2 : 1;  /**< [  2:  2](R/W/H) CMU clock path CMCP PLL2 word clock to DPL DIV1/DIV2 pre-scaler division control.
                                                                 0x0 = DIV1
                                                                 0x1 = DIV2 */
        uint32_t cmcp_clkdiv2          : 2;  /**< [  1:  0](R/W/H) CMU clock path CMCP PLL2 post-divider division control. This division setting
                                                                 applies to all PLL2 aka rate2, RPLL clock paths.
                                                                 0x0 = DIV1
                                                                 0x1 = DIV2
                                                                 0x2 = DIV4
                                                                 0x3 = reserved */
#else /* Word 0 - Little Endian */
        uint32_t cmcp_clkdiv2          : 2;  /**< [  1:  0](R/W/H) CMU clock path CMCP PLL2 post-divider division control. This division setting
                                                                 applies to all PLL2 aka rate2, RPLL clock paths.
                                                                 0x0 = DIV1
                                                                 0x1 = DIV2
                                                                 0x2 = DIV4
                                                                 0x3 = reserved */
        uint32_t cmcp_clkdiv_pll2_div2 : 1;  /**< [  2:  2](R/W/H) CMU clock path CMCP PLL2 word clock to DPL DIV1/DIV2 pre-scaler division control.
                                                                 0x0 = DIV1
                                                                 0x1 = DIV2 */
        uint32_t cmcp_clkdiv_pll3_div2 : 1;  /**< [  3:  3](R/W/H) CMU clock path CMCP PLL3 word clock to DPL DIV1/DIV2 pre-scaler division control.
                                                                 0x0 = DIV1
                                                                 0x1 = DIV2 */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_cm0_top_afe_cmcp_ctrl2_s cn; */
};
typedef union cavm_gsercx_cm0_top_afe_cmcp_ctrl2 cavm_gsercx_cm0_top_afe_cmcp_ctrl2_t;

static inline uint64_t CAVM_GSERCX_CM0_TOP_AFE_CMCP_CTRL2(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_CM0_TOP_AFE_CMCP_CTRL2(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a800c110ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c110ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_CM0_TOP_AFE_CMCP_CTRL2", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_CM0_TOP_AFE_CMCP_CTRL2(a) cavm_gsercx_cm0_top_afe_cmcp_ctrl2_t
#define bustype_CAVM_GSERCX_CM0_TOP_AFE_CMCP_CTRL2(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_CM0_TOP_AFE_CMCP_CTRL2(a) "GSERCX_CM0_TOP_AFE_CMCP_CTRL2"
#define device_bar_CAVM_GSERCX_CM0_TOP_AFE_CMCP_CTRL2(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_CM0_TOP_AFE_CMCP_CTRL2(a) (a)
#define arguments_CAVM_GSERCX_CM0_TOP_AFE_CMCP_CTRL2(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_top_afe_cmcp_ctrl3
 *
 * GSERC Cm0 Top Afe Cmcp Ctrl3 Register
 */
union cavm_gsercx_cm0_top_afe_cmcp_ctrl3
{
    uint32_t u;
    struct cavm_gsercx_cm0_top_afe_cmcp_ctrl3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t cmcp_clkdiv_pll2div   : 4;  /**< [  7:  4](R/W/H) CMU clock path CMCP PLL2 word clock to DPL additional programmable divider
                                                                 division control. This divider affecs the output clock clk_pll2div.
                                                                 0x0 = DIV1
                                                                 0x1 = DIV2
                                                                 0x2 = DIV4
                                                                 0x3 = DIV5
                                                                 0x4 = DIV8
                                                                 0x5 = DIV10
                                                                 0x6 = DIV16
                                                                 0x7 = DIV 16.5
                                                                 0x8 = DIV 20 default for 40-bit parallel interface via gearbox
                                                                 0x9 = DIV 32
                                                                 0xA = DIV 33
                                                                 0xB = DIV 40
                                                                 0xC = DIV 66
                                                                 0xD = DIV 80
                                                                 0xE = DIV 90
                                                                 others = reserved */
        uint32_t cmcp_clkdiv_pll2      : 4;  /**< [  3:  0](R/W/H) CMU clock path CMCP PLL2 word clock to DPL programmable divider division
                                                                 control. This divider affecs the output clock clk_pll2.
                                                                 0x0 = DIV1
                                                                 0x1 = DIV2
                                                                 0x2 = DIV4
                                                                 0x3 = DIV5
                                                                 0x4 = DIV8
                                                                 0x5 = DIV10
                                                                 0x6 = DIV16 default for 32-bit parallel interface
                                                                 0x7 = DIV 16.5
                                                                 0x8 = DIV 20
                                                                 0x9 = DIV 32
                                                                 0xA = DIV 33
                                                                 0xB = DIV 40
                                                                 0xC = DIV 66
                                                                 0xD = DIV 80
                                                                 0xE = DIV 90
                                                                 others = reserved */
#else /* Word 0 - Little Endian */
        uint32_t cmcp_clkdiv_pll2      : 4;  /**< [  3:  0](R/W/H) CMU clock path CMCP PLL2 word clock to DPL programmable divider division
                                                                 control. This divider affecs the output clock clk_pll2.
                                                                 0x0 = DIV1
                                                                 0x1 = DIV2
                                                                 0x2 = DIV4
                                                                 0x3 = DIV5
                                                                 0x4 = DIV8
                                                                 0x5 = DIV10
                                                                 0x6 = DIV16 default for 32-bit parallel interface
                                                                 0x7 = DIV 16.5
                                                                 0x8 = DIV 20
                                                                 0x9 = DIV 32
                                                                 0xA = DIV 33
                                                                 0xB = DIV 40
                                                                 0xC = DIV 66
                                                                 0xD = DIV 80
                                                                 0xE = DIV 90
                                                                 others = reserved */
        uint32_t cmcp_clkdiv_pll2div   : 4;  /**< [  7:  4](R/W/H) CMU clock path CMCP PLL2 word clock to DPL additional programmable divider
                                                                 division control. This divider affecs the output clock clk_pll2div.
                                                                 0x0 = DIV1
                                                                 0x1 = DIV2
                                                                 0x2 = DIV4
                                                                 0x3 = DIV5
                                                                 0x4 = DIV8
                                                                 0x5 = DIV10
                                                                 0x6 = DIV16
                                                                 0x7 = DIV 16.5
                                                                 0x8 = DIV 20 default for 40-bit parallel interface via gearbox
                                                                 0x9 = DIV 32
                                                                 0xA = DIV 33
                                                                 0xB = DIV 40
                                                                 0xC = DIV 66
                                                                 0xD = DIV 80
                                                                 0xE = DIV 90
                                                                 others = reserved */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_cm0_top_afe_cmcp_ctrl3_s cn; */
};
typedef union cavm_gsercx_cm0_top_afe_cmcp_ctrl3 cavm_gsercx_cm0_top_afe_cmcp_ctrl3_t;

static inline uint64_t CAVM_GSERCX_CM0_TOP_AFE_CMCP_CTRL3(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_CM0_TOP_AFE_CMCP_CTRL3(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a800c118ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c118ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_CM0_TOP_AFE_CMCP_CTRL3", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_CM0_TOP_AFE_CMCP_CTRL3(a) cavm_gsercx_cm0_top_afe_cmcp_ctrl3_t
#define bustype_CAVM_GSERCX_CM0_TOP_AFE_CMCP_CTRL3(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_CM0_TOP_AFE_CMCP_CTRL3(a) "GSERCX_CM0_TOP_AFE_CMCP_CTRL3"
#define device_bar_CAVM_GSERCX_CM0_TOP_AFE_CMCP_CTRL3(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_CM0_TOP_AFE_CMCP_CTRL3(a) (a)
#define arguments_CAVM_GSERCX_CM0_TOP_AFE_CMCP_CTRL3(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_top_afe_cmcp_ctrl4
 *
 * GSERC Cm0 Top Afe Cmcp Ctrl4 Register
 */
union cavm_gsercx_cm0_top_afe_cmcp_ctrl4
{
    uint32_t u;
    struct cavm_gsercx_cm0_top_afe_cmcp_ctrl4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t cmcp_clkdiv_pll3div   : 4;  /**< [  7:  4](R/W/H) CMU clock path CMCP PLL2 word clock to DPL additional programmable divider
                                                                 division control. This divider affecs the output clock clk_pll2div.
                                                                 0x0 = DIV5
                                                                 0x1 = DIV10 default for 40-bit parallel interface via gearbox
                                                                 0x2 = DIV2.5
                                                                 others = reserved */
        uint32_t cmcp_clkdiv_pll3      : 4;  /**< [  3:  0](R/W/H) CMU clock path CMCP PLL3 word clock to DPL programmable divider division
                                                                 control. This divider affecs the output clock clk_pll3.
                                                                 0x0 = DIV4
                                                                 0x1 = DIV8 default for 32-bit parallel interface
                                                                 others = reserved */
#else /* Word 0 - Little Endian */
        uint32_t cmcp_clkdiv_pll3      : 4;  /**< [  3:  0](R/W/H) CMU clock path CMCP PLL3 word clock to DPL programmable divider division
                                                                 control. This divider affecs the output clock clk_pll3.
                                                                 0x0 = DIV4
                                                                 0x1 = DIV8 default for 32-bit parallel interface
                                                                 others = reserved */
        uint32_t cmcp_clkdiv_pll3div   : 4;  /**< [  7:  4](R/W/H) CMU clock path CMCP PLL2 word clock to DPL additional programmable divider
                                                                 division control. This divider affecs the output clock clk_pll2div.
                                                                 0x0 = DIV5
                                                                 0x1 = DIV10 default for 40-bit parallel interface via gearbox
                                                                 0x2 = DIV2.5
                                                                 others = reserved */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_cm0_top_afe_cmcp_ctrl4_s cn; */
};
typedef union cavm_gsercx_cm0_top_afe_cmcp_ctrl4 cavm_gsercx_cm0_top_afe_cmcp_ctrl4_t;

static inline uint64_t CAVM_GSERCX_CM0_TOP_AFE_CMCP_CTRL4(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_CM0_TOP_AFE_CMCP_CTRL4(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a800c120ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c120ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_CM0_TOP_AFE_CMCP_CTRL4", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_CM0_TOP_AFE_CMCP_CTRL4(a) cavm_gsercx_cm0_top_afe_cmcp_ctrl4_t
#define bustype_CAVM_GSERCX_CM0_TOP_AFE_CMCP_CTRL4(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_CM0_TOP_AFE_CMCP_CTRL4(a) "GSERCX_CM0_TOP_AFE_CMCP_CTRL4"
#define device_bar_CAVM_GSERCX_CM0_TOP_AFE_CMCP_CTRL4(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_CM0_TOP_AFE_CMCP_CTRL4(a) (a)
#define arguments_CAVM_GSERCX_CM0_TOP_AFE_CMCP_CTRL4(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_top_afe_refclk_ctrl0
 *
 * GSERC Cm0 Top Afe Refclk Ctrl0 Register
 */
union cavm_gsercx_cm0_top_afe_refclk_ctrl0
{
    uint32_t u;
    struct cavm_gsercx_cm0_top_afe_refclk_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t refclk_dpl_div        : 2;  /**< [  3:  2](R/W/H) Reserved. */
        uint32_t refclk_div            : 2;  /**< [  1:  0](R/W/H) Reference clock input buffer division control.
                                                                 0x0 = DIV1
                                                                 0x1 = DIV2
                                                                 0x2 = DIV3
                                                                 0x3 = DIV4 */
#else /* Word 0 - Little Endian */
        uint32_t refclk_div            : 2;  /**< [  1:  0](R/W/H) Reference clock input buffer division control.
                                                                 0x0 = DIV1
                                                                 0x1 = DIV2
                                                                 0x2 = DIV3
                                                                 0x3 = DIV4 */
        uint32_t refclk_dpl_div        : 2;  /**< [  3:  2](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_cm0_top_afe_refclk_ctrl0_s cn; */
};
typedef union cavm_gsercx_cm0_top_afe_refclk_ctrl0 cavm_gsercx_cm0_top_afe_refclk_ctrl0_t;

static inline uint64_t CAVM_GSERCX_CM0_TOP_AFE_REFCLK_CTRL0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_CM0_TOP_AFE_REFCLK_CTRL0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a800c0d0ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c0d0ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_CM0_TOP_AFE_REFCLK_CTRL0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_CM0_TOP_AFE_REFCLK_CTRL0(a) cavm_gsercx_cm0_top_afe_refclk_ctrl0_t
#define bustype_CAVM_GSERCX_CM0_TOP_AFE_REFCLK_CTRL0(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_CM0_TOP_AFE_REFCLK_CTRL0(a) "GSERCX_CM0_TOP_AFE_REFCLK_CTRL0"
#define device_bar_CAVM_GSERCX_CM0_TOP_AFE_REFCLK_CTRL0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_CM0_TOP_AFE_REFCLK_CTRL0(a) (a)
#define arguments_CAVM_GSERCX_CM0_TOP_AFE_REFCLK_CTRL0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_top_afe_tstclk_ctrl0
 *
 * GSERC Cm0 Top Afe Tstclk Ctrl0 Register
 */
union cavm_gsercx_cm0_top_afe_tstclk_ctrl0
{
    uint32_t u;
    struct cavm_gsercx_cm0_top_afe_tstclk_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t cmcp_tstclk_div       : 4;  /**< [  6:  3](R/W/H) CMU test clock path division control.
                                                                 0x0 = DIV1
                                                                 0x1 = DIV2
                                                                 0x2 = DIV4
                                                                 0x3 = DIV5
                                                                 0x4 = DIV8
                                                                 0x5 = DIV10
                                                                 0x6 = DIV16
                                                                 0x7 = DIV 16.5
                                                                 0x8 = DIV 20
                                                                 0x9 = DIV 32
                                                                 0xA = DIV 33
                                                                 0xB = DIV 40
                                                                 0xC = DIV 66
                                                                 0xD = DIV 80
                                                                 0xE = DIV 90
                                                                 others = reserved */
        uint32_t cmcp_tstclk_mux       : 3;  /**< [  2:  0](R/W/H) CMU test clock selection. Further descriptions will be provided in future updates.
                                                                 0x0 = power down test clock path
                                                                 0x1 = input refclk to PLL i.e., LCPLL
                                                                 0x2 = input refclk to PLL2 i.e. RPLL
                                                                 0x3 = life clock
                                                                 0x4 = clk_pll
                                                                 0x5 = clk_plldiv
                                                                 0x6 = clk_pll2
                                                                 0x7 = clk_pll2div */
#else /* Word 0 - Little Endian */
        uint32_t cmcp_tstclk_mux       : 3;  /**< [  2:  0](R/W/H) CMU test clock selection. Further descriptions will be provided in future updates.
                                                                 0x0 = power down test clock path
                                                                 0x1 = input refclk to PLL i.e., LCPLL
                                                                 0x2 = input refclk to PLL2 i.e. RPLL
                                                                 0x3 = life clock
                                                                 0x4 = clk_pll
                                                                 0x5 = clk_plldiv
                                                                 0x6 = clk_pll2
                                                                 0x7 = clk_pll2div */
        uint32_t cmcp_tstclk_div       : 4;  /**< [  6:  3](R/W/H) CMU test clock path division control.
                                                                 0x0 = DIV1
                                                                 0x1 = DIV2
                                                                 0x2 = DIV4
                                                                 0x3 = DIV5
                                                                 0x4 = DIV8
                                                                 0x5 = DIV10
                                                                 0x6 = DIV16
                                                                 0x7 = DIV 16.5
                                                                 0x8 = DIV 20
                                                                 0x9 = DIV 32
                                                                 0xA = DIV 33
                                                                 0xB = DIV 40
                                                                 0xC = DIV 66
                                                                 0xD = DIV 80
                                                                 0xE = DIV 90
                                                                 others = reserved */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_cm0_top_afe_tstclk_ctrl0_s cn; */
};
typedef union cavm_gsercx_cm0_top_afe_tstclk_ctrl0 cavm_gsercx_cm0_top_afe_tstclk_ctrl0_t;

static inline uint64_t CAVM_GSERCX_CM0_TOP_AFE_TSTCLK_CTRL0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_CM0_TOP_AFE_TSTCLK_CTRL0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a800c150ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c150ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_CM0_TOP_AFE_TSTCLK_CTRL0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_CM0_TOP_AFE_TSTCLK_CTRL0(a) cavm_gsercx_cm0_top_afe_tstclk_ctrl0_t
#define bustype_CAVM_GSERCX_CM0_TOP_AFE_TSTCLK_CTRL0(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_CM0_TOP_AFE_TSTCLK_CTRL0(a) "GSERCX_CM0_TOP_AFE_TSTCLK_CTRL0"
#define device_bar_CAVM_GSERCX_CM0_TOP_AFE_TSTCLK_CTRL0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_CM0_TOP_AFE_TSTCLK_CTRL0(a) (a)
#define arguments_CAVM_GSERCX_CM0_TOP_AFE_TSTCLK_CTRL0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_top_cmu_ctrl_ovr1
 *
 * GSERC Cm0 Top Cmu Ctrl Ovr1 Register
 */
union cavm_gsercx_cm0_top_cmu_ctrl_ovr1
{
    uint32_t u;
    struct cavm_gsercx_cm0_top_cmu_ctrl_ovr1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t iddq                  : 1;  /**< [  4:  4](R/W/H) Override value for HSS_CM0_IDDQ_I cmu_iddq_i.  It takes effect when ovr_en is 1.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t rst_n                 : 1;  /**< [  3:  3](R/W/H) Override value for HSS_CM0_RST_N_I cmu_rst_n_i.  It takes effect when ovr_en is 1.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t pd                    : 2;  /**< [  2:  1](R/W/H) Override value for HSS_CM0_PD_I[1:0] cmu_pd_i[1:0].  It takes effect when ovr_en is 1.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t ovr_en                : 1;  /**< [  0:  0](R/W/H) Override enable for cmu_pd_i[1:0] and cmu_rst_n_i.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
#else /* Word 0 - Little Endian */
        uint32_t ovr_en                : 1;  /**< [  0:  0](R/W/H) Override enable for cmu_pd_i[1:0] and cmu_rst_n_i.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t pd                    : 2;  /**< [  2:  1](R/W/H) Override value for HSS_CM0_PD_I[1:0] cmu_pd_i[1:0].  It takes effect when ovr_en is 1.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t rst_n                 : 1;  /**< [  3:  3](R/W/H) Override value for HSS_CM0_RST_N_I cmu_rst_n_i.  It takes effect when ovr_en is 1.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t iddq                  : 1;  /**< [  4:  4](R/W/H) Override value for HSS_CM0_IDDQ_I cmu_iddq_i.  It takes effect when ovr_en is 1.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_cm0_top_cmu_ctrl_ovr1_s cn; */
};
typedef union cavm_gsercx_cm0_top_cmu_ctrl_ovr1 cavm_gsercx_cm0_top_cmu_ctrl_ovr1_t;

static inline uint64_t CAVM_GSERCX_CM0_TOP_CMU_CTRL_OVR1(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_CM0_TOP_CMU_CTRL_OVR1(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a800c460ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c460ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_CM0_TOP_CMU_CTRL_OVR1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_CM0_TOP_CMU_CTRL_OVR1(a) cavm_gsercx_cm0_top_cmu_ctrl_ovr1_t
#define bustype_CAVM_GSERCX_CM0_TOP_CMU_CTRL_OVR1(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_CM0_TOP_CMU_CTRL_OVR1(a) "GSERCX_CM0_TOP_CMU_CTRL_OVR1"
#define device_bar_CAVM_GSERCX_CM0_TOP_CMU_CTRL_OVR1(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_CM0_TOP_CMU_CTRL_OVR1(a) (a)
#define arguments_CAVM_GSERCX_CM0_TOP_CMU_CTRL_OVR1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_top_cmu_stat_status0
 *
 * GSERC Cm0 Top Cmu Stat Status0 Register
 */
union cavm_gsercx_cm0_top_cmu_stat_status0
{
    uint32_t u;
    struct cavm_gsercx_cm0_top_cmu_stat_status0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t state_chng_rdy        : 1;  /**< [  0:  0](RO/H) Value of HSS_CM0_state_chng_rdy_O cmu_state_chng_rdy_o.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
#else /* Word 0 - Little Endian */
        uint32_t state_chng_rdy        : 1;  /**< [  0:  0](RO/H) Value of HSS_CM0_state_chng_rdy_O cmu_state_chng_rdy_o.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_cm0_top_cmu_stat_status0_s cn; */
};
typedef union cavm_gsercx_cm0_top_cmu_stat_status0 cavm_gsercx_cm0_top_cmu_stat_status0_t;

static inline uint64_t CAVM_GSERCX_CM0_TOP_CMU_STAT_STATUS0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_CM0_TOP_CMU_STAT_STATUS0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a800c458ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c458ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_CM0_TOP_CMU_STAT_STATUS0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_CM0_TOP_CMU_STAT_STATUS0(a) cavm_gsercx_cm0_top_cmu_stat_status0_t
#define bustype_CAVM_GSERCX_CM0_TOP_CMU_STAT_STATUS0(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_CM0_TOP_CMU_STAT_STATUS0(a) "GSERCX_CM0_TOP_CMU_STAT_STATUS0"
#define device_bar_CAVM_GSERCX_CM0_TOP_CMU_STAT_STATUS0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_CM0_TOP_CMU_STAT_STATUS0(a) (a)
#define arguments_CAVM_GSERCX_CM0_TOP_CMU_STAT_STATUS0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_top_err_ctrl1
 *
 * GSERC Cm0 Top Err Ctrl1 Register
 */
union cavm_gsercx_cm0_top_err_ctrl1
{
    uint32_t u;
    struct cavm_gsercx_cm0_top_err_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t err_code_7_0          : 8;  /**< [  7:  0](R/W/H) CMU top-level firmware error code lower 8-bits of 16-bit error code. */
#else /* Word 0 - Little Endian */
        uint32_t err_code_7_0          : 8;  /**< [  7:  0](R/W/H) CMU top-level firmware error code lower 8-bits of 16-bit error code. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_cm0_top_err_ctrl1_s cn; */
};
typedef union cavm_gsercx_cm0_top_err_ctrl1 cavm_gsercx_cm0_top_err_ctrl1_t;

static inline uint64_t CAVM_GSERCX_CM0_TOP_ERR_CTRL1(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_CM0_TOP_ERR_CTRL1(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a800c400ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c400ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_CM0_TOP_ERR_CTRL1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_CM0_TOP_ERR_CTRL1(a) cavm_gsercx_cm0_top_err_ctrl1_t
#define bustype_CAVM_GSERCX_CM0_TOP_ERR_CTRL1(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_CM0_TOP_ERR_CTRL1(a) "GSERCX_CM0_TOP_ERR_CTRL1"
#define device_bar_CAVM_GSERCX_CM0_TOP_ERR_CTRL1(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_CM0_TOP_ERR_CTRL1(a) (a)
#define arguments_CAVM_GSERCX_CM0_TOP_ERR_CTRL1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_top_err_ctrl2
 *
 * GSERC Cm0 Top Err Ctrl2 Register
 */
union cavm_gsercx_cm0_top_err_ctrl2
{
    uint32_t u;
    struct cavm_gsercx_cm0_top_err_ctrl2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t err_code_15_8         : 8;  /**< [  7:  0](R/W/H) CMU top-level firmware error code higher 8-bits of 16-bit error code. */
#else /* Word 0 - Little Endian */
        uint32_t err_code_15_8         : 8;  /**< [  7:  0](R/W/H) CMU top-level firmware error code higher 8-bits of 16-bit error code. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_cm0_top_err_ctrl2_s cn; */
};
typedef union cavm_gsercx_cm0_top_err_ctrl2 cavm_gsercx_cm0_top_err_ctrl2_t;

static inline uint64_t CAVM_GSERCX_CM0_TOP_ERR_CTRL2(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_CM0_TOP_ERR_CTRL2(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a800c408ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c408ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_CM0_TOP_ERR_CTRL2", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_CM0_TOP_ERR_CTRL2(a) cavm_gsercx_cm0_top_err_ctrl2_t
#define bustype_CAVM_GSERCX_CM0_TOP_ERR_CTRL2(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_CM0_TOP_ERR_CTRL2(a) "GSERCX_CM0_TOP_ERR_CTRL2"
#define device_bar_CAVM_GSERCX_CM0_TOP_ERR_CTRL2(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_CM0_TOP_ERR_CTRL2(a) (a)
#define arguments_CAVM_GSERCX_CM0_TOP_ERR_CTRL2(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_top_err_ctrl3
 *
 * GSERC Cm0 Top Err Ctrl3 Register
 */
union cavm_gsercx_cm0_top_err_ctrl3
{
    uint32_t u;
    struct cavm_gsercx_cm0_top_err_ctrl3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t critical_err          : 1;  /**< [  0:  0](R/W/H) CMU critical error status.
                                                                 1 indicates that a critical error has occurred. cm0_ok_o is gated when this is set to 1 */
#else /* Word 0 - Little Endian */
        uint32_t critical_err          : 1;  /**< [  0:  0](R/W/H) CMU critical error status.
                                                                 1 indicates that a critical error has occurred. cm0_ok_o is gated when this is set to 1 */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_cm0_top_err_ctrl3_s cn; */
};
typedef union cavm_gsercx_cm0_top_err_ctrl3 cavm_gsercx_cm0_top_err_ctrl3_t;

static inline uint64_t CAVM_GSERCX_CM0_TOP_ERR_CTRL3(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_CM0_TOP_ERR_CTRL3(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a800c410ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c410ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_CM0_TOP_ERR_CTRL3", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_CM0_TOP_ERR_CTRL3(a) cavm_gsercx_cm0_top_err_ctrl3_t
#define bustype_CAVM_GSERCX_CM0_TOP_ERR_CTRL3(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_CM0_TOP_ERR_CTRL3(a) "GSERCX_CM0_TOP_ERR_CTRL3"
#define device_bar_CAVM_GSERCX_CM0_TOP_ERR_CTRL3(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_CM0_TOP_ERR_CTRL3(a) (a)
#define arguments_CAVM_GSERCX_CM0_TOP_ERR_CTRL3(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_top_phy_if_status
 *
 * GSERC Cm0 Top Phy If Status Register
 */
union cavm_gsercx_cm0_top_phy_if_status
{
    uint32_t u;
    struct cavm_gsercx_cm0_top_phy_if_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t cmu_ok                : 1;  /**< [  0:  0](RO/H) CMU OK status. */
#else /* Word 0 - Little Endian */
        uint32_t cmu_ok                : 1;  /**< [  0:  0](RO/H) CMU OK status. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_cm0_top_phy_if_status_s cn; */
};
typedef union cavm_gsercx_cm0_top_phy_if_status cavm_gsercx_cm0_top_phy_if_status_t;

static inline uint64_t CAVM_GSERCX_CM0_TOP_PHY_IF_STATUS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_CM0_TOP_PHY_IF_STATUS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a800c290ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c290ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_CM0_TOP_PHY_IF_STATUS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_CM0_TOP_PHY_IF_STATUS(a) cavm_gsercx_cm0_top_phy_if_status_t
#define bustype_CAVM_GSERCX_CM0_TOP_PHY_IF_STATUS(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_CM0_TOP_PHY_IF_STATUS(a) "GSERCX_CM0_TOP_PHY_IF_STATUS"
#define device_bar_CAVM_GSERCX_CM0_TOP_PHY_IF_STATUS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_CM0_TOP_PHY_IF_STATUS(a) (a)
#define arguments_CAVM_GSERCX_CM0_TOP_PHY_IF_STATUS(a) (a),-1,-1,-1

/**
 * Register (RSL) gserc#_common_phy_ctrl_bcfg
 *
 * GSERC PHY Common Control Register
 */
union cavm_gsercx_common_phy_ctrl_bcfg
{
    uint64_t u;
    struct cavm_gsercx_common_phy_ctrl_bcfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_47_63        : 17;
        uint64_t refclk_override       : 1;  /**< [ 46: 46](R/W) During a cold reset, the following fields are populated by HW.   When
                                                                 REFCLK_OVERRIDE=0, writes to these fields are ignored.
                                                                 When REFCLK_OVERRIDE=1, writes to these fields are applied. For diagnostic use only.

                                                                   REFCLK_A_OE_L.
                                                                   REFCLK_A_OE_R.
                                                                   REFCLK_B_OE_L.
                                                                   REFCLK_B_OE_R.
                                                                   REFCLK_RIGHT_OUTPUT_SEL.
                                                                   REFCLK_LEFT_OUTPUT_SEL.
                                                                   PHY_REXT_MASTER. */
        uint64_t apb_reset             : 1;  /**< [ 45: 45](R/W) Reset for CPU's APB bus. Must be set to zero prior to accessing APB bus via JTAG or RSL.
                                                                   0x0 = APB bus reset deasserted.
                                                                   0x1 = APB bus reset asserted. */
        uint64_t dis_apb_csr_addr_filter : 1;/**< [ 44: 44](R/W) Reserved. */
        uint64_t pmem_wr_prot          : 1;  /**< [ 43: 43](R/W) Write Protect for CPU Program Memory. If write protection is desired on PMEM,
                                                                 this bit should be set to 0x1 prior to asserting POR or CPU_RESET. This bit may be written
                                                                 to 0x0 or 0x1 by software as necessary.
                                                                   0x0 = Program Memory may be written (not write protected).
                                                                   0x1 = Program Memory cannot be written (write protected). */
        uint64_t reserved_41_42        : 2;
        uint64_t phy_rext_master       : 1;  /**< [ 40: 40](R/W/H) REXT master select:
                                                                   0x0 = PHY is a slave.
                                                                   0x1 = PHY is the master. */
        uint64_t refclk_a_oe_l         : 1;  /**< [ 39: 39](R/W/H) Output enables for the CML output buffers that drive reference
                                                                 clock "A" out of the bottom of the AFE macro, active high. */
        uint64_t refclk_b_oe_l         : 1;  /**< [ 38: 38](R/W/H) Output enables for the CML output buffers that drive reference
                                                                 clock "B" out of the bottom of the AFE macro, active high. */
        uint64_t refclk_a_oe_r         : 1;  /**< [ 37: 37](R/W/H) Output enables for the CML output buffers that drive reference
                                                                 clock "A" out of the top of the AFE macro, active high. */
        uint64_t refclk_b_oe_r         : 1;  /**< [ 36: 36](R/W/H) Output enables for the CML output buffers that drive reference
                                                                 clock "B" out of the top of the AFE macro, active high. */
        uint64_t refclk_pad_ena        : 1;  /**< [ 35: 35](R/W) Output enable for the cm0_refclk_pad_o output clock.  This signal
                                                                 should not change outside of the POR CMU power state:
                                                                   0x0 = The cm0_refclk_pad output will be held low.
                                                                   0x1 = The ref clk driven into the refclkp/m bumps will be driven
                                                                         out of the CMOS cm0_refclk_pad output to the DPL in all CMU
                                                                         power states including POR. */
        uint64_t refclk_hiz_ena        : 1;  /**< [ 34: 34](R/W) High impedance enable for the reclkp/m bumps:
                                                                   0x0 = The bumps are terminated with a differential 100 ohm resistance.
                                                                   0x1 = The bumps are unterminated. */
        uint64_t refclk_right_output_sel : 4;/**< [ 33: 30](R/W/H) CMU reference clock output select for the CML distribution buffers driving
                                                                 out of the top of the AFE macro at die edge:

                                                                   REFCLK_RIGHT_OUTPUT_SEL\<3:2\>:
                                                                     0x0 - Choose clk_ref_b_r_o source from refclk_pads.
                                                                     0x1 - Choose clk_ref_b_r_o source from clk_ref_b_r_i.
                                                                     0x2 - Choose clk_ref_b_r_o source from clk_ref_b_l_i.
                                                                     0x3 - Choose clk_ref_b_r_o source from refclk_pads.

                                                                   REFCLK_RIGHT_OUTPUT_SEL\<1:0\>:
                                                                     0x0 - Choose clk_ref_a_r_o source from refclk_pads.
                                                                     0x1 - Choose clk_ref_a_r_o source from clk_ref_a_r_i.
                                                                     0x2 - Choose clk_ref_a_r_o source from clk_ref_a_l_i.
                                                                     0x3 - Choose clk_ref_a_r_o source from refclk_pads. */
        uint64_t refclk_left_output_sel : 4; /**< [ 29: 26](R/W/H) CMU reference clock output select for the CML distribution buffers driving
                                                                 out of the bottom of the AFE macro at die edge:
                                                                   REFCLK_LEFT_OUTPUT_SEL\<3:2\>:
                                                                     0x0 = Choose clk_ref_b_l_o source from refclk_pads.
                                                                     0x1 = Choose clk_ref_b_l_o source from clk_ref_b_l_i.
                                                                     0x2 = Choose clk_ref_b_l_o source from clk_ref_b_r_i.
                                                                     0x3 = Choose clk_ref_b_l_o source from refclk_pads.

                                                                   REFCLK_LEFT_OUTPUT_SEL\<1:0\>:
                                                                     0x0 = Choose clk_ref_a_l_o source from refclk_pads.
                                                                     0x1 = Choose clk_ref_a_l_o source from clk_ref_a_l_i.
                                                                     0x2 = Choose clk_ref_a_l_o source from clk_ref_a_r_i.
                                                                     0x3 = Choose clk_ref_a_l_o source from refclk_pads. */
        uint64_t refclk_input_sel      : 3;  /**< [ 25: 23](R/W) CMU reference clock input select:
                                                                   0x0,0x3,0x4,0x7 = Ext ref clock from refclkp/m pads.
                                                                   0x1 = Ref clock from on-chip CML source, clk_ref_a_l_i.
                                                                   0x2 = Ref clock from on-chip CML source, clk_ref_a_r_i.
                                                                   0x5 = Ref clock from on-chip CML source, clk_ref_b_l_i.
                                                                   0x6 = Ref clock from on-chip CML source, clk_ref_b_r_i. */
        uint64_t cpu_reset             : 1;  /**< [ 22: 22](R/W) CPU reset. Active-high CPU reset. When asserted, CPU is halted and reset. When
                                                                 deasserted, CPU will execute its program. */
        uint64_t cm0_pd                : 2;  /**< [ 21: 20](R/W) CMU macro power down control:
                                                                   0x0 = Normal/active.
                                                                   0x1 = Partial power down.
                                                                   0x2 = Near complete power down (sleep state).
                                                                   0x3 = Reserved. */
        uint64_t reserved_19           : 1;
        uint64_t cm0_rst               : 1;  /**< [ 18: 18](R/W) CMU reset, active high. */
        uint64_t phy_ctrl_rate2        : 6;  /**< [ 17: 12](R/W) Phy configuration for rate 2.
                                                                   Ethernet Rates:
                                                                   0x23 = 10.3125 Gbps (Default).
                                                                   0x24 = 10.20 Gbps (At-speed scan mode).
                                                                   0x26 = 8.5 Gbps.
                                                                   0x28 = 6.25 Gbps.
                                                                   0x2A = 5 Gbps.
                                                                   _ Others = Reserved. */
        uint64_t phy_ctrl_rate1        : 6;  /**< [ 11:  6](R/W) Phy configuration for rate 1.
                                                                   Ethernet Rates:
                                                                   0x00 = 30 Gbps.
                                                                   0x01 = 28.05 Gbps.
                                                                   0x0B = 28 Gbps.
                                                                   0x02 = 27.34375 Gbps.
                                                                   0x03 = 25.78125 Gbps (Default).
                                                                   0x04 = 21.875 Gbps.
                                                                   0x05 = 20.625 Gbps.
                                                                   0x06 = 26.5625 Gbps.
                                                                   0x07 = 25 Gbps.
                                                                   0x08 = 28.125 Gbps.
                                                                   0x09 = 15 Gbps.
                                                                   0x21 = 12.5 Gbps.
                                                                   0x22 = 10.9375 Gbps.
                                                                   0x23 = 10.3125 Gbps.
                                                                   0x25 = 10 Gbps.
                                                                   _ Others = Reserved. */
        uint64_t phy_ctrl_refclk       : 5;  /**< [  5:  1](R/W) Phy configuration for the ref clock frequency:
                                                                   0x0A = 212.5 MHz.
                                                                   0x0E = 156.25 MHz Ethernet (Default).
                                                                   Ox13 = 200 MHz.
                                                                   _ Others = Reserved. */
        uint64_t por                   : 1;  /**< [  0:  0](R/W) Power on reset signal, active high. */
#else /* Word 0 - Little Endian */
        uint64_t por                   : 1;  /**< [  0:  0](R/W) Power on reset signal, active high. */
        uint64_t phy_ctrl_refclk       : 5;  /**< [  5:  1](R/W) Phy configuration for the ref clock frequency:
                                                                   0x0A = 212.5 MHz.
                                                                   0x0E = 156.25 MHz Ethernet (Default).
                                                                   Ox13 = 200 MHz.
                                                                   _ Others = Reserved. */
        uint64_t phy_ctrl_rate1        : 6;  /**< [ 11:  6](R/W) Phy configuration for rate 1.
                                                                   Ethernet Rates:
                                                                   0x00 = 30 Gbps.
                                                                   0x01 = 28.05 Gbps.
                                                                   0x0B = 28 Gbps.
                                                                   0x02 = 27.34375 Gbps.
                                                                   0x03 = 25.78125 Gbps (Default).
                                                                   0x04 = 21.875 Gbps.
                                                                   0x05 = 20.625 Gbps.
                                                                   0x06 = 26.5625 Gbps.
                                                                   0x07 = 25 Gbps.
                                                                   0x08 = 28.125 Gbps.
                                                                   0x09 = 15 Gbps.
                                                                   0x21 = 12.5 Gbps.
                                                                   0x22 = 10.9375 Gbps.
                                                                   0x23 = 10.3125 Gbps.
                                                                   0x25 = 10 Gbps.
                                                                   _ Others = Reserved. */
        uint64_t phy_ctrl_rate2        : 6;  /**< [ 17: 12](R/W) Phy configuration for rate 2.
                                                                   Ethernet Rates:
                                                                   0x23 = 10.3125 Gbps (Default).
                                                                   0x24 = 10.20 Gbps (At-speed scan mode).
                                                                   0x26 = 8.5 Gbps.
                                                                   0x28 = 6.25 Gbps.
                                                                   0x2A = 5 Gbps.
                                                                   _ Others = Reserved. */
        uint64_t cm0_rst               : 1;  /**< [ 18: 18](R/W) CMU reset, active high. */
        uint64_t reserved_19           : 1;
        uint64_t cm0_pd                : 2;  /**< [ 21: 20](R/W) CMU macro power down control:
                                                                   0x0 = Normal/active.
                                                                   0x1 = Partial power down.
                                                                   0x2 = Near complete power down (sleep state).
                                                                   0x3 = Reserved. */
        uint64_t cpu_reset             : 1;  /**< [ 22: 22](R/W) CPU reset. Active-high CPU reset. When asserted, CPU is halted and reset. When
                                                                 deasserted, CPU will execute its program. */
        uint64_t refclk_input_sel      : 3;  /**< [ 25: 23](R/W) CMU reference clock input select:
                                                                   0x0,0x3,0x4,0x7 = Ext ref clock from refclkp/m pads.
                                                                   0x1 = Ref clock from on-chip CML source, clk_ref_a_l_i.
                                                                   0x2 = Ref clock from on-chip CML source, clk_ref_a_r_i.
                                                                   0x5 = Ref clock from on-chip CML source, clk_ref_b_l_i.
                                                                   0x6 = Ref clock from on-chip CML source, clk_ref_b_r_i. */
        uint64_t refclk_left_output_sel : 4; /**< [ 29: 26](R/W/H) CMU reference clock output select for the CML distribution buffers driving
                                                                 out of the bottom of the AFE macro at die edge:
                                                                   REFCLK_LEFT_OUTPUT_SEL\<3:2\>:
                                                                     0x0 = Choose clk_ref_b_l_o source from refclk_pads.
                                                                     0x1 = Choose clk_ref_b_l_o source from clk_ref_b_l_i.
                                                                     0x2 = Choose clk_ref_b_l_o source from clk_ref_b_r_i.
                                                                     0x3 = Choose clk_ref_b_l_o source from refclk_pads.

                                                                   REFCLK_LEFT_OUTPUT_SEL\<1:0\>:
                                                                     0x0 = Choose clk_ref_a_l_o source from refclk_pads.
                                                                     0x1 = Choose clk_ref_a_l_o source from clk_ref_a_l_i.
                                                                     0x2 = Choose clk_ref_a_l_o source from clk_ref_a_r_i.
                                                                     0x3 = Choose clk_ref_a_l_o source from refclk_pads. */
        uint64_t refclk_right_output_sel : 4;/**< [ 33: 30](R/W/H) CMU reference clock output select for the CML distribution buffers driving
                                                                 out of the top of the AFE macro at die edge:

                                                                   REFCLK_RIGHT_OUTPUT_SEL\<3:2\>:
                                                                     0x0 - Choose clk_ref_b_r_o source from refclk_pads.
                                                                     0x1 - Choose clk_ref_b_r_o source from clk_ref_b_r_i.
                                                                     0x2 - Choose clk_ref_b_r_o source from clk_ref_b_l_i.
                                                                     0x3 - Choose clk_ref_b_r_o source from refclk_pads.

                                                                   REFCLK_RIGHT_OUTPUT_SEL\<1:0\>:
                                                                     0x0 - Choose clk_ref_a_r_o source from refclk_pads.
                                                                     0x1 - Choose clk_ref_a_r_o source from clk_ref_a_r_i.
                                                                     0x2 - Choose clk_ref_a_r_o source from clk_ref_a_l_i.
                                                                     0x3 - Choose clk_ref_a_r_o source from refclk_pads. */
        uint64_t refclk_hiz_ena        : 1;  /**< [ 34: 34](R/W) High impedance enable for the reclkp/m bumps:
                                                                   0x0 = The bumps are terminated with a differential 100 ohm resistance.
                                                                   0x1 = The bumps are unterminated. */
        uint64_t refclk_pad_ena        : 1;  /**< [ 35: 35](R/W) Output enable for the cm0_refclk_pad_o output clock.  This signal
                                                                 should not change outside of the POR CMU power state:
                                                                   0x0 = The cm0_refclk_pad output will be held low.
                                                                   0x1 = The ref clk driven into the refclkp/m bumps will be driven
                                                                         out of the CMOS cm0_refclk_pad output to the DPL in all CMU
                                                                         power states including POR. */
        uint64_t refclk_b_oe_r         : 1;  /**< [ 36: 36](R/W/H) Output enables for the CML output buffers that drive reference
                                                                 clock "B" out of the top of the AFE macro, active high. */
        uint64_t refclk_a_oe_r         : 1;  /**< [ 37: 37](R/W/H) Output enables for the CML output buffers that drive reference
                                                                 clock "A" out of the top of the AFE macro, active high. */
        uint64_t refclk_b_oe_l         : 1;  /**< [ 38: 38](R/W/H) Output enables for the CML output buffers that drive reference
                                                                 clock "B" out of the bottom of the AFE macro, active high. */
        uint64_t refclk_a_oe_l         : 1;  /**< [ 39: 39](R/W/H) Output enables for the CML output buffers that drive reference
                                                                 clock "A" out of the bottom of the AFE macro, active high. */
        uint64_t phy_rext_master       : 1;  /**< [ 40: 40](R/W/H) REXT master select:
                                                                   0x0 = PHY is a slave.
                                                                   0x1 = PHY is the master. */
        uint64_t reserved_41_42        : 2;
        uint64_t pmem_wr_prot          : 1;  /**< [ 43: 43](R/W) Write Protect for CPU Program Memory. If write protection is desired on PMEM,
                                                                 this bit should be set to 0x1 prior to asserting POR or CPU_RESET. This bit may be written
                                                                 to 0x0 or 0x1 by software as necessary.
                                                                   0x0 = Program Memory may be written (not write protected).
                                                                   0x1 = Program Memory cannot be written (write protected). */
        uint64_t dis_apb_csr_addr_filter : 1;/**< [ 44: 44](R/W) Reserved. */
        uint64_t apb_reset             : 1;  /**< [ 45: 45](R/W) Reset for CPU's APB bus. Must be set to zero prior to accessing APB bus via JTAG or RSL.
                                                                   0x0 = APB bus reset deasserted.
                                                                   0x1 = APB bus reset asserted. */
        uint64_t refclk_override       : 1;  /**< [ 46: 46](R/W) During a cold reset, the following fields are populated by HW.   When
                                                                 REFCLK_OVERRIDE=0, writes to these fields are ignored.
                                                                 When REFCLK_OVERRIDE=1, writes to these fields are applied. For diagnostic use only.

                                                                   REFCLK_A_OE_L.
                                                                   REFCLK_A_OE_R.
                                                                   REFCLK_B_OE_L.
                                                                   REFCLK_B_OE_R.
                                                                   REFCLK_RIGHT_OUTPUT_SEL.
                                                                   REFCLK_LEFT_OUTPUT_SEL.
                                                                   PHY_REXT_MASTER. */
        uint64_t reserved_47_63        : 17;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_common_phy_ctrl_bcfg_s cn9; */
    /* struct cavm_gsercx_common_phy_ctrl_bcfg_s f95o; */
    struct cavm_gsercx_common_phy_ctrl_bcfg_loki
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_47_63        : 17;
        uint64_t refclk_override       : 1;  /**< [ 46: 46](R/W) During a cold reset, the following fields are populated by HW.   When
                                                                 REFCLK_OVERRIDE=0, writes to these fields are ignored.
                                                                 When REFCLK_OVERRIDE=1, writes to these fields are applied. For diagnostic use only.

                                                                   REFCLK_A_OE_L.
                                                                   REFCLK_A_OE_R.
                                                                   REFCLK_B_OE_L.
                                                                   REFCLK_B_OE_R.
                                                                   REFCLK_RIGHT_OUTPUT_SEL.
                                                                   REFCLK_LEFT_OUTPUT_SEL.
                                                                   PHY_REXT_MASTER. */
        uint64_t apb_reset             : 1;  /**< [ 45: 45](R/W) Reset for CPU's APB bus. Must be set to zero prior to accessing APB bus via JTAG or RSL.
                                                                   0x0 = APB bus reset deasserted.
                                                                   0x1 = APB bus reset asserted. */
        uint64_t dis_apb_csr_addr_filter : 1;/**< [ 44: 44](R/W) Reserved. */
        uint64_t pmem_wr_prot          : 1;  /**< [ 43: 43](R/W) Write Protect for CPU Program Memory. If write protection is desired on PMEM,
                                                                 this bit should be set to 0x1 prior to asserting POR or CPU_RESET. This bit may be written
                                                                 to 0x0 or 0x1 by software as necessary.
                                                                   0x0 = Program Memory may be written (not write protected).
                                                                   0x1 = Program Memory cannot be written (write protected). */
        uint64_t reserved_41_42        : 2;
        uint64_t phy_rext_master       : 1;  /**< [ 40: 40](R/W/H) REXT master select:
                                                                   0x0 = PHY is a slave.
                                                                   0x1 = PHY is the master. */
        uint64_t refclk_a_oe_l         : 1;  /**< [ 39: 39](R/W/H) Output enables for the CML output buffers that drive reference
                                                                 clock "A" out of the bottom of the AFE macro, active high. */
        uint64_t refclk_b_oe_l         : 1;  /**< [ 38: 38](R/W/H) Output enables for the CML output buffers that drive reference
                                                                 clock "B" out of the bottom of the AFE macro, active high. */
        uint64_t refclk_a_oe_r         : 1;  /**< [ 37: 37](R/W/H) Output enables for the CML output buffers that drive reference
                                                                 clock "A" out of the top of the AFE macro, active high. */
        uint64_t refclk_b_oe_r         : 1;  /**< [ 36: 36](R/W/H) Output enables for the CML output buffers that drive reference
                                                                 clock "B" out of the top of the AFE macro, active high. */
        uint64_t refclk_pad_ena        : 1;  /**< [ 35: 35](R/W) Output enable for the cm0_refclk_pad_o output clock.  This signal
                                                                 should not change outside of the POR CMU power state:
                                                                   0x0 = The cm0_refclk_pad output will be held low.
                                                                   0x1 = The ref clk driven into the refclkp/m bumps will be driven
                                                                         out of the CMOS cm0_refclk_pad output to the DPL in all CMU
                                                                         power states including POR. */
        uint64_t refclk_hiz_ena        : 1;  /**< [ 34: 34](R/W) High impedance enable for the reclkp/m bumps:
                                                                   0x0 = The bumps are terminated with a differential 100 ohm resistance.
                                                                   0x1 = The bumps are unterminated. */
        uint64_t refclk_right_output_sel : 4;/**< [ 33: 30](R/W/H) CMU reference clock output select for the CML distribution buffers driving
                                                                 out of the top of the AFE macro at die edge:

                                                                   REFCLK_RIGHT_OUTPUT_SEL\<3:2\>:
                                                                     0x0 - Choose clk_ref_b_r_o source from refclk_pads.
                                                                     0x1 - Choose clk_ref_b_r_o source from clk_ref_b_r_i.
                                                                     0x2 - Choose clk_ref_b_r_o source from clk_ref_b_l_i.
                                                                     0x3 - Choose clk_ref_b_r_o source from refclk_pads.

                                                                   REFCLK_RIGHT_OUTPUT_SEL\<1:0\>:
                                                                     0x0 - Choose clk_ref_a_r_o source from refclk_pads.
                                                                     0x1 - Choose clk_ref_a_r_o source from clk_ref_a_r_i.
                                                                     0x2 - Choose clk_ref_a_r_o source from clk_ref_a_l_i.
                                                                     0x3 - Choose clk_ref_a_r_o source from refclk_pads. */
        uint64_t refclk_left_output_sel : 4; /**< [ 29: 26](R/W/H) CMU reference clock output select for the CML distribution buffers driving
                                                                 out of the bottom of the AFE macro at die edge:
                                                                   REFCLK_LEFT_OUTPUT_SEL\<3:2\>:
                                                                     0x0 = Choose clk_ref_b_l_o source from refclk_pads.
                                                                     0x1 = Choose clk_ref_b_l_o source from clk_ref_b_l_i.
                                                                     0x2 = Choose clk_ref_b_l_o source from clk_ref_b_r_i.
                                                                     0x3 = Choose clk_ref_b_l_o source from refclk_pads.

                                                                   REFCLK_LEFT_OUTPUT_SEL\<1:0\>:
                                                                     0x0 = Choose clk_ref_a_l_o source from refclk_pads.
                                                                     0x1 = Choose clk_ref_a_l_o source from clk_ref_a_l_i.
                                                                     0x2 = Choose clk_ref_a_l_o source from clk_ref_a_r_i.
                                                                     0x3 = Choose clk_ref_a_l_o source from refclk_pads. */
        uint64_t refclk_input_sel      : 3;  /**< [ 25: 23](R/W) CMU reference clock input select:
                                                                   0x0,0x3,0x4,0x7 = Ext ref clock from refclkp/m pads.
                                                                   0x1 = Ref clock from on-chip CML source, clk_ref_a_l_i.
                                                                   0x2 = Ref clock from on-chip CML source, clk_ref_a_r_i.
                                                                   0x5 = Ref clock from on-chip CML source, clk_ref_b_l_i.
                                                                   0x6 = Ref clock from on-chip CML source, clk_ref_b_r_i. */
        uint64_t cpu_reset             : 1;  /**< [ 22: 22](R/W) CPU reset. Active-high CPU reset. When asserted, CPU is halted and reset. When
                                                                 deasserted, CPU will execute its program. */
        uint64_t cm0_pd                : 2;  /**< [ 21: 20](R/W) CMU macro power down control:
                                                                   0x0 = Normal/active.
                                                                   0x1 = Partial power down.
                                                                   0x2 = Near complete power down (sleep state).
                                                                   0x3 = Reserved. */
        uint64_t reserved_19           : 1;
        uint64_t cm0_rst               : 1;  /**< [ 18: 18](R/W) CMU reset, active high. */
        uint64_t phy_ctrl_rate2        : 6;  /**< [ 17: 12](R/W) Phy configuration for rate 2.
                                                                   CPRI Rates:
                                                                   0x11 = 6.144 Gbps.
                                                                   0x12 = 9.8304 Gbps.
                                                                   Ethernet Rates:
                                                                   0x23 = 10.3125 Gbps (Default).
                                                                   0x24 = 10.20 Gbps (At-speed scan mode).
                                                                   0x26 = 8.5 Gbps.
                                                                   0x28 = 6.25 Gbps.
                                                                   0x2A = 5 Gbps.
                                                                   _ Others = Reserved. */
        uint64_t phy_ctrl_rate1        : 6;  /**< [ 11:  6](R/W) Phy configuration for rate 1.
                                                                   Ethernet Rates:
                                                                   0x00 = 30 Gbps.
                                                                   0x01 = 28.05 Gbps.
                                                                   0x0B = 28 Gbps.
                                                                   0x02 = 27.34375 Gbps.
                                                                   0x03 = 25.78125 Gbps (Default).
                                                                   0x04 = 21.875 Gbps.
                                                                   0x05 = 20.625 Gbps.
                                                                   0x06 = 26.5625 Gbps.
                                                                   0x07 = 25 Gbps.
                                                                   0x08 = 28.125 Gbps.
                                                                   0x09 = 15 Gbps.
                                                                   0x21 = 12.5 Gbps.
                                                                   0x22 = 10.9375 Gbps.
                                                                   0x23 = 10.3125 Gbps.
                                                                   0x25 = 10 Gbps.
                                                                   _ Others = Reserved.
                                                                   CPRI Configuration:
                                                                   0x0D = 14.7456 Gbps (Reserved). */
        uint64_t phy_ctrl_refclk       : 5;  /**< [  5:  1](R/W) Phy configuration for the ref clock frequency:
                                                                   0x0A = 212.5 MHz.
                                                                   0x0E = 156.25 MHz Ethernet (Default).
                                                                   0x15 = 245.76 MHz.
                                                                   0x14 = 122.88 MHz CPRI.
                                                                   Ox13 = 200 MHz.
                                                                   _ Others = Reserved. */
        uint64_t por                   : 1;  /**< [  0:  0](R/W) Power on reset signal, active high. */
#else /* Word 0 - Little Endian */
        uint64_t por                   : 1;  /**< [  0:  0](R/W) Power on reset signal, active high. */
        uint64_t phy_ctrl_refclk       : 5;  /**< [  5:  1](R/W) Phy configuration for the ref clock frequency:
                                                                   0x0A = 212.5 MHz.
                                                                   0x0E = 156.25 MHz Ethernet (Default).
                                                                   0x15 = 245.76 MHz.
                                                                   0x14 = 122.88 MHz CPRI.
                                                                   Ox13 = 200 MHz.
                                                                   _ Others = Reserved. */
        uint64_t phy_ctrl_rate1        : 6;  /**< [ 11:  6](R/W) Phy configuration for rate 1.
                                                                   Ethernet Rates:
                                                                   0x00 = 30 Gbps.
                                                                   0x01 = 28.05 Gbps.
                                                                   0x0B = 28 Gbps.
                                                                   0x02 = 27.34375 Gbps.
                                                                   0x03 = 25.78125 Gbps (Default).
                                                                   0x04 = 21.875 Gbps.
                                                                   0x05 = 20.625 Gbps.
                                                                   0x06 = 26.5625 Gbps.
                                                                   0x07 = 25 Gbps.
                                                                   0x08 = 28.125 Gbps.
                                                                   0x09 = 15 Gbps.
                                                                   0x21 = 12.5 Gbps.
                                                                   0x22 = 10.9375 Gbps.
                                                                   0x23 = 10.3125 Gbps.
                                                                   0x25 = 10 Gbps.
                                                                   _ Others = Reserved.
                                                                   CPRI Configuration:
                                                                   0x0D = 14.7456 Gbps (Reserved). */
        uint64_t phy_ctrl_rate2        : 6;  /**< [ 17: 12](R/W) Phy configuration for rate 2.
                                                                   CPRI Rates:
                                                                   0x11 = 6.144 Gbps.
                                                                   0x12 = 9.8304 Gbps.
                                                                   Ethernet Rates:
                                                                   0x23 = 10.3125 Gbps (Default).
                                                                   0x24 = 10.20 Gbps (At-speed scan mode).
                                                                   0x26 = 8.5 Gbps.
                                                                   0x28 = 6.25 Gbps.
                                                                   0x2A = 5 Gbps.
                                                                   _ Others = Reserved. */
        uint64_t cm0_rst               : 1;  /**< [ 18: 18](R/W) CMU reset, active high. */
        uint64_t reserved_19           : 1;
        uint64_t cm0_pd                : 2;  /**< [ 21: 20](R/W) CMU macro power down control:
                                                                   0x0 = Normal/active.
                                                                   0x1 = Partial power down.
                                                                   0x2 = Near complete power down (sleep state).
                                                                   0x3 = Reserved. */
        uint64_t cpu_reset             : 1;  /**< [ 22: 22](R/W) CPU reset. Active-high CPU reset. When asserted, CPU is halted and reset. When
                                                                 deasserted, CPU will execute its program. */
        uint64_t refclk_input_sel      : 3;  /**< [ 25: 23](R/W) CMU reference clock input select:
                                                                   0x0,0x3,0x4,0x7 = Ext ref clock from refclkp/m pads.
                                                                   0x1 = Ref clock from on-chip CML source, clk_ref_a_l_i.
                                                                   0x2 = Ref clock from on-chip CML source, clk_ref_a_r_i.
                                                                   0x5 = Ref clock from on-chip CML source, clk_ref_b_l_i.
                                                                   0x6 = Ref clock from on-chip CML source, clk_ref_b_r_i. */
        uint64_t refclk_left_output_sel : 4; /**< [ 29: 26](R/W/H) CMU reference clock output select for the CML distribution buffers driving
                                                                 out of the bottom of the AFE macro at die edge:
                                                                   REFCLK_LEFT_OUTPUT_SEL\<3:2\>:
                                                                     0x0 = Choose clk_ref_b_l_o source from refclk_pads.
                                                                     0x1 = Choose clk_ref_b_l_o source from clk_ref_b_l_i.
                                                                     0x2 = Choose clk_ref_b_l_o source from clk_ref_b_r_i.
                                                                     0x3 = Choose clk_ref_b_l_o source from refclk_pads.

                                                                   REFCLK_LEFT_OUTPUT_SEL\<1:0\>:
                                                                     0x0 = Choose clk_ref_a_l_o source from refclk_pads.
                                                                     0x1 = Choose clk_ref_a_l_o source from clk_ref_a_l_i.
                                                                     0x2 = Choose clk_ref_a_l_o source from clk_ref_a_r_i.
                                                                     0x3 = Choose clk_ref_a_l_o source from refclk_pads. */
        uint64_t refclk_right_output_sel : 4;/**< [ 33: 30](R/W/H) CMU reference clock output select for the CML distribution buffers driving
                                                                 out of the top of the AFE macro at die edge:

                                                                   REFCLK_RIGHT_OUTPUT_SEL\<3:2\>:
                                                                     0x0 - Choose clk_ref_b_r_o source from refclk_pads.
                                                                     0x1 - Choose clk_ref_b_r_o source from clk_ref_b_r_i.
                                                                     0x2 - Choose clk_ref_b_r_o source from clk_ref_b_l_i.
                                                                     0x3 - Choose clk_ref_b_r_o source from refclk_pads.

                                                                   REFCLK_RIGHT_OUTPUT_SEL\<1:0\>:
                                                                     0x0 - Choose clk_ref_a_r_o source from refclk_pads.
                                                                     0x1 - Choose clk_ref_a_r_o source from clk_ref_a_r_i.
                                                                     0x2 - Choose clk_ref_a_r_o source from clk_ref_a_l_i.
                                                                     0x3 - Choose clk_ref_a_r_o source from refclk_pads. */
        uint64_t refclk_hiz_ena        : 1;  /**< [ 34: 34](R/W) High impedance enable for the reclkp/m bumps:
                                                                   0x0 = The bumps are terminated with a differential 100 ohm resistance.
                                                                   0x1 = The bumps are unterminated. */
        uint64_t refclk_pad_ena        : 1;  /**< [ 35: 35](R/W) Output enable for the cm0_refclk_pad_o output clock.  This signal
                                                                 should not change outside of the POR CMU power state:
                                                                   0x0 = The cm0_refclk_pad output will be held low.
                                                                   0x1 = The ref clk driven into the refclkp/m bumps will be driven
                                                                         out of the CMOS cm0_refclk_pad output to the DPL in all CMU
                                                                         power states including POR. */
        uint64_t refclk_b_oe_r         : 1;  /**< [ 36: 36](R/W/H) Output enables for the CML output buffers that drive reference
                                                                 clock "B" out of the top of the AFE macro, active high. */
        uint64_t refclk_a_oe_r         : 1;  /**< [ 37: 37](R/W/H) Output enables for the CML output buffers that drive reference
                                                                 clock "A" out of the top of the AFE macro, active high. */
        uint64_t refclk_b_oe_l         : 1;  /**< [ 38: 38](R/W/H) Output enables for the CML output buffers that drive reference
                                                                 clock "B" out of the bottom of the AFE macro, active high. */
        uint64_t refclk_a_oe_l         : 1;  /**< [ 39: 39](R/W/H) Output enables for the CML output buffers that drive reference
                                                                 clock "A" out of the bottom of the AFE macro, active high. */
        uint64_t phy_rext_master       : 1;  /**< [ 40: 40](R/W/H) REXT master select:
                                                                   0x0 = PHY is a slave.
                                                                   0x1 = PHY is the master. */
        uint64_t reserved_41_42        : 2;
        uint64_t pmem_wr_prot          : 1;  /**< [ 43: 43](R/W) Write Protect for CPU Program Memory. If write protection is desired on PMEM,
                                                                 this bit should be set to 0x1 prior to asserting POR or CPU_RESET. This bit may be written
                                                                 to 0x0 or 0x1 by software as necessary.
                                                                   0x0 = Program Memory may be written (not write protected).
                                                                   0x1 = Program Memory cannot be written (write protected). */
        uint64_t dis_apb_csr_addr_filter : 1;/**< [ 44: 44](R/W) Reserved. */
        uint64_t apb_reset             : 1;  /**< [ 45: 45](R/W) Reset for CPU's APB bus. Must be set to zero prior to accessing APB bus via JTAG or RSL.
                                                                   0x0 = APB bus reset deasserted.
                                                                   0x1 = APB bus reset asserted. */
        uint64_t refclk_override       : 1;  /**< [ 46: 46](R/W) During a cold reset, the following fields are populated by HW.   When
                                                                 REFCLK_OVERRIDE=0, writes to these fields are ignored.
                                                                 When REFCLK_OVERRIDE=1, writes to these fields are applied. For diagnostic use only.

                                                                   REFCLK_A_OE_L.
                                                                   REFCLK_A_OE_R.
                                                                   REFCLK_B_OE_L.
                                                                   REFCLK_B_OE_R.
                                                                   REFCLK_RIGHT_OUTPUT_SEL.
                                                                   REFCLK_LEFT_OUTPUT_SEL.
                                                                   PHY_REXT_MASTER. */
        uint64_t reserved_47_63        : 17;
#endif /* Word 0 - End */
    } loki;
};
typedef union cavm_gsercx_common_phy_ctrl_bcfg cavm_gsercx_common_phy_ctrl_bcfg_t;

static inline uint64_t CAVM_GSERCX_COMMON_PHY_CTRL_BCFG(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_COMMON_PHY_CTRL_BCFG(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a80800a0ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80800a0ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_COMMON_PHY_CTRL_BCFG", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_COMMON_PHY_CTRL_BCFG(a) cavm_gsercx_common_phy_ctrl_bcfg_t
#define bustype_CAVM_GSERCX_COMMON_PHY_CTRL_BCFG(a) CSR_TYPE_RSL
#define basename_CAVM_GSERCX_COMMON_PHY_CTRL_BCFG(a) "GSERCX_COMMON_PHY_CTRL_BCFG"
#define device_bar_CAVM_GSERCX_COMMON_PHY_CTRL_BCFG(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_COMMON_PHY_CTRL_BCFG(a) (a)
#define arguments_CAVM_GSERCX_COMMON_PHY_CTRL_BCFG(a) (a),-1,-1,-1

/**
 * Register (RSL) gserc#_common_phy_ctrl_prot
 *
 * GSERC PHY Common Control Protection Register
 */
union cavm_gsercx_common_phy_ctrl_prot
{
    uint64_t u;
    struct cavm_gsercx_common_phy_ctrl_prot_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t pmem_wr_prot_stky     : 1;  /**< [  0:  0](R/W1S) Sticky Write Protect for CPU Program Memory. If write protection is desired on PMEM,
                                                                 this bit should be set to 0x1 prior to asserting POR or CPU_RESET. This bit cannot be
                                                                 cleared by writing, only cleared upon reset.
                                                                   0x0 = Program memory may be written (not write protected).
                                                                   0x1 = Program memory cannot be written (write protected). */
#else /* Word 0 - Little Endian */
        uint64_t pmem_wr_prot_stky     : 1;  /**< [  0:  0](R/W1S) Sticky Write Protect for CPU Program Memory. If write protection is desired on PMEM,
                                                                 this bit should be set to 0x1 prior to asserting POR or CPU_RESET. This bit cannot be
                                                                 cleared by writing, only cleared upon reset.
                                                                   0x0 = Program memory may be written (not write protected).
                                                                   0x1 = Program memory cannot be written (write protected). */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_common_phy_ctrl_prot_s cn; */
};
typedef union cavm_gsercx_common_phy_ctrl_prot cavm_gsercx_common_phy_ctrl_prot_t;

static inline uint64_t CAVM_GSERCX_COMMON_PHY_CTRL_PROT(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_COMMON_PHY_CTRL_PROT(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a80800b0ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80800b0ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_COMMON_PHY_CTRL_PROT", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_COMMON_PHY_CTRL_PROT(a) cavm_gsercx_common_phy_ctrl_prot_t
#define bustype_CAVM_GSERCX_COMMON_PHY_CTRL_PROT(a) CSR_TYPE_RSL
#define basename_CAVM_GSERCX_COMMON_PHY_CTRL_PROT(a) "GSERCX_COMMON_PHY_CTRL_PROT"
#define device_bar_CAVM_GSERCX_COMMON_PHY_CTRL_PROT(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_COMMON_PHY_CTRL_PROT(a) (a)
#define arguments_CAVM_GSERCX_COMMON_PHY_CTRL_PROT(a) (a),-1,-1,-1

/**
 * Register (RSL) gserc#_common_phy_ctrl_stall
 *
 * GSERC PHY Common Control Stall Register
 */
union cavm_gsercx_common_phy_ctrl_stall
{
    uint64_t u;
    struct cavm_gsercx_common_phy_ctrl_stall_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_2_63         : 62;
        uint64_t csr_force_stall       : 1;  /**< [  1:  1](R/W) CSR controlled stall for accesses to CPU program and data memory.
                                                                   0x0 = Does not assert stall to CPU program and data memory.
                                                                   0x1 = Asserts stall stall to CPU program and data memory. */
        uint64_t csr_mask_stall        : 1;  /**< [  0:  0](R/W) Hardware stall mask control for accesses to CPU program and data memory.
                                                                   0x0 = Hardware stall from RSL access is enabled.
                                                                   0x1 = Hardware stall from RSL access is disabled (masked). */
#else /* Word 0 - Little Endian */
        uint64_t csr_mask_stall        : 1;  /**< [  0:  0](R/W) Hardware stall mask control for accesses to CPU program and data memory.
                                                                   0x0 = Hardware stall from RSL access is enabled.
                                                                   0x1 = Hardware stall from RSL access is disabled (masked). */
        uint64_t csr_force_stall       : 1;  /**< [  1:  1](R/W) CSR controlled stall for accesses to CPU program and data memory.
                                                                   0x0 = Does not assert stall to CPU program and data memory.
                                                                   0x1 = Asserts stall stall to CPU program and data memory. */
        uint64_t reserved_2_63         : 62;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_common_phy_ctrl_stall_s cn; */
};
typedef union cavm_gsercx_common_phy_ctrl_stall cavm_gsercx_common_phy_ctrl_stall_t;

static inline uint64_t CAVM_GSERCX_COMMON_PHY_CTRL_STALL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_COMMON_PHY_CTRL_STALL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a80800c0ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80800c0ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_COMMON_PHY_CTRL_STALL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_COMMON_PHY_CTRL_STALL(a) cavm_gsercx_common_phy_ctrl_stall_t
#define bustype_CAVM_GSERCX_COMMON_PHY_CTRL_STALL(a) CSR_TYPE_RSL
#define basename_CAVM_GSERCX_COMMON_PHY_CTRL_STALL(a) "GSERCX_COMMON_PHY_CTRL_STALL"
#define device_bar_CAVM_GSERCX_COMMON_PHY_CTRL_STALL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_COMMON_PHY_CTRL_STALL(a) (a)
#define arguments_CAVM_GSERCX_COMMON_PHY_CTRL_STALL(a) (a),-1,-1,-1

/**
 * Register (RSL) gserc#_common_phy_status_bsts
 *
 * GSERC PHY Common Status Register
 */
union cavm_gsercx_common_phy_status_bsts
{
    uint64_t u;
    struct cavm_gsercx_common_phy_status_bsts_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t dtest                 : 12; /**< [ 15:  4](RO/H) DTEST test output value */
        uint64_t reserved_3            : 1;
        uint64_t cm0_ok                : 1;  /**< [  2:  2](RO/H) CMU OK signal, asserted after CMU macro successfully reaches the
                                                                 Active power state, the CMU PLL has locked to the ref clock, and
                                                                 all output clocks are the correct frequency.  Signal is only valid
                                                                 on initial assertion, not a PLL lock indicator. */
        uint64_t cm0_state_chng_rdy    : 1;  /**< [  1:  1](RO/H) CMU reset and power state ready status:
                                                                   0x0 = PHY is performing a power state transition, signals cm0_rst_n
                                                                         and cm0_pd should not be changed.
                                                                   0x1 = PHY has successfully completed the last power state transition
                                                                         request and is ready to respond to cm0_rst_n, cm0_iddq, and
                                                                         cm0_pd changes. */
        uint64_t phy_error             : 1;  /**< [  0:  0](RO/H) PHY error status:
                                                                   0x0 = No error.
                                                                   0x1 = PHY has an internal error. */
#else /* Word 0 - Little Endian */
        uint64_t phy_error             : 1;  /**< [  0:  0](RO/H) PHY error status:
                                                                   0x0 = No error.
                                                                   0x1 = PHY has an internal error. */
        uint64_t cm0_state_chng_rdy    : 1;  /**< [  1:  1](RO/H) CMU reset and power state ready status:
                                                                   0x0 = PHY is performing a power state transition, signals cm0_rst_n
                                                                         and cm0_pd should not be changed.
                                                                   0x1 = PHY has successfully completed the last power state transition
                                                                         request and is ready to respond to cm0_rst_n, cm0_iddq, and
                                                                         cm0_pd changes. */
        uint64_t cm0_ok                : 1;  /**< [  2:  2](RO/H) CMU OK signal, asserted after CMU macro successfully reaches the
                                                                 Active power state, the CMU PLL has locked to the ref clock, and
                                                                 all output clocks are the correct frequency.  Signal is only valid
                                                                 on initial assertion, not a PLL lock indicator. */
        uint64_t reserved_3            : 1;
        uint64_t dtest                 : 12; /**< [ 15:  4](RO/H) DTEST test output value */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_common_phy_status_bsts_s cn; */
};
typedef union cavm_gsercx_common_phy_status_bsts cavm_gsercx_common_phy_status_bsts_t;

static inline uint64_t CAVM_GSERCX_COMMON_PHY_STATUS_BSTS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_COMMON_PHY_STATUS_BSTS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8081020ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8081020ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_COMMON_PHY_STATUS_BSTS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_COMMON_PHY_STATUS_BSTS(a) cavm_gsercx_common_phy_status_bsts_t
#define bustype_CAVM_GSERCX_COMMON_PHY_STATUS_BSTS(a) CSR_TYPE_RSL
#define basename_CAVM_GSERCX_COMMON_PHY_STATUS_BSTS(a) "GSERCX_COMMON_PHY_STATUS_BSTS"
#define device_bar_CAVM_GSERCX_COMMON_PHY_STATUS_BSTS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_COMMON_PHY_STATUS_BSTS(a) (a)
#define arguments_CAVM_GSERCX_COMMON_PHY_STATUS_BSTS(a) (a),-1,-1,-1

/**
 * Register (RSL) gserc#_const
 *
 * GSERC CONST Register
 */
union cavm_gsercx_const
{
    uint64_t u;
    struct cavm_gsercx_const_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data                  : 61; /**< [ 63:  3](RO) Reserved. */
        uint64_t nr_lanes              : 3;  /**< [  2:  0](RO) Number of lanes in this module. */
#else /* Word 0 - Little Endian */
        uint64_t nr_lanes              : 3;  /**< [  2:  0](RO) Number of lanes in this module. */
        uint64_t data                  : 61; /**< [ 63:  3](RO) Reserved. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_const_s cn; */
};
typedef union cavm_gsercx_const cavm_gsercx_const_t;

static inline uint64_t CAVM_GSERCX_CONST(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_CONST(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8080090ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8080090ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_CONST", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_CONST(a) cavm_gsercx_const_t
#define bustype_CAVM_GSERCX_CONST(a) CSR_TYPE_RSL
#define basename_CAVM_GSERCX_CONST(a) "GSERCX_CONST"
#define device_bar_CAVM_GSERCX_CONST(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_CONST(a) (a)
#define arguments_CAVM_GSERCX_CONST(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_dmem#
 *
 * GSERC Data Memory (36kB) Registers
 */
union cavm_gsercx_dmemx
{
    uint32_t u;
    struct cavm_gsercx_dmemx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t data                  : 32; /**< [ 31:  0](R/W) Data memory for GSERC microcontroller. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 32; /**< [ 31:  0](R/W) Data memory for GSERC microcontroller. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_dmemx_s cn; */
};
typedef union cavm_gsercx_dmemx cavm_gsercx_dmemx_t;

static inline uint64_t CAVM_GSERCX_DMEMX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_DMEMX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=4607)))
        return 0x87e0a8090000ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x1fff);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=4607)))
        return 0x87e0a8090000ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x1fff);
    __cavm_csr_fatal("GSERCX_DMEMX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_DMEMX(a,b) cavm_gsercx_dmemx_t
#define bustype_CAVM_GSERCX_DMEMX(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_DMEMX(a,b) "GSERCX_DMEMX"
#define device_bar_CAVM_GSERCX_DMEMX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_DMEMX(a,b) (a)
#define arguments_CAVM_GSERCX_DMEMX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) gserc#_domain_rst_en
 *
 * Domain Reset Enable Register
 */
union cavm_gsercx_domain_rst_en
{
    uint64_t u;
    struct cavm_gsercx_domain_rst_en_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t en                    : 1;  /**< [  0:  0](R/W) Domain reset enable.
                                                                     0 = Prevent resetting lane logic with domain reset.
                                                                     1 = Enable resetting all lane logic, except CSRCOLD CSR subblock registers, with domain reset. */
#else /* Word 0 - Little Endian */
        uint64_t en                    : 1;  /**< [  0:  0](R/W) Domain reset enable.
                                                                     0 = Prevent resetting lane logic with domain reset.
                                                                     1 = Enable resetting all lane logic, except CSRCOLD CSR subblock registers, with domain reset. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_domain_rst_en_s cn; */
};
typedef union cavm_gsercx_domain_rst_en cavm_gsercx_domain_rst_en_t;

static inline uint64_t CAVM_GSERCX_DOMAIN_RST_EN(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_DOMAIN_RST_EN(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8080080ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8080080ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_DOMAIN_RST_EN", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_DOMAIN_RST_EN(a) cavm_gsercx_domain_rst_en_t
#define bustype_CAVM_GSERCX_DOMAIN_RST_EN(a) CSR_TYPE_RSL
#define basename_CAVM_GSERCX_DOMAIN_RST_EN(a) "GSERCX_DOMAIN_RST_EN"
#define device_bar_CAVM_GSERCX_DOMAIN_RST_EN(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_DOMAIN_RST_EN(a) (a)
#define arguments_CAVM_GSERCX_DOMAIN_RST_EN(a) (a),-1,-1,-1

/**
 * Register (RSL) gserc#_lane#_btsclk_cfg
 *
 * GSERC Lane BTS Synchronous Ethernet Clock Control Register
 * Register controls settings for providing a clock output from the lane which is
 * synchronous to the clock recovered from the received data stream.
 */
union cavm_gsercx_lanex_btsclk_cfg
{
    uint64_t u;
    struct cavm_gsercx_lanex_btsclk_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_25_63        : 39;
        uint64_t en                    : 1;  /**< [ 24: 24](R/W) Enable driving the clock output from the lane. This bit should be set low before
                                                                 changing [DRATIO]; it may be written to 1 in the same cycle that [DRATIO] is
                                                                 written. */
        uint64_t reserved_18_23        : 6;
        uint64_t dratio                : 2;  /**< [ 17: 16](R/W) Divider ratio for the clock output from the lane relative to the clock for the
                                                                 parallel receive data.
                                                                 0x0 = Divide by 1, i.e., no division.
                                                                 0x1 = Divide by 2.
                                                                 0x2 = Divide by 4.
                                                                 0x3 = Divide by 8. */
        uint64_t reserved_9_15         : 7;
        uint64_t mio_en                : 1;  /**< [  8:  8](R/W) Enable driving the clock output from the lane to MIO. This bit should be set low before
                                                                 changing [MIO_DRATIO]; it may be written to 1 in the same cycle that [DRATIO] is
                                                                 written. */
        uint64_t reserved_2_7          : 6;
        uint64_t mio_dratio            : 2;  /**< [  1:  0](R/W) Divider ratio for the clock output from the lane to MIO relative to the clock for the
                                                                 parallel receive data.
                                                                 0x0 = Divide by 1, i.e., no division.
                                                                 0x1 = Divide by 2.
                                                                 0x2 = Divide by 4.
                                                                 0x3 = Divide by 8. */
#else /* Word 0 - Little Endian */
        uint64_t mio_dratio            : 2;  /**< [  1:  0](R/W) Divider ratio for the clock output from the lane to MIO relative to the clock for the
                                                                 parallel receive data.
                                                                 0x0 = Divide by 1, i.e., no division.
                                                                 0x1 = Divide by 2.
                                                                 0x2 = Divide by 4.
                                                                 0x3 = Divide by 8. */
        uint64_t reserved_2_7          : 6;
        uint64_t mio_en                : 1;  /**< [  8:  8](R/W) Enable driving the clock output from the lane to MIO. This bit should be set low before
                                                                 changing [MIO_DRATIO]; it may be written to 1 in the same cycle that [DRATIO] is
                                                                 written. */
        uint64_t reserved_9_15         : 7;
        uint64_t dratio                : 2;  /**< [ 17: 16](R/W) Divider ratio for the clock output from the lane relative to the clock for the
                                                                 parallel receive data.
                                                                 0x0 = Divide by 1, i.e., no division.
                                                                 0x1 = Divide by 2.
                                                                 0x2 = Divide by 4.
                                                                 0x3 = Divide by 8. */
        uint64_t reserved_18_23        : 6;
        uint64_t en                    : 1;  /**< [ 24: 24](R/W) Enable driving the clock output from the lane. This bit should be set low before
                                                                 changing [DRATIO]; it may be written to 1 in the same cycle that [DRATIO] is
                                                                 written. */
        uint64_t reserved_25_63        : 39;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lanex_btsclk_cfg_s cn; */
};
typedef union cavm_gsercx_lanex_btsclk_cfg cavm_gsercx_lanex_btsclk_cfg_t;

static inline uint64_t CAVM_GSERCX_LANEX_BTSCLK_CFG(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LANEX_BTSCLK_CFG(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a80810b0ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80810b0ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LANEX_BTSCLK_CFG", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LANEX_BTSCLK_CFG(a,b) cavm_gsercx_lanex_btsclk_cfg_t
#define bustype_CAVM_GSERCX_LANEX_BTSCLK_CFG(a,b) CSR_TYPE_RSL
#define basename_CAVM_GSERCX_LANEX_BTSCLK_CFG(a,b) "GSERCX_LANEX_BTSCLK_CFG"
#define device_bar_CAVM_GSERCX_LANEX_BTSCLK_CFG(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LANEX_BTSCLK_CFG(a,b) (a)
#define arguments_CAVM_GSERCX_LANEX_BTSCLK_CFG(a,b) (a),(b),-1,-1

/**
 * Register (RSL) gserc#_lane#_control_bcfg
 *
 * GSERC PHY Lane Control Register
 */
union cavm_gsercx_lanex_control_bcfg
{
    uint64_t u;
    struct cavm_gsercx_lanex_control_bcfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t cpri_txclk_bist_ovrd  : 2;  /**< [ 47: 46](R/W) Reserved. */
        uint64_t rx_bitstrip_mode      : 1;  /**< [ 45: 45](R/W) Selects the bitstrip div mode.
                                                                   0x0 = Div 2 bitstripping.
                                                                   0x1 = Div 4 bitstripping. */
        uint64_t cfg_cpri              : 1;  /**< [ 44: 44](R/W) Reserved. */
        uint64_t rx_bitstrip_cfg       : 1;  /**< [ 43: 43](R/W) Reserved. */
        uint64_t rx_bitstrip_en        : 1;  /**< [ 42: 42](R/W) Reserved. */
        uint64_t rx_wpk_order          : 1;  /**< [ 41: 41](R/W) Receiver word packing order. Used when the GSERC()_LANE()_CONTROL_BCFG[LN_CTRL_RX_WIDTH]
                                                                 is set to 0x3 to configure the GSERC PHY to 20-bit receive path data width
                                                                 for the 10.3125Gbuad and lower Ethernet data rates.
                                                                 When [RX_WPK_ORDER] is set to 1 the first (earliest) 20-bit word received from the GSERC PHY
                                                                 is packed into the lower 20-bit word position of the 40-bit word and the second (later)
                                                                 20-bit word received is packed into the upper 20-bit word position of the 40-bit word.
                                                                 When [RX_WPK_ORDER] is cleared to 0 the 20-bit word packing order within the 40-bit word
                                                                 is swapped. Set [RX_WUP_ORDER] to 1 for normal Ethernet receive data to the CGX Ethernet MAC.
                                                                 For diagnostic use only. */
        uint64_t tx_wup_order          : 1;  /**< [ 40: 40](RAZ) Reserved. */
        uint64_t rx_wpk_20b40b         : 1;  /**< [ 39: 39](RAZ) Reserved. */
        uint64_t tx_wup_40b20b         : 1;  /**< [ 38: 38](RAZ) Reserved. */
        uint64_t reverse_rx_bit_order  : 1;  /**< [ 37: 37](R/W) When set to 1, reverses the bit order in the 40-bit receive word
                                                                 from the GSERC PHY to the CGX MAC. This control must be set to 1
                                                                 for normal Ethernet receive data.
                                                                 For diagnostic use only. */
        uint64_t reverse_tx_bit_order  : 1;  /**< [ 36: 36](R/W) When set to 1, reverses the bit order in the 40-bit transmit word
                                                                 from the CGX MAC to the GSERC PHY. This control must be set to 1
                                                                 for normal Ethernet transmit data.
                                                                 For diagnostic use only. */
        uint64_t cgx_quad              : 1;  /**< [ 35: 35](R/W) Reserved. */
        uint64_t cgx_dual              : 1;  /**< [ 34: 34](R/W) When set, indicates the DLM is in CGX dual aggregation mode. [CGX_DUAL] must only be
                                                                 set when GSERC()_LANE()_CONTROL_BCFG[CFG_CGX] is set.

                                                                 When [CGX_DUAL] is set, GSERC bundles transmitter lanes 0 and 1 for one CGX controller to
                                                                 minimize the transmitter lane-to-lane skew. [CGX_DUAL] must only be set for the RXAUI
                                                                 protocol. */
        uint64_t cfg_cgx               : 1;  /**< [ 33: 33](R/W) Enables SCLK to the CGX TX and RX data path to CGX in Ethernet mode. */
        uint64_t reserved_32           : 1;
        uint64_t ln_tx_clk_gate_en     : 1;  /**< [ 31: 31](R/W) When set to 0 disables the ln_tx_clk clock from the ln_tx_clk clock mux.
                                                                 Use to disable the ln_tx_clk for power savings.
                                                                 For normal operation set [LN_TX_CLK_GATE_EN] to 1. */
        uint64_t tx_clk_mux_sel        : 5;  /**< [ 30: 26](R/W) Selects the clock source for ln_tx_clk input:
                                                                   0x0 = 25G, 50G, and 100G data rates. Also for
                                                                         10G, 40G data rates if GSERC()_PHY_CTRL_BCFG[PHY_CTRL_RATE1] is
                                                                         configured for the 10.3125Gbps data rate.
                                                                   0x1 = 10G, 40G data rates if GSERC()_PHY_CTRL_BCFG[PHY_CTRL_RATE2] is
                                                                         configured for the 10.3125Gbps data rate.
                                                                         Also for RXAUI, DXAUI, and QSGMII data rates.
                                                                   0x4 = XAUI data rate.
                                                                   0x6 = SGMII data rate
                                                                   All other selections reserved. */
        uint64_t reserved_25           : 1;
        uint64_t ln_link_stat          : 5;  /**< [ 24: 20](R/W) Reserved. */
        uint64_t ln_an_cfg             : 2;  /**< [ 19: 18](R/W) Reserved. */
        uint64_t ln_rate_chng          : 1;  /**< [ 17: 17](R/W) Rate change handshake signal.  Phy transitions to rates set in LN_CTRL_RX_RATE and
                                                                 LN_CTRL_TX_RATE when asserted.  De-assertion indicates to the PHY that rate
                                                                 configuration adjustments have been completed. */
        uint64_t ln_ctrl_rxpolarity    : 1;  /**< [ 16: 16](R/W) RX data polarity inversion:
                                                                   0x0 = No polarity inversion.
                                                                   0x1 = Polarity inversion. */
        uint64_t ln_ctrl_rx_width      : 3;  /**< [ 15: 13](R/W) RX data word width selector:
                                                                   0x1 = 10 bit Reserved.
                                                                   0x2 = 16 bit Reserved.
                                                                   0x3 = 20 bit 40G,10G,DXAUI,RXAUI,XAUI,QSGMII,SGMII.
                                                                   0x4 = 32 bit Reserved.
                                                                   0x5 = 40 bit 25G,50G,100G data rates (Default).
                                                                   Others = Reserved. */
        uint64_t ln_ctrl_tx_width      : 3;  /**< [ 12: 10](R/W) TX data word width selector:
                                                                   0x1 = 10 bit Reserved.
                                                                   0x2 = 16 bit 40G,10G,DXAUI,RXAUI,XAUI,QSGMII,SGMII
                                                                   0x3 = 20 bit Reserved.
                                                                   0x4 = 32 bit 25G,50G,100G data rate (Default).
                                                                   0x5 = 40 bit Reserved.
                                                                   Others - Reserved. */
        uint64_t ln_ctrl_rx_rate       : 3;  /**< [  9:  7](R/W) RX data rate selector:
                                                                   0x0 = Rate 1 (PHY_CTRL_RATE1).
                                                                   0x1 = Rate 2 (PHY_CTRL_RATE2).
                                                                   0x2 = Rate 3 (Reserved for 1.25Gbps Ethernet).
                                                                   0x4 = Divide-by-2 of Rate 1.
                                                                   0x5 = Divide-by-2 of Rate 2.
                                                                   0x6 = Divide-by-2 of Rate 3.
                                                                   Others = Reserved. */
        uint64_t ln_ctrl_tx_rate       : 3;  /**< [  6:  4](R/W) TX data rate selector:
                                                                   0x0 = Rate 1 (PHY_CTRL_RATE1).
                                                                   0x1 = Rate 2 (PHY_CTRL_RATE2).
                                                                   0x2 = Rate 3 (Reserved for 1.25Gbps Ethernet).
                                                                   0x4 = Divide-by-2 of Rate 1.
                                                                   0x5 = Divide-by-2 of Rate 2.
                                                                   0x6 = Divide-by-2 of Rate 3.
                                                                   Others = Reserved. */
        uint64_t ln_ctrl_tx_en         : 1;  /**< [  3:  3](R/W) Transmit enable:
                                                                   0x0 = Data on LN_TXDATA will not be transmitted, transmitter placed into
                                                                         electrical idle.
                                                                   0x1 = Data on the active bits, set by LN_CTRL_RX/TX_WIDTH, of LN_TXDATA
                                                                         will be transmitted. */
        uint64_t ln_pd                 : 2;  /**< [  2:  1](R/W) Lane macro power down control:
                                                                   0x0 = Nomral/active.
                                                                   0x1 = Partial power down.
                                                                   0x2,0x3 = Most blocks powered down (Sleep mode). */
        uint64_t ln_rst                : 1;  /**< [  0:  0](R/W) Lane reset control, active high. */
#else /* Word 0 - Little Endian */
        uint64_t ln_rst                : 1;  /**< [  0:  0](R/W) Lane reset control, active high. */
        uint64_t ln_pd                 : 2;  /**< [  2:  1](R/W) Lane macro power down control:
                                                                   0x0 = Nomral/active.
                                                                   0x1 = Partial power down.
                                                                   0x2,0x3 = Most blocks powered down (Sleep mode). */
        uint64_t ln_ctrl_tx_en         : 1;  /**< [  3:  3](R/W) Transmit enable:
                                                                   0x0 = Data on LN_TXDATA will not be transmitted, transmitter placed into
                                                                         electrical idle.
                                                                   0x1 = Data on the active bits, set by LN_CTRL_RX/TX_WIDTH, of LN_TXDATA
                                                                         will be transmitted. */
        uint64_t ln_ctrl_tx_rate       : 3;  /**< [  6:  4](R/W) TX data rate selector:
                                                                   0x0 = Rate 1 (PHY_CTRL_RATE1).
                                                                   0x1 = Rate 2 (PHY_CTRL_RATE2).
                                                                   0x2 = Rate 3 (Reserved for 1.25Gbps Ethernet).
                                                                   0x4 = Divide-by-2 of Rate 1.
                                                                   0x5 = Divide-by-2 of Rate 2.
                                                                   0x6 = Divide-by-2 of Rate 3.
                                                                   Others = Reserved. */
        uint64_t ln_ctrl_rx_rate       : 3;  /**< [  9:  7](R/W) RX data rate selector:
                                                                   0x0 = Rate 1 (PHY_CTRL_RATE1).
                                                                   0x1 = Rate 2 (PHY_CTRL_RATE2).
                                                                   0x2 = Rate 3 (Reserved for 1.25Gbps Ethernet).
                                                                   0x4 = Divide-by-2 of Rate 1.
                                                                   0x5 = Divide-by-2 of Rate 2.
                                                                   0x6 = Divide-by-2 of Rate 3.
                                                                   Others = Reserved. */
        uint64_t ln_ctrl_tx_width      : 3;  /**< [ 12: 10](R/W) TX data word width selector:
                                                                   0x1 = 10 bit Reserved.
                                                                   0x2 = 16 bit 40G,10G,DXAUI,RXAUI,XAUI,QSGMII,SGMII
                                                                   0x3 = 20 bit Reserved.
                                                                   0x4 = 32 bit 25G,50G,100G data rate (Default).
                                                                   0x5 = 40 bit Reserved.
                                                                   Others - Reserved. */
        uint64_t ln_ctrl_rx_width      : 3;  /**< [ 15: 13](R/W) RX data word width selector:
                                                                   0x1 = 10 bit Reserved.
                                                                   0x2 = 16 bit Reserved.
                                                                   0x3 = 20 bit 40G,10G,DXAUI,RXAUI,XAUI,QSGMII,SGMII.
                                                                   0x4 = 32 bit Reserved.
                                                                   0x5 = 40 bit 25G,50G,100G data rates (Default).
                                                                   Others = Reserved. */
        uint64_t ln_ctrl_rxpolarity    : 1;  /**< [ 16: 16](R/W) RX data polarity inversion:
                                                                   0x0 = No polarity inversion.
                                                                   0x1 = Polarity inversion. */
        uint64_t ln_rate_chng          : 1;  /**< [ 17: 17](R/W) Rate change handshake signal.  Phy transitions to rates set in LN_CTRL_RX_RATE and
                                                                 LN_CTRL_TX_RATE when asserted.  De-assertion indicates to the PHY that rate
                                                                 configuration adjustments have been completed. */
        uint64_t ln_an_cfg             : 2;  /**< [ 19: 18](R/W) Reserved. */
        uint64_t ln_link_stat          : 5;  /**< [ 24: 20](R/W) Reserved. */
        uint64_t reserved_25           : 1;
        uint64_t tx_clk_mux_sel        : 5;  /**< [ 30: 26](R/W) Selects the clock source for ln_tx_clk input:
                                                                   0x0 = 25G, 50G, and 100G data rates. Also for
                                                                         10G, 40G data rates if GSERC()_PHY_CTRL_BCFG[PHY_CTRL_RATE1] is
                                                                         configured for the 10.3125Gbps data rate.
                                                                   0x1 = 10G, 40G data rates if GSERC()_PHY_CTRL_BCFG[PHY_CTRL_RATE2] is
                                                                         configured for the 10.3125Gbps data rate.
                                                                         Also for RXAUI, DXAUI, and QSGMII data rates.
                                                                   0x4 = XAUI data rate.
                                                                   0x6 = SGMII data rate
                                                                   All other selections reserved. */
        uint64_t ln_tx_clk_gate_en     : 1;  /**< [ 31: 31](R/W) When set to 0 disables the ln_tx_clk clock from the ln_tx_clk clock mux.
                                                                 Use to disable the ln_tx_clk for power savings.
                                                                 For normal operation set [LN_TX_CLK_GATE_EN] to 1. */
        uint64_t reserved_32           : 1;
        uint64_t cfg_cgx               : 1;  /**< [ 33: 33](R/W) Enables SCLK to the CGX TX and RX data path to CGX in Ethernet mode. */
        uint64_t cgx_dual              : 1;  /**< [ 34: 34](R/W) When set, indicates the DLM is in CGX dual aggregation mode. [CGX_DUAL] must only be
                                                                 set when GSERC()_LANE()_CONTROL_BCFG[CFG_CGX] is set.

                                                                 When [CGX_DUAL] is set, GSERC bundles transmitter lanes 0 and 1 for one CGX controller to
                                                                 minimize the transmitter lane-to-lane skew. [CGX_DUAL] must only be set for the RXAUI
                                                                 protocol. */
        uint64_t cgx_quad              : 1;  /**< [ 35: 35](R/W) Reserved. */
        uint64_t reverse_tx_bit_order  : 1;  /**< [ 36: 36](R/W) When set to 1, reverses the bit order in the 40-bit transmit word
                                                                 from the CGX MAC to the GSERC PHY. This control must be set to 1
                                                                 for normal Ethernet transmit data.
                                                                 For diagnostic use only. */
        uint64_t reverse_rx_bit_order  : 1;  /**< [ 37: 37](R/W) When set to 1, reverses the bit order in the 40-bit receive word
                                                                 from the GSERC PHY to the CGX MAC. This control must be set to 1
                                                                 for normal Ethernet receive data.
                                                                 For diagnostic use only. */
        uint64_t tx_wup_40b20b         : 1;  /**< [ 38: 38](RAZ) Reserved. */
        uint64_t rx_wpk_20b40b         : 1;  /**< [ 39: 39](RAZ) Reserved. */
        uint64_t tx_wup_order          : 1;  /**< [ 40: 40](RAZ) Reserved. */
        uint64_t rx_wpk_order          : 1;  /**< [ 41: 41](R/W) Receiver word packing order. Used when the GSERC()_LANE()_CONTROL_BCFG[LN_CTRL_RX_WIDTH]
                                                                 is set to 0x3 to configure the GSERC PHY to 20-bit receive path data width
                                                                 for the 10.3125Gbuad and lower Ethernet data rates.
                                                                 When [RX_WPK_ORDER] is set to 1 the first (earliest) 20-bit word received from the GSERC PHY
                                                                 is packed into the lower 20-bit word position of the 40-bit word and the second (later)
                                                                 20-bit word received is packed into the upper 20-bit word position of the 40-bit word.
                                                                 When [RX_WPK_ORDER] is cleared to 0 the 20-bit word packing order within the 40-bit word
                                                                 is swapped. Set [RX_WUP_ORDER] to 1 for normal Ethernet receive data to the CGX Ethernet MAC.
                                                                 For diagnostic use only. */
        uint64_t rx_bitstrip_en        : 1;  /**< [ 42: 42](R/W) Reserved. */
        uint64_t rx_bitstrip_cfg       : 1;  /**< [ 43: 43](R/W) Reserved. */
        uint64_t cfg_cpri              : 1;  /**< [ 44: 44](R/W) Reserved. */
        uint64_t rx_bitstrip_mode      : 1;  /**< [ 45: 45](R/W) Selects the bitstrip div mode.
                                                                   0x0 = Div 2 bitstripping.
                                                                   0x1 = Div 4 bitstripping. */
        uint64_t cpri_txclk_bist_ovrd  : 2;  /**< [ 47: 46](R/W) Reserved. */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lanex_control_bcfg_s cn9; */
    /* struct cavm_gsercx_lanex_control_bcfg_s f95o; */
    struct cavm_gsercx_lanex_control_bcfg_loki
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t cpri_txclk_bist_ovrd  : 2;  /**< [ 47: 46](R/W) Overrides the CPRI TXCLK MUX:
                                                                   0x0 = Standard operation.
                                                                   0x1 = Select div2 txclk.
                                                                   0x2 = Reserved.
                                                                   0x3 = Select div4 txclk. */
        uint64_t rx_bitstrip_mode      : 1;  /**< [ 45: 45](R/W) Selects the bitstrip div mode.
                                                                   0x0 = Div 2 bitstripping.
                                                                   0x1 = Div 4 bitstripping. */
        uint64_t cfg_cpri              : 1;  /**< [ 44: 44](R/W) Select for the lane tx clock and data muxes:
                                                                   0x0 = Ethernet ln_txclk and ln_txdata.
                                                                   0x1 = CPRI ln_txclk and ln_txdata. */
        uint64_t rx_bitstrip_cfg       : 1;  /**< [ 43: 43](R/W) Configures the sampling position for the div 4 bit stripping logic at the 2.4576Gbps CPRI rate:
                                                                   0x0 = 135 degree sample.
                                                                   0x1 = 225 degree sample. */
        uint64_t rx_bitstrip_en        : 1;  /**< [ 42: 42](R/W) Enables the bit stripping logic used in the 2.4576Gbps CPRI rate.  Clear to a 0
                                                                 to reset the bit strip
                                                                 pattern lock FSM. */
        uint64_t rx_wpk_order          : 1;  /**< [ 41: 41](R/W) Receiver word packing order. Used when the GSERC()_LANE()_CONTROL_BCFG[LN_CTRL_RX_WIDTH]
                                                                 is set to 0x3 to configure the GSERC PHY to 20-bit receive path data width
                                                                 for the 10.3125Gbuad and lower Ethernet data rates.
                                                                 When [RX_WPK_ORDER] is set to 1 the first (earliest) 20-bit word received from the GSERC PHY
                                                                 is packed into the lower 20-bit word position of the 40-bit word and the second (later)
                                                                 20-bit word received is packed into the upper 20-bit word position of the 40-bit word.
                                                                 When [RX_WPK_ORDER] is cleared to 0 the 20-bit word packing order within the 40-bit word
                                                                 is swapped. Set [RX_WUP_ORDER] to 1 for normal Ethernet receive data to the CGX Ethernet MAC.
                                                                 For diagnostic use only. */
        uint64_t tx_wup_order          : 1;  /**< [ 40: 40](RAZ) Reserved. */
        uint64_t rx_wpk_20b40b         : 1;  /**< [ 39: 39](RAZ) Reserved. */
        uint64_t tx_wup_40b20b         : 1;  /**< [ 38: 38](RAZ) Reserved. */
        uint64_t reverse_rx_bit_order  : 1;  /**< [ 37: 37](R/W) When set to 1, reverses the bit order in the 40-bit receive word
                                                                 from the GSERC PHY to the CGX MAC. This control must be set to 1
                                                                 for normal Ethernet receive data.
                                                                 For diagnostic use only. */
        uint64_t reverse_tx_bit_order  : 1;  /**< [ 36: 36](R/W) When set to 1, reverses the bit order in the 40-bit transmit word
                                                                 from the CGX MAC to the GSERC PHY. This control must be set to 1
                                                                 for normal Ethernet transmit data.
                                                                 For diagnostic use only. */
        uint64_t cgx_quad              : 1;  /**< [ 35: 35](R/W) Reserved. */
        uint64_t cgx_dual              : 1;  /**< [ 34: 34](R/W) When set, indicates the DLM is in CGX dual aggregation mode. [CGX_DUAL] must only be
                                                                 set when GSERC()_LANE()_CONTROL_BCFG[CFG_CGX] is set.

                                                                 When [CGX_DUAL] is set, GSERC bundles transmitter lanes 0 and 1 for one CGX controller to
                                                                 minimize the transmitter lane-to-lane skew. [CGX_DUAL] must only be set for the RXAUI
                                                                 protocol. */
        uint64_t cfg_cgx               : 1;  /**< [ 33: 33](R/W) Enables SCLK to the CGX TX and RX data path to CGX in Ethernet mode.
                                                                 For CPRI set CFG_CGX = 0. */
        uint64_t reserved_32           : 1;
        uint64_t ln_tx_clk_gate_en     : 1;  /**< [ 31: 31](R/W) When set to 0 disables the ln_tx_clk clock from the ln_tx_clk clock mux.
                                                                 Use to disable the ln_tx_clk for power savings.
                                                                 For normal operation set [LN_TX_CLK_GATE_EN] to 1. */
        uint64_t tx_clk_mux_sel        : 5;  /**< [ 30: 26](R/W) Selects the clock source for ln_tx_clk input:
                                                                   0x0 = 25G, 50G, and 100G data rates. Also for
                                                                         10G, 40G data rates if GSERC()_PHY_CTRL_BCFG[PHY_CTRL_RATE1] is
                                                                         configured for the 10.3125Gbps data rate.
                                                                   0x1 = 10G, 40G data rates if GSERC()_PHY_CTRL_BCFG[PHY_CTRL_RATE2] is
                                                                         configured for the 10.3125Gbps data rate.
                                                                         Also for RXAUI, DXAUI, and QSGMII data rates.
                                                                   0x4 = XAUI data rate.
                                                                   0x6 = SGMII data rate
                                                                   All other selections reserved. */
        uint64_t reserved_25           : 1;
        uint64_t ln_link_stat          : 5;  /**< [ 24: 20](R/W) Reserved. */
        uint64_t ln_an_cfg             : 2;  /**< [ 19: 18](R/W) Reserved. */
        uint64_t ln_rate_chng          : 1;  /**< [ 17: 17](R/W) Rate change handshake signal.  Phy transitions to rates set in LN_CTRL_RX_RATE and
                                                                 LN_CTRL_TX_RATE when asserted.  De-assertion indicates to the PHY that rate
                                                                 configuration adjustments have been completed. */
        uint64_t ln_ctrl_rxpolarity    : 1;  /**< [ 16: 16](R/W) RX data polarity inversion:
                                                                   0x0 = No polarity inversion.
                                                                   0x1 = Polarity inversion. */
        uint64_t ln_ctrl_rx_width      : 3;  /**< [ 15: 13](R/W) RX data word width selector:
                                                                   0x1 = 10 bit Reserved.
                                                                   0x2 = 16 bit Reserved.
                                                                   0x3 = 20 bit 40G,10G,DXAUI,RXAUI,XAUI,QSGMII,SGMII.
                                                                   0x4 = 32 bit Reserved.
                                                                   0x5 = 40 bit 25G,50G,100G data rates (Default).
                                                                   Others = Reserved.
                                                                   For CPRI select 0x3 = 20 bit. */
        uint64_t ln_ctrl_tx_width      : 3;  /**< [ 12: 10](R/W) TX data word width selector:
                                                                   0x1 = 10 bit Reserved.
                                                                   0x2 = 16 bit 40G,10G,DXAUI,RXAUI,XAUI,QSGMII,SGMII
                                                                   0x3 = 20 bit Reserved.
                                                                   0x4 = 32 bit 25G,50G,100G data rate (Default).
                                                                   0x5 = 40 bit Reserved.
                                                                   Others - Reserved.
                                                                   For CPRI select 0x3 = 20 bit. */
        uint64_t ln_ctrl_rx_rate       : 3;  /**< [  9:  7](R/W) RX data rate selector:
                                                                   0x0 = Rate 1 (PHY_CTRL_RATE1).
                                                                   0x1 = Rate 2 (PHY_CTRL_RATE2).
                                                                   0x2 = Rate 3 (Reserved for 1.25Gbps Ethernet).
                                                                   0x4 = Divide-by-2 of Rate 1.
                                                                   0x5 = Divide-by-2 of Rate 2.
                                                                   0x6 = Divide-by-2 of Rate 3.
                                                                   Others = Reserved.
                                                                   For CPRI select:
                                                                   0x1 = Rate 2 for the 9.8304 Gbps, 6.144Gbps, and 2.4576Gbps rates.
                                                                   0x5 = Divided-by-2 of Rate 2 for the 4.9152 Gbps, and 3.072 Gbps rates. */
        uint64_t ln_ctrl_tx_rate       : 3;  /**< [  6:  4](R/W) TX data rate selector:
                                                                   0x0 = Rate 1 (PHY_CTRL_RATE1).
                                                                   0x1 = Rate 2 (PHY_CTRL_RATE2).
                                                                   0x2 = Rate 3 (Reserved for 1.25Gbps Ethernet).
                                                                   0x4 = Divide-by-2 of Rate 1.
                                                                   0x5 = Divide-by-2 of Rate 2.
                                                                   0x6 = Divide-by-2 of Rate 3.
                                                                   Others = Reserved.
                                                                   For CPRI select:
                                                                   0x1 = Rate 2 for all CPRI rates. */
        uint64_t ln_ctrl_tx_en         : 1;  /**< [  3:  3](R/W) Transmit enable:
                                                                   0x0 = Data on LN_TXDATA will not be transmitted, transmitter placed into
                                                                         electrical idle.
                                                                   0x1 = Data on the active bits, set by LN_CTRL_RX/TX_WIDTH, of LN_TXDATA
                                                                         will be transmitted. */
        uint64_t ln_pd                 : 2;  /**< [  2:  1](R/W) Lane macro power down control:
                                                                   0x0 = Nomral/active.
                                                                   0x1 = Partial power down.
                                                                   0x2,0x3 = Most blocks powered down (Sleep mode). */
        uint64_t ln_rst                : 1;  /**< [  0:  0](R/W) Lane reset control, active high. */
#else /* Word 0 - Little Endian */
        uint64_t ln_rst                : 1;  /**< [  0:  0](R/W) Lane reset control, active high. */
        uint64_t ln_pd                 : 2;  /**< [  2:  1](R/W) Lane macro power down control:
                                                                   0x0 = Nomral/active.
                                                                   0x1 = Partial power down.
                                                                   0x2,0x3 = Most blocks powered down (Sleep mode). */
        uint64_t ln_ctrl_tx_en         : 1;  /**< [  3:  3](R/W) Transmit enable:
                                                                   0x0 = Data on LN_TXDATA will not be transmitted, transmitter placed into
                                                                         electrical idle.
                                                                   0x1 = Data on the active bits, set by LN_CTRL_RX/TX_WIDTH, of LN_TXDATA
                                                                         will be transmitted. */
        uint64_t ln_ctrl_tx_rate       : 3;  /**< [  6:  4](R/W) TX data rate selector:
                                                                   0x0 = Rate 1 (PHY_CTRL_RATE1).
                                                                   0x1 = Rate 2 (PHY_CTRL_RATE2).
                                                                   0x2 = Rate 3 (Reserved for 1.25Gbps Ethernet).
                                                                   0x4 = Divide-by-2 of Rate 1.
                                                                   0x5 = Divide-by-2 of Rate 2.
                                                                   0x6 = Divide-by-2 of Rate 3.
                                                                   Others = Reserved.
                                                                   For CPRI select:
                                                                   0x1 = Rate 2 for all CPRI rates. */
        uint64_t ln_ctrl_rx_rate       : 3;  /**< [  9:  7](R/W) RX data rate selector:
                                                                   0x0 = Rate 1 (PHY_CTRL_RATE1).
                                                                   0x1 = Rate 2 (PHY_CTRL_RATE2).
                                                                   0x2 = Rate 3 (Reserved for 1.25Gbps Ethernet).
                                                                   0x4 = Divide-by-2 of Rate 1.
                                                                   0x5 = Divide-by-2 of Rate 2.
                                                                   0x6 = Divide-by-2 of Rate 3.
                                                                   Others = Reserved.
                                                                   For CPRI select:
                                                                   0x1 = Rate 2 for the 9.8304 Gbps, 6.144Gbps, and 2.4576Gbps rates.
                                                                   0x5 = Divided-by-2 of Rate 2 for the 4.9152 Gbps, and 3.072 Gbps rates. */
        uint64_t ln_ctrl_tx_width      : 3;  /**< [ 12: 10](R/W) TX data word width selector:
                                                                   0x1 = 10 bit Reserved.
                                                                   0x2 = 16 bit 40G,10G,DXAUI,RXAUI,XAUI,QSGMII,SGMII
                                                                   0x3 = 20 bit Reserved.
                                                                   0x4 = 32 bit 25G,50G,100G data rate (Default).
                                                                   0x5 = 40 bit Reserved.
                                                                   Others - Reserved.
                                                                   For CPRI select 0x3 = 20 bit. */
        uint64_t ln_ctrl_rx_width      : 3;  /**< [ 15: 13](R/W) RX data word width selector:
                                                                   0x1 = 10 bit Reserved.
                                                                   0x2 = 16 bit Reserved.
                                                                   0x3 = 20 bit 40G,10G,DXAUI,RXAUI,XAUI,QSGMII,SGMII.
                                                                   0x4 = 32 bit Reserved.
                                                                   0x5 = 40 bit 25G,50G,100G data rates (Default).
                                                                   Others = Reserved.
                                                                   For CPRI select 0x3 = 20 bit. */
        uint64_t ln_ctrl_rxpolarity    : 1;  /**< [ 16: 16](R/W) RX data polarity inversion:
                                                                   0x0 = No polarity inversion.
                                                                   0x1 = Polarity inversion. */
        uint64_t ln_rate_chng          : 1;  /**< [ 17: 17](R/W) Rate change handshake signal.  Phy transitions to rates set in LN_CTRL_RX_RATE and
                                                                 LN_CTRL_TX_RATE when asserted.  De-assertion indicates to the PHY that rate
                                                                 configuration adjustments have been completed. */
        uint64_t ln_an_cfg             : 2;  /**< [ 19: 18](R/W) Reserved. */
        uint64_t ln_link_stat          : 5;  /**< [ 24: 20](R/W) Reserved. */
        uint64_t reserved_25           : 1;
        uint64_t tx_clk_mux_sel        : 5;  /**< [ 30: 26](R/W) Selects the clock source for ln_tx_clk input:
                                                                   0x0 = 25G, 50G, and 100G data rates. Also for
                                                                         10G, 40G data rates if GSERC()_PHY_CTRL_BCFG[PHY_CTRL_RATE1] is
                                                                         configured for the 10.3125Gbps data rate.
                                                                   0x1 = 10G, 40G data rates if GSERC()_PHY_CTRL_BCFG[PHY_CTRL_RATE2] is
                                                                         configured for the 10.3125Gbps data rate.
                                                                         Also for RXAUI, DXAUI, and QSGMII data rates.
                                                                   0x4 = XAUI data rate.
                                                                   0x6 = SGMII data rate
                                                                   All other selections reserved. */
        uint64_t ln_tx_clk_gate_en     : 1;  /**< [ 31: 31](R/W) When set to 0 disables the ln_tx_clk clock from the ln_tx_clk clock mux.
                                                                 Use to disable the ln_tx_clk for power savings.
                                                                 For normal operation set [LN_TX_CLK_GATE_EN] to 1. */
        uint64_t reserved_32           : 1;
        uint64_t cfg_cgx               : 1;  /**< [ 33: 33](R/W) Enables SCLK to the CGX TX and RX data path to CGX in Ethernet mode.
                                                                 For CPRI set CFG_CGX = 0. */
        uint64_t cgx_dual              : 1;  /**< [ 34: 34](R/W) When set, indicates the DLM is in CGX dual aggregation mode. [CGX_DUAL] must only be
                                                                 set when GSERC()_LANE()_CONTROL_BCFG[CFG_CGX] is set.

                                                                 When [CGX_DUAL] is set, GSERC bundles transmitter lanes 0 and 1 for one CGX controller to
                                                                 minimize the transmitter lane-to-lane skew. [CGX_DUAL] must only be set for the RXAUI
                                                                 protocol. */
        uint64_t cgx_quad              : 1;  /**< [ 35: 35](R/W) Reserved. */
        uint64_t reverse_tx_bit_order  : 1;  /**< [ 36: 36](R/W) When set to 1, reverses the bit order in the 40-bit transmit word
                                                                 from the CGX MAC to the GSERC PHY. This control must be set to 1
                                                                 for normal Ethernet transmit data.
                                                                 For diagnostic use only. */
        uint64_t reverse_rx_bit_order  : 1;  /**< [ 37: 37](R/W) When set to 1, reverses the bit order in the 40-bit receive word
                                                                 from the GSERC PHY to the CGX MAC. This control must be set to 1
                                                                 for normal Ethernet receive data.
                                                                 For diagnostic use only. */
        uint64_t tx_wup_40b20b         : 1;  /**< [ 38: 38](RAZ) Reserved. */
        uint64_t rx_wpk_20b40b         : 1;  /**< [ 39: 39](RAZ) Reserved. */
        uint64_t tx_wup_order          : 1;  /**< [ 40: 40](RAZ) Reserved. */
        uint64_t rx_wpk_order          : 1;  /**< [ 41: 41](R/W) Receiver word packing order. Used when the GSERC()_LANE()_CONTROL_BCFG[LN_CTRL_RX_WIDTH]
                                                                 is set to 0x3 to configure the GSERC PHY to 20-bit receive path data width
                                                                 for the 10.3125Gbuad and lower Ethernet data rates.
                                                                 When [RX_WPK_ORDER] is set to 1 the first (earliest) 20-bit word received from the GSERC PHY
                                                                 is packed into the lower 20-bit word position of the 40-bit word and the second (later)
                                                                 20-bit word received is packed into the upper 20-bit word position of the 40-bit word.
                                                                 When [RX_WPK_ORDER] is cleared to 0 the 20-bit word packing order within the 40-bit word
                                                                 is swapped. Set [RX_WUP_ORDER] to 1 for normal Ethernet receive data to the CGX Ethernet MAC.
                                                                 For diagnostic use only. */
        uint64_t rx_bitstrip_en        : 1;  /**< [ 42: 42](R/W) Enables the bit stripping logic used in the 2.4576Gbps CPRI rate.  Clear to a 0
                                                                 to reset the bit strip
                                                                 pattern lock FSM. */
        uint64_t rx_bitstrip_cfg       : 1;  /**< [ 43: 43](R/W) Configures the sampling position for the div 4 bit stripping logic at the 2.4576Gbps CPRI rate:
                                                                   0x0 = 135 degree sample.
                                                                   0x1 = 225 degree sample. */
        uint64_t cfg_cpri              : 1;  /**< [ 44: 44](R/W) Select for the lane tx clock and data muxes:
                                                                   0x0 = Ethernet ln_txclk and ln_txdata.
                                                                   0x1 = CPRI ln_txclk and ln_txdata. */
        uint64_t rx_bitstrip_mode      : 1;  /**< [ 45: 45](R/W) Selects the bitstrip div mode.
                                                                   0x0 = Div 2 bitstripping.
                                                                   0x1 = Div 4 bitstripping. */
        uint64_t cpri_txclk_bist_ovrd  : 2;  /**< [ 47: 46](R/W) Overrides the CPRI TXCLK MUX:
                                                                   0x0 = Standard operation.
                                                                   0x1 = Select div2 txclk.
                                                                   0x2 = Reserved.
                                                                   0x3 = Select div4 txclk. */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } loki;
};
typedef union cavm_gsercx_lanex_control_bcfg cavm_gsercx_lanex_control_bcfg_t;

static inline uint64_t CAVM_GSERCX_LANEX_CONTROL_BCFG(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LANEX_CONTROL_BCFG(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8081030ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8081030ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LANEX_CONTROL_BCFG", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LANEX_CONTROL_BCFG(a,b) cavm_gsercx_lanex_control_bcfg_t
#define bustype_CAVM_GSERCX_LANEX_CONTROL_BCFG(a,b) CSR_TYPE_RSL
#define basename_CAVM_GSERCX_LANEX_CONTROL_BCFG(a,b) "GSERCX_LANEX_CONTROL_BCFG"
#define device_bar_CAVM_GSERCX_LANEX_CONTROL_BCFG(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LANEX_CONTROL_BCFG(a,b) (a)
#define arguments_CAVM_GSERCX_LANEX_CONTROL_BCFG(a,b) (a),(b),-1,-1

/**
 * Register (RSL) gserc#_lane#_status_bsts
 *
 * GSERC PHY Lane Status Register
 */
union cavm_gsercx_lanex_status_bsts
{
    uint64_t u;
    struct cavm_gsercx_lanex_status_bsts_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_22_63        : 42;
        uint64_t ln_rx_bitstrip_err    : 1;  /**< [ 21: 21](RO/H) Sticky bit that signals when the rx div4 fail counter has saturated when
                                                                 trying to lock to the bit stuffed rxdata. */
        uint64_t ln_rx_fifo_full       : 1;  /**< [ 20: 20](RO/H) Reserved. */
        uint64_t ln_tx_fifo_empty      : 1;  /**< [ 19: 19](RO/H) Reserved. */
        uint64_t ln_an_stat_resolved   : 1;  /**< [ 18: 18](RO/H) Reserved. */
        uint64_t ln_an_scan_for_carrier : 1; /**< [ 17: 17](RO/H) Reserved. */
        uint64_t ln_an_link_sel        : 5;  /**< [ 16: 12](RO/H) Reserved. */
        uint64_t ln_an_rs_fec_en       : 1;  /**< [ 11: 11](RO/H) Reserved. */
        uint64_t ln_an_base_fec_en     : 1;  /**< [ 10: 10](RO/H) Reserved. */
        uint64_t ln_an_rx_pause_en     : 1;  /**< [  9:  9](RO/H) Reserved. */
        uint64_t ln_an_tx_pause_en     : 1;  /**< [  8:  8](RO/H) Reserved. */
        uint64_t ln_an_dme_tx          : 1;  /**< [  7:  7](RO/H) Reserved. */
        uint64_t ln_an_stat_good       : 1;  /**< [  6:  6](RO/H) Reserved. */
        uint64_t ln_lt_sigdet          : 1;  /**< [  5:  5](RO/H) Link training signal detect, active high. */
        uint64_t ln_stat_rxvalid       : 1;  /**< [  4:  4](RO/H) Lane RX valid, indicates when CDR has locked to data and all RX
                                                                 equalization has completed, active high. */
        uint64_t ln_stat_los           : 1;  /**< [  3:  3](RO/H) Loss of signal indicator:
                                                                   0x0 = Signal detected on LN_RXP/M pins.
                                                                   0x1 = No signal detected on LN_RXP/M pins. */
        uint64_t ln_rx_rdy             : 1;  /**< [  2:  2](RO/H) Lane RX ready indicator, active high. */
        uint64_t ln_tx_rdy             : 1;  /**< [  1:  1](RO/H) Lane TX ready indicator, active high. */
        uint64_t ln_state_chng_rdy     : 1;  /**< [  0:  0](RO/H) Lane reset, rate, and power state change ready status:
                                                                   0x0 = PHY is currently performing a power or rate transition so LN_RST,
                                                                         LN_CTRL_TX_RATE, LN_CTRL_RX_RATE, and LN_PD should not be changed.
                                                                   0x1 = PHY has completed the last transition and is ready for the next
                                                                         request. */
#else /* Word 0 - Little Endian */
        uint64_t ln_state_chng_rdy     : 1;  /**< [  0:  0](RO/H) Lane reset, rate, and power state change ready status:
                                                                   0x0 = PHY is currently performing a power or rate transition so LN_RST,
                                                                         LN_CTRL_TX_RATE, LN_CTRL_RX_RATE, and LN_PD should not be changed.
                                                                   0x1 = PHY has completed the last transition and is ready for the next
                                                                         request. */
        uint64_t ln_tx_rdy             : 1;  /**< [  1:  1](RO/H) Lane TX ready indicator, active high. */
        uint64_t ln_rx_rdy             : 1;  /**< [  2:  2](RO/H) Lane RX ready indicator, active high. */
        uint64_t ln_stat_los           : 1;  /**< [  3:  3](RO/H) Loss of signal indicator:
                                                                   0x0 = Signal detected on LN_RXP/M pins.
                                                                   0x1 = No signal detected on LN_RXP/M pins. */
        uint64_t ln_stat_rxvalid       : 1;  /**< [  4:  4](RO/H) Lane RX valid, indicates when CDR has locked to data and all RX
                                                                 equalization has completed, active high. */
        uint64_t ln_lt_sigdet          : 1;  /**< [  5:  5](RO/H) Link training signal detect, active high. */
        uint64_t ln_an_stat_good       : 1;  /**< [  6:  6](RO/H) Reserved. */
        uint64_t ln_an_dme_tx          : 1;  /**< [  7:  7](RO/H) Reserved. */
        uint64_t ln_an_tx_pause_en     : 1;  /**< [  8:  8](RO/H) Reserved. */
        uint64_t ln_an_rx_pause_en     : 1;  /**< [  9:  9](RO/H) Reserved. */
        uint64_t ln_an_base_fec_en     : 1;  /**< [ 10: 10](RO/H) Reserved. */
        uint64_t ln_an_rs_fec_en       : 1;  /**< [ 11: 11](RO/H) Reserved. */
        uint64_t ln_an_link_sel        : 5;  /**< [ 16: 12](RO/H) Reserved. */
        uint64_t ln_an_scan_for_carrier : 1; /**< [ 17: 17](RO/H) Reserved. */
        uint64_t ln_an_stat_resolved   : 1;  /**< [ 18: 18](RO/H) Reserved. */
        uint64_t ln_tx_fifo_empty      : 1;  /**< [ 19: 19](RO/H) Reserved. */
        uint64_t ln_rx_fifo_full       : 1;  /**< [ 20: 20](RO/H) Reserved. */
        uint64_t ln_rx_bitstrip_err    : 1;  /**< [ 21: 21](RO/H) Sticky bit that signals when the rx div4 fail counter has saturated when
                                                                 trying to lock to the bit stuffed rxdata. */
        uint64_t reserved_22_63        : 42;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lanex_status_bsts_s cn; */
};
typedef union cavm_gsercx_lanex_status_bsts cavm_gsercx_lanex_status_bsts_t;

static inline uint64_t CAVM_GSERCX_LANEX_STATUS_BSTS(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LANEX_STATUS_BSTS(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8081070ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8081070ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LANEX_STATUS_BSTS", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LANEX_STATUS_BSTS(a,b) cavm_gsercx_lanex_status_bsts_t
#define bustype_CAVM_GSERCX_LANEX_STATUS_BSTS(a,b) CSR_TYPE_RSL
#define basename_CAVM_GSERCX_LANEX_STATUS_BSTS(a,b) "GSERCX_LANEX_STATUS_BSTS"
#define device_bar_CAVM_GSERCX_LANEX_STATUS_BSTS(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LANEX_STATUS_BSTS(a,b) (a)
#define arguments_CAVM_GSERCX_LANEX_STATUS_BSTS(a,b) (a),(b),-1,-1

/**
 * Register (RSL) gserc#_lane#_txclk_ctr
 *
 * GSERC Reference Clock Cycle Counter Register
 * A free-running cycle counter of the TX Clock Mux Output to enable rough
 * confirmation of tx clock frequency via software. Read the counter; wait some
 * time, e.g., 100ms; read the counter; calculate frequency based on the difference in
 * values during the known wait time.
 */
union cavm_gsercx_lanex_txclk_ctr
{
    uint64_t u;
    struct cavm_gsercx_lanex_txclk_ctr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t count                 : 64; /**< [ 63:  0](R/W/H) Running cycle count of the TX Clock Mux Output. */
#else /* Word 0 - Little Endian */
        uint64_t count                 : 64; /**< [ 63:  0](R/W/H) Running cycle count of the TX Clock Mux Output. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lanex_txclk_ctr_s cn; */
};
typedef union cavm_gsercx_lanex_txclk_ctr cavm_gsercx_lanex_txclk_ctr_t;

static inline uint64_t CAVM_GSERCX_LANEX_TXCLK_CTR(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LANEX_TXCLK_CTR(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8081090ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8081090ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LANEX_TXCLK_CTR", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LANEX_TXCLK_CTR(a,b) cavm_gsercx_lanex_txclk_ctr_t
#define bustype_CAVM_GSERCX_LANEX_TXCLK_CTR(a,b) CSR_TYPE_RSL
#define basename_CAVM_GSERCX_LANEX_TXCLK_CTR(a,b) "GSERCX_LANEX_TXCLK_CTR"
#define device_bar_CAVM_GSERCX_LANEX_TXCLK_CTR(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LANEX_TXCLK_CTR(a,b) (a)
#define arguments_CAVM_GSERCX_LANEX_TXCLK_CTR(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_base_page0
 *
 * GSERC Ln Aneg Base Page0 Register
 */
union cavm_gsercx_lnx_aneg_base_page0
{
    uint32_t u;
    struct cavm_gsercx_lnx_aneg_base_page0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t echoed_nonce_2_0      : 3;  /**< [  7:  5](RO/H) Echoed Nonce Field bits 2-0.  AN controller generates it. */
        uint32_t selector              : 5;  /**< [  4:  0](RO/H) Technology Select Field. */
#else /* Word 0 - Little Endian */
        uint32_t selector              : 5;  /**< [  4:  0](RO/H) Technology Select Field. */
        uint32_t echoed_nonce_2_0      : 3;  /**< [  7:  5](RO/H) Echoed Nonce Field bits 2-0.  AN controller generates it. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_aneg_base_page0_s cn; */
};
typedef union cavm_gsercx_lnx_aneg_base_page0 cavm_gsercx_lnx_aneg_base_page0_t;

static inline uint64_t CAVM_GSERCX_LNX_ANEG_BASE_PAGE0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_ANEG_BASE_PAGE0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8010cc0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010cc0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_ANEG_BASE_PAGE0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_ANEG_BASE_PAGE0(a,b) cavm_gsercx_lnx_aneg_base_page0_t
#define bustype_CAVM_GSERCX_LNX_ANEG_BASE_PAGE0(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_ANEG_BASE_PAGE0(a,b) "GSERCX_LNX_ANEG_BASE_PAGE0"
#define device_bar_CAVM_GSERCX_LNX_ANEG_BASE_PAGE0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_ANEG_BASE_PAGE0(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_ANEG_BASE_PAGE0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_base_page1
 *
 * GSERC Ln Aneg Base Page1 Register
 */
union cavm_gsercx_lnx_aneg_base_page1
{
    uint32_t u;
    struct cavm_gsercx_lnx_aneg_base_page1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t next_page             : 1;  /**< [  7:  7](R/W/H) Next Page.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t reserved_6            : 1;
        uint32_t remote_fault          : 1;  /**< [  5:  5](R/W/H) Remote Fault Local Device
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t c2                    : 1;  /**< [  4:  4](R/W/H) Reserved always 0. */
        uint32_t asm_dir               : 1;  /**< [  3:  3](R/W/H) Pause ASM_DIR advertised ability
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t pause                 : 1;  /**< [  2:  2](R/W/H) Pause advertised ability.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t echoed_nonce_4_3      : 2;  /**< [  1:  0](RO/H) Echoed Nonce Field bits 4-3.    AN controller generates it. */
#else /* Word 0 - Little Endian */
        uint32_t echoed_nonce_4_3      : 2;  /**< [  1:  0](RO/H) Echoed Nonce Field bits 4-3.    AN controller generates it. */
        uint32_t pause                 : 1;  /**< [  2:  2](R/W/H) Pause advertised ability.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t asm_dir               : 1;  /**< [  3:  3](R/W/H) Pause ASM_DIR advertised ability
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t c2                    : 1;  /**< [  4:  4](R/W/H) Reserved always 0. */
        uint32_t remote_fault          : 1;  /**< [  5:  5](R/W/H) Remote Fault Local Device
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t reserved_6            : 1;
        uint32_t next_page             : 1;  /**< [  7:  7](R/W/H) Next Page.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_aneg_base_page1_s cn; */
};
typedef union cavm_gsercx_lnx_aneg_base_page1 cavm_gsercx_lnx_aneg_base_page1_t;

static inline uint64_t CAVM_GSERCX_LNX_ANEG_BASE_PAGE1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_ANEG_BASE_PAGE1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8010cc8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010cc8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_ANEG_BASE_PAGE1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_ANEG_BASE_PAGE1(a,b) cavm_gsercx_lnx_aneg_base_page1_t
#define bustype_CAVM_GSERCX_LNX_ANEG_BASE_PAGE1(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_ANEG_BASE_PAGE1(a,b) "GSERCX_LNX_ANEG_BASE_PAGE1"
#define device_bar_CAVM_GSERCX_LNX_ANEG_BASE_PAGE1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_ANEG_BASE_PAGE1(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_ANEG_BASE_PAGE1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_base_page2
 *
 * GSERC Ln Aneg Base Page2 Register
 */
union cavm_gsercx_lnx_aneg_base_page2
{
    uint32_t u;
    struct cavm_gsercx_lnx_aneg_base_page2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t tx_nonce              : 5;  /**< [  4:  0](RO/H) Transmitted Nonce Field.  It is generated in hardware. */
#else /* Word 0 - Little Endian */
        uint32_t tx_nonce              : 5;  /**< [  4:  0](RO/H) Transmitted Nonce Field.  It is generated in hardware. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_aneg_base_page2_s cn; */
};
typedef union cavm_gsercx_lnx_aneg_base_page2 cavm_gsercx_lnx_aneg_base_page2_t;

static inline uint64_t CAVM_GSERCX_LNX_ANEG_BASE_PAGE2(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_ANEG_BASE_PAGE2(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8010cd0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010cd0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_ANEG_BASE_PAGE2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_ANEG_BASE_PAGE2(a,b) cavm_gsercx_lnx_aneg_base_page2_t
#define bustype_CAVM_GSERCX_LNX_ANEG_BASE_PAGE2(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_ANEG_BASE_PAGE2(a,b) "GSERCX_LNX_ANEG_BASE_PAGE2"
#define device_bar_CAVM_GSERCX_LNX_ANEG_BASE_PAGE2(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_ANEG_BASE_PAGE2(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_ANEG_BASE_PAGE2(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_base_page_fec
 *
 * GSERC Ln Aneg Base Page Fec Register
 */
union cavm_gsercx_lnx_aneg_base_page_fec
{
    uint32_t u;
    struct cavm_gsercx_lnx_aneg_base_page_fec_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t fc_fec_req_25g        : 1;  /**< [  3:  3](R/W/H) Base page bit F3.  It requests FC-FEC Base-R FEC for 25G-GR or 25G-GR-S 25G-
                                                                 KR/-CR or 25G-KR-S/-CR-S link.  It is defined in IEEE 802.3by.  For prior
                                                                 versions, it corresponds to A24 in base page.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t rs_fec_req_25g        : 1;  /**< [  2:  2](R/W/H) Base page bit F2.  It requests RS-FEC for 25G-GR 25G-KR/-CR link.  It is defined
                                                                 in IEEE 802.3by.  For prior versions, it corresponds to A23 in base page.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t fec_req               : 1;  /**< [  1:  1](R/W/H) Base page bit F1.  It requests FEC to be turned on when supported at the both ends of link.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t fec_ability           : 1;  /**< [  0:  0](R/W/H) Base page bit F0.  It advertises FEC ability.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
#else /* Word 0 - Little Endian */
        uint32_t fec_ability           : 1;  /**< [  0:  0](R/W/H) Base page bit F0.  It advertises FEC ability.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t fec_req               : 1;  /**< [  1:  1](R/W/H) Base page bit F1.  It requests FEC to be turned on when supported at the both ends of link.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t rs_fec_req_25g        : 1;  /**< [  2:  2](R/W/H) Base page bit F2.  It requests RS-FEC for 25G-GR 25G-KR/-CR link.  It is defined
                                                                 in IEEE 802.3by.  For prior versions, it corresponds to A23 in base page.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t fc_fec_req_25g        : 1;  /**< [  3:  3](R/W/H) Base page bit F3.  It requests FC-FEC Base-R FEC for 25G-GR or 25G-GR-S 25G-
                                                                 KR/-CR or 25G-KR-S/-CR-S link.  It is defined in IEEE 802.3by.  For prior
                                                                 versions, it corresponds to A24 in base page.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_aneg_base_page_fec_s cn; */
};
typedef union cavm_gsercx_lnx_aneg_base_page_fec cavm_gsercx_lnx_aneg_base_page_fec_t;

static inline uint64_t CAVM_GSERCX_LNX_ANEG_BASE_PAGE_FEC(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_ANEG_BASE_PAGE_FEC(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8010cf0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010cf0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_ANEG_BASE_PAGE_FEC", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_ANEG_BASE_PAGE_FEC(a,b) cavm_gsercx_lnx_aneg_base_page_fec_t
#define bustype_CAVM_GSERCX_LNX_ANEG_BASE_PAGE_FEC(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_ANEG_BASE_PAGE_FEC(a,b) "GSERCX_LNX_ANEG_BASE_PAGE_FEC"
#define device_bar_CAVM_GSERCX_LNX_ANEG_BASE_PAGE_FEC(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_ANEG_BASE_PAGE_FEC(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_ANEG_BASE_PAGE_FEC(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_base_page_tech0
 *
 * GSERC Ln Aneg Base Page Tech0 Register
 */
union cavm_gsercx_lnx_aneg_base_page_tech0
{
    uint32_t u;
    struct cavm_gsercx_lnx_aneg_base_page_tech0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t ability_100g_kr4      : 1;  /**< [  7:  7](R/W/H) 100GBase-KR4 technology advertised ability.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_100g_kp4      : 1;  /**< [  6:  6](R/W/H) 100GBase-KP4 technology advertised ability.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_100g_cr10     : 1;  /**< [  5:  5](R/W/H) 100GBase-CR10 technology advertised ability.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_40g_cr4       : 1;  /**< [  4:  4](R/W/H) 40GBase-CR4 technology advertised ability.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_40g_kr4       : 1;  /**< [  3:  3](R/W/H) 40GBase-KR4 technology advertised ability.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_10g_kr        : 1;  /**< [  2:  2](R/W/H) 10GBase-KR technology advertised ability.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_10g_kx4       : 1;  /**< [  1:  1](R/W/H) 10GBase-KX4 technology advertised ability.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_1g_kx         : 1;  /**< [  0:  0](R/W/H) 1000Base-KX technology advertised ability
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
#else /* Word 0 - Little Endian */
        uint32_t ability_1g_kx         : 1;  /**< [  0:  0](R/W/H) 1000Base-KX technology advertised ability
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_10g_kx4       : 1;  /**< [  1:  1](R/W/H) 10GBase-KX4 technology advertised ability.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_10g_kr        : 1;  /**< [  2:  2](R/W/H) 10GBase-KR technology advertised ability.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_40g_kr4       : 1;  /**< [  3:  3](R/W/H) 40GBase-KR4 technology advertised ability.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_40g_cr4       : 1;  /**< [  4:  4](R/W/H) 40GBase-CR4 technology advertised ability.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_100g_cr10     : 1;  /**< [  5:  5](R/W/H) 100GBase-CR10 technology advertised ability.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_100g_kp4      : 1;  /**< [  6:  6](R/W/H) 100GBase-KP4 technology advertised ability.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_100g_kr4      : 1;  /**< [  7:  7](R/W/H) 100GBase-KR4 technology advertised ability.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_aneg_base_page_tech0_s cn; */
};
typedef union cavm_gsercx_lnx_aneg_base_page_tech0 cavm_gsercx_lnx_aneg_base_page_tech0_t;

static inline uint64_t CAVM_GSERCX_LNX_ANEG_BASE_PAGE_TECH0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_ANEG_BASE_PAGE_TECH0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8010cd8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010cd8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_ANEG_BASE_PAGE_TECH0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_ANEG_BASE_PAGE_TECH0(a,b) cavm_gsercx_lnx_aneg_base_page_tech0_t
#define bustype_CAVM_GSERCX_LNX_ANEG_BASE_PAGE_TECH0(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_ANEG_BASE_PAGE_TECH0(a,b) "GSERCX_LNX_ANEG_BASE_PAGE_TECH0"
#define device_bar_CAVM_GSERCX_LNX_ANEG_BASE_PAGE_TECH0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_ANEG_BASE_PAGE_TECH0(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_ANEG_BASE_PAGE_TECH0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_base_page_tech1
 *
 * GSERC Ln Aneg Base Page Tech1 Register
 */
union cavm_gsercx_lnx_aneg_base_page_tech1
{
    uint32_t u;
    struct cavm_gsercx_lnx_aneg_base_page_tech1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t ability_a15_a11       : 5;  /**< [  7:  3](R/W/H) Technology advertised ability Field A15-A11.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_25g_gr        : 1;  /**< [  2:  2](R/W/H) 25GBase-GR KR or CR technology advertised ability.  It is defined in IEEE
                                                                 802.3by.  For prior versions, it corresponds to A10 in base page.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_25g_gr_s      : 1;  /**< [  1:  1](R/W/H) 25GBase-GR-S KR or CR technology advertised ability.  It is defined in IEEE
                                                                 802.3by.  For prior versions, it corresponds to A9 in base page.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_100g_cr4      : 1;  /**< [  0:  0](R/W/H) 100GBase-CR4 technology advertised ability.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
#else /* Word 0 - Little Endian */
        uint32_t ability_100g_cr4      : 1;  /**< [  0:  0](R/W/H) 100GBase-CR4 technology advertised ability.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_25g_gr_s      : 1;  /**< [  1:  1](R/W/H) 25GBase-GR-S KR or CR technology advertised ability.  It is defined in IEEE
                                                                 802.3by.  For prior versions, it corresponds to A9 in base page.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_25g_gr        : 1;  /**< [  2:  2](R/W/H) 25GBase-GR KR or CR technology advertised ability.  It is defined in IEEE
                                                                 802.3by.  For prior versions, it corresponds to A10 in base page.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_a15_a11       : 5;  /**< [  7:  3](R/W/H) Technology advertised ability Field A15-A11.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_aneg_base_page_tech1_s cn; */
};
typedef union cavm_gsercx_lnx_aneg_base_page_tech1 cavm_gsercx_lnx_aneg_base_page_tech1_t;

static inline uint64_t CAVM_GSERCX_LNX_ANEG_BASE_PAGE_TECH1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_ANEG_BASE_PAGE_TECH1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8010ce0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010ce0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_ANEG_BASE_PAGE_TECH1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_ANEG_BASE_PAGE_TECH1(a,b) cavm_gsercx_lnx_aneg_base_page_tech1_t
#define bustype_CAVM_GSERCX_LNX_ANEG_BASE_PAGE_TECH1(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_ANEG_BASE_PAGE_TECH1(a,b) "GSERCX_LNX_ANEG_BASE_PAGE_TECH1"
#define device_bar_CAVM_GSERCX_LNX_ANEG_BASE_PAGE_TECH1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_ANEG_BASE_PAGE_TECH1(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_ANEG_BASE_PAGE_TECH1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_base_page_tech2
 *
 * GSERC Ln Aneg Base Page Tech2 Register
 */
union cavm_gsercx_lnx_aneg_base_page_tech2
{
    uint32_t u;
    struct cavm_gsercx_lnx_aneg_base_page_tech2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t ability_a22_a16       : 7;  /**< [  6:  0](R/W/H) Technology advertised ability Field A22-A16.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
#else /* Word 0 - Little Endian */
        uint32_t ability_a22_a16       : 7;  /**< [  6:  0](R/W/H) Technology advertised ability Field A22-A16.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_aneg_base_page_tech2_s cn; */
};
typedef union cavm_gsercx_lnx_aneg_base_page_tech2 cavm_gsercx_lnx_aneg_base_page_tech2_t;

static inline uint64_t CAVM_GSERCX_LNX_ANEG_BASE_PAGE_TECH2(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_ANEG_BASE_PAGE_TECH2(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8010ce8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010ce8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_ANEG_BASE_PAGE_TECH2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_ANEG_BASE_PAGE_TECH2(a,b) cavm_gsercx_lnx_aneg_base_page_tech2_t
#define bustype_CAVM_GSERCX_LNX_ANEG_BASE_PAGE_TECH2(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_ANEG_BASE_PAGE_TECH2(a,b) "GSERCX_LNX_ANEG_BASE_PAGE_TECH2"
#define device_bar_CAVM_GSERCX_LNX_ANEG_BASE_PAGE_TECH2(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_ANEG_BASE_PAGE_TECH2(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_ANEG_BASE_PAGE_TECH2(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_cfg10
 *
 * GSERC Ln Aneg Cfg10 Register
 */
union cavm_gsercx_lnx_aneg_cfg10
{
    uint32_t u;
    struct cavm_gsercx_lnx_aneg_cfg10_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t nonce_seed            : 8;  /**< [  7:  0](R/W/H) Seed provided to the transmit nonce generator polynomial. */
#else /* Word 0 - Little Endian */
        uint32_t nonce_seed            : 8;  /**< [  7:  0](R/W/H) Seed provided to the transmit nonce generator polynomial. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_aneg_cfg10_s cn; */
};
typedef union cavm_gsercx_lnx_aneg_cfg10 cavm_gsercx_lnx_aneg_cfg10_t;

static inline uint64_t CAVM_GSERCX_LNX_ANEG_CFG10(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_ANEG_CFG10(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8010c50ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010c50ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_ANEG_CFG10", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_ANEG_CFG10(a,b) cavm_gsercx_lnx_aneg_cfg10_t
#define bustype_CAVM_GSERCX_LNX_ANEG_CFG10(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_ANEG_CFG10(a,b) "GSERCX_LNX_ANEG_CFG10"
#define device_bar_CAVM_GSERCX_LNX_ANEG_CFG10(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_ANEG_CFG10(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_ANEG_CFG10(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_cfg11
 *
 * GSERC Ln Aneg Cfg11 Register
 */
union cavm_gsercx_lnx_aneg_cfg11
{
    uint32_t u;
    struct cavm_gsercx_lnx_aneg_cfg11_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t pseudo_sel            : 1;  /**< [  0:  0](R/W/H) Selector for the DME page bit 49 pseudo-random generator. */
#else /* Word 0 - Little Endian */
        uint32_t pseudo_sel            : 1;  /**< [  0:  0](R/W/H) Selector for the DME page bit 49 pseudo-random generator. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_aneg_cfg11_s cn; */
};
typedef union cavm_gsercx_lnx_aneg_cfg11 cavm_gsercx_lnx_aneg_cfg11_t;

static inline uint64_t CAVM_GSERCX_LNX_ANEG_CFG11(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_ANEG_CFG11(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8010c58ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010c58ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_ANEG_CFG11", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_ANEG_CFG11(a,b) cavm_gsercx_lnx_aneg_cfg11_t
#define bustype_CAVM_GSERCX_LNX_ANEG_CFG11(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_ANEG_CFG11(a,b) "GSERCX_LNX_ANEG_CFG11"
#define device_bar_CAVM_GSERCX_LNX_ANEG_CFG11(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_ANEG_CFG11(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_ANEG_CFG11(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_ctrl0
 *
 * GSERC Ln Aneg Ctrl0 Register
 */
union cavm_gsercx_lnx_aneg_ctrl0
{
    uint32_t u;
    struct cavm_gsercx_lnx_aneg_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t autoneg_restart       : 1;  /**< [  0:  0](R/W/H) Restarts AN that is already in progress or otherwise completed.  Reset is
                                                                 triggered by rising edge of this signal.  Not self clearing. */
#else /* Word 0 - Little Endian */
        uint32_t autoneg_restart       : 1;  /**< [  0:  0](R/W/H) Restarts AN that is already in progress or otherwise completed.  Reset is
                                                                 triggered by rising edge of this signal.  Not self clearing. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    struct cavm_gsercx_lnx_aneg_ctrl0_cn
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t reserved_1_7          : 7;
        uint32_t autoneg_restart       : 1;  /**< [  0:  0](R/W/H) Restarts AN that is already in progress or otherwise completed.  Reset is
                                                                 triggered by rising edge of this signal.  Not self clearing. */
#else /* Word 0 - Little Endian */
        uint32_t autoneg_restart       : 1;  /**< [  0:  0](R/W/H) Restarts AN that is already in progress or otherwise completed.  Reset is
                                                                 triggered by rising edge of this signal.  Not self clearing. */
        uint32_t reserved_1_7          : 7;
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } cn;
};
typedef union cavm_gsercx_lnx_aneg_ctrl0 cavm_gsercx_lnx_aneg_ctrl0_t;

static inline uint64_t CAVM_GSERCX_LNX_ANEG_CTRL0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_ANEG_CTRL0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8010c60ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010c60ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_ANEG_CTRL0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_ANEG_CTRL0(a,b) cavm_gsercx_lnx_aneg_ctrl0_t
#define bustype_CAVM_GSERCX_LNX_ANEG_CTRL0(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_ANEG_CTRL0(a,b) "GSERCX_LNX_ANEG_CTRL0"
#define device_bar_CAVM_GSERCX_LNX_ANEG_CTRL0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_ANEG_CTRL0(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_ANEG_CTRL0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_extended0
 *
 * GSERC Ln Aneg Extended0 Register
 */
union cavm_gsercx_lnx_aneg_extended0
{
    uint32_t u;
    struct cavm_gsercx_lnx_aneg_extended0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t fc_fec_req            : 1;  /**< [  7:  7](R/W/H) Extended advertised FEC field 3.  It requests Fire code FEC to be turned on when
                                                                 supported at the both ends of link for 25G/50G consortium specification non-
                                                                 IEEE.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t rs_fec_req            : 1;  /**< [  6:  6](R/W/H) Extended advertised FEC field 2.  It requests Reed-Solomon FEC to be turned on
                                                                 when supported at the both ends of link for 25G/50G consortium specification
                                                                 non-IEEE.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t fc_fec_ability        : 1;  /**< [  5:  5](R/W/H) Extended advertised FEC field 1.  It advertises Fire code FEC CL74 ability for
                                                                 25G/50G consortium specification non-IEEE.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t rs_fec_ability        : 1;  /**< [  4:  4](R/W/H) Extended advertised FEC field 0.  It advertises Reed-Solomon FEC CL91 ability
                                                                 for 25G/50G consortium specification non-IEEE.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_50g_cr2       : 1;  /**< [  3:  3](R/W/H) 50GBase-CR2 technology advertised ability for 25G/50G consortium specification non-IEEE.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_50g_kr2       : 1;  /**< [  2:  2](R/W/H) 50GBase-KR2 technology advertised ability for 25G/50G consortium specification non-IEEE.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_25g_cr        : 1;  /**< [  1:  1](R/W/H) 25GBase-CR technology advertised ability for 25G/50G consortium specification non-IEEE.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_25g_kr        : 1;  /**< [  0:  0](R/W/H) 25GBase-KR technology advertised ability for 25G/50G consortium specification non-IEEE.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
#else /* Word 0 - Little Endian */
        uint32_t ability_25g_kr        : 1;  /**< [  0:  0](R/W/H) 25GBase-KR technology advertised ability for 25G/50G consortium specification non-IEEE.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_25g_cr        : 1;  /**< [  1:  1](R/W/H) 25GBase-CR technology advertised ability for 25G/50G consortium specification non-IEEE.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_50g_kr2       : 1;  /**< [  2:  2](R/W/H) 50GBase-KR2 technology advertised ability for 25G/50G consortium specification non-IEEE.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_50g_cr2       : 1;  /**< [  3:  3](R/W/H) 50GBase-CR2 technology advertised ability for 25G/50G consortium specification non-IEEE.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t rs_fec_ability        : 1;  /**< [  4:  4](R/W/H) Extended advertised FEC field 0.  It advertises Reed-Solomon FEC CL91 ability
                                                                 for 25G/50G consortium specification non-IEEE.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t fc_fec_ability        : 1;  /**< [  5:  5](R/W/H) Extended advertised FEC field 1.  It advertises Fire code FEC CL74 ability for
                                                                 25G/50G consortium specification non-IEEE.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t rs_fec_req            : 1;  /**< [  6:  6](R/W/H) Extended advertised FEC field 2.  It requests Reed-Solomon FEC to be turned on
                                                                 when supported at the both ends of link for 25G/50G consortium specification
                                                                 non-IEEE.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t fc_fec_req            : 1;  /**< [  7:  7](R/W/H) Extended advertised FEC field 3.  It requests Fire code FEC to be turned on when
                                                                 supported at the both ends of link for 25G/50G consortium specification non-
                                                                 IEEE.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_aneg_extended0_s cn; */
};
typedef union cavm_gsercx_lnx_aneg_extended0 cavm_gsercx_lnx_aneg_extended0_t;

static inline uint64_t CAVM_GSERCX_LNX_ANEG_EXTENDED0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_ANEG_EXTENDED0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8010cf8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010cf8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_ANEG_EXTENDED0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_ANEG_EXTENDED0(a,b) cavm_gsercx_lnx_aneg_extended0_t
#define bustype_CAVM_GSERCX_LNX_ANEG_EXTENDED0(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_ANEG_EXTENDED0(a,b) "GSERCX_LNX_ANEG_EXTENDED0"
#define device_bar_CAVM_GSERCX_LNX_ANEG_EXTENDED0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_ANEG_EXTENDED0(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_ANEG_EXTENDED0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_link_status0
 *
 * GSERC Ln Aneg Link Status0 Register
 */
union cavm_gsercx_lnx_aneg_link_status0
{
    uint32_t u;
    struct cavm_gsercx_lnx_aneg_link_status0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t ability_100g_kr4      : 1;  /**< [  7:  7](RO/H) Link status for 100GBase-KR4. */
        uint32_t ability_100g_kp4      : 1;  /**< [  6:  6](RO/H) Link status for 100GBase-KP4. */
        uint32_t ability_100g_cr10     : 1;  /**< [  5:  5](RO/H) Link status for 100GBase-CR10. */
        uint32_t ability_40g_cr4       : 1;  /**< [  4:  4](RO/H) Link status for 40GBase-CR4. */
        uint32_t ability_40g_kr4       : 1;  /**< [  3:  3](RO/H) Link status for 40GBase-KR4. */
        uint32_t ability_10g_kr        : 1;  /**< [  2:  2](RO/H) Link status for 10GBase-KR. */
        uint32_t ability_10g_kx4       : 1;  /**< [  1:  1](RO/H) Link status for 10GBase-KX4. */
        uint32_t ability_1g_kx         : 1;  /**< [  0:  0](RO/H) Link status for 1000Base-KX. */
#else /* Word 0 - Little Endian */
        uint32_t ability_1g_kx         : 1;  /**< [  0:  0](RO/H) Link status for 1000Base-KX. */
        uint32_t ability_10g_kx4       : 1;  /**< [  1:  1](RO/H) Link status for 10GBase-KX4. */
        uint32_t ability_10g_kr        : 1;  /**< [  2:  2](RO/H) Link status for 10GBase-KR. */
        uint32_t ability_40g_kr4       : 1;  /**< [  3:  3](RO/H) Link status for 40GBase-KR4. */
        uint32_t ability_40g_cr4       : 1;  /**< [  4:  4](RO/H) Link status for 40GBase-CR4. */
        uint32_t ability_100g_cr10     : 1;  /**< [  5:  5](RO/H) Link status for 100GBase-CR10. */
        uint32_t ability_100g_kp4      : 1;  /**< [  6:  6](RO/H) Link status for 100GBase-KP4. */
        uint32_t ability_100g_kr4      : 1;  /**< [  7:  7](RO/H) Link status for 100GBase-KR4. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_aneg_link_status0_s cn; */
};
typedef union cavm_gsercx_lnx_aneg_link_status0 cavm_gsercx_lnx_aneg_link_status0_t;

static inline uint64_t CAVM_GSERCX_LNX_ANEG_LINK_STATUS0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_ANEG_LINK_STATUS0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8010df0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010df0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_ANEG_LINK_STATUS0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_ANEG_LINK_STATUS0(a,b) cavm_gsercx_lnx_aneg_link_status0_t
#define bustype_CAVM_GSERCX_LNX_ANEG_LINK_STATUS0(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_ANEG_LINK_STATUS0(a,b) "GSERCX_LNX_ANEG_LINK_STATUS0"
#define device_bar_CAVM_GSERCX_LNX_ANEG_LINK_STATUS0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_ANEG_LINK_STATUS0(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_ANEG_LINK_STATUS0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_link_status1
 *
 * GSERC Ln Aneg Link Status1 Register
 */
union cavm_gsercx_lnx_aneg_link_status1
{
    uint32_t u;
    struct cavm_gsercx_lnx_aneg_link_status1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t ability_50g_cr2       : 1;  /**< [  6:  6](RO/H) Link status for 50GBase-CR2. */
        uint32_t ability_50g_kr2       : 1;  /**< [  5:  5](RO/H) Link status for 50GBase-KR2. */
        uint32_t ability_25g_cr        : 1;  /**< [  4:  4](RO/H) Link status for 25GBase-CR4. */
        uint32_t ability_25g_kr        : 1;  /**< [  3:  3](RO/H) Link status for 25GBase-KR. */
        uint32_t reserved_2            : 1;
        uint32_t ability_25g_gr        : 1;  /**< [  1:  1](RO/H) Link status for 25GBase-GR KR/CR or 25GBase-GR-S KR-S/CR-S. */
        uint32_t ability_100g_cr4      : 1;  /**< [  0:  0](RO/H) Link status for 100GBase-CR4. */
#else /* Word 0 - Little Endian */
        uint32_t ability_100g_cr4      : 1;  /**< [  0:  0](RO/H) Link status for 100GBase-CR4. */
        uint32_t ability_25g_gr        : 1;  /**< [  1:  1](RO/H) Link status for 25GBase-GR KR/CR or 25GBase-GR-S KR-S/CR-S. */
        uint32_t reserved_2            : 1;
        uint32_t ability_25g_kr        : 1;  /**< [  3:  3](RO/H) Link status for 25GBase-KR. */
        uint32_t ability_25g_cr        : 1;  /**< [  4:  4](RO/H) Link status for 25GBase-CR4. */
        uint32_t ability_50g_kr2       : 1;  /**< [  5:  5](RO/H) Link status for 50GBase-KR2. */
        uint32_t ability_50g_cr2       : 1;  /**< [  6:  6](RO/H) Link status for 50GBase-CR2. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_aneg_link_status1_s cn; */
};
typedef union cavm_gsercx_lnx_aneg_link_status1 cavm_gsercx_lnx_aneg_link_status1_t;

static inline uint64_t CAVM_GSERCX_LNX_ANEG_LINK_STATUS1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_ANEG_LINK_STATUS1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8010df8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010df8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_ANEG_LINK_STATUS1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_ANEG_LINK_STATUS1(a,b) cavm_gsercx_lnx_aneg_link_status1_t
#define bustype_CAVM_GSERCX_LNX_ANEG_LINK_STATUS1(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_ANEG_LINK_STATUS1(a,b) "GSERCX_LNX_ANEG_LINK_STATUS1"
#define device_bar_CAVM_GSERCX_LNX_ANEG_LINK_STATUS1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_ANEG_LINK_STATUS1(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_ANEG_LINK_STATUS1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_lp_base_page0
 *
 * GSERC Ln Aneg Lp Base Page0 Register
 */
union cavm_gsercx_lnx_aneg_lp_base_page0
{
    uint32_t u;
    struct cavm_gsercx_lnx_aneg_lp_base_page0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t echoed_nonce_2_0      : 3;  /**< [  7:  5](RO/H) Link partner Echoed Nonce Field bits 2-0. */
        uint32_t selector              : 5;  /**< [  4:  0](RO/H) Link partner technology Select Field. */
#else /* Word 0 - Little Endian */
        uint32_t selector              : 5;  /**< [  4:  0](RO/H) Link partner technology Select Field. */
        uint32_t echoed_nonce_2_0      : 3;  /**< [  7:  5](RO/H) Link partner Echoed Nonce Field bits 2-0. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_aneg_lp_base_page0_s cn; */
};
typedef union cavm_gsercx_lnx_aneg_lp_base_page0 cavm_gsercx_lnx_aneg_lp_base_page0_t;

static inline uint64_t CAVM_GSERCX_LNX_ANEG_LP_BASE_PAGE0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_ANEG_LP_BASE_PAGE0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8010d40ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010d40ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_ANEG_LP_BASE_PAGE0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_ANEG_LP_BASE_PAGE0(a,b) cavm_gsercx_lnx_aneg_lp_base_page0_t
#define bustype_CAVM_GSERCX_LNX_ANEG_LP_BASE_PAGE0(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_ANEG_LP_BASE_PAGE0(a,b) "GSERCX_LNX_ANEG_LP_BASE_PAGE0"
#define device_bar_CAVM_GSERCX_LNX_ANEG_LP_BASE_PAGE0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_ANEG_LP_BASE_PAGE0(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_ANEG_LP_BASE_PAGE0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_lp_base_page1
 *
 * GSERC Ln Aneg Lp Base Page1 Register
 */
union cavm_gsercx_lnx_aneg_lp_base_page1
{
    uint32_t u;
    struct cavm_gsercx_lnx_aneg_lp_base_page1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t next_page             : 1;  /**< [  7:  7](RO/H) Link partner Next Page. */
        uint32_t ack                   : 1;  /**< [  6:  6](RO/H) Link partner Acknowledge always 0. */
        uint32_t remote_fault          : 1;  /**< [  5:  5](RO/H) Link partner Remote Fault. */
        uint32_t c2                    : 1;  /**< [  4:  4](RO/H) Link partner C2 field always 0. */
        uint32_t asm_dir               : 1;  /**< [  3:  3](RO/H) Link partner Pause ASM_DIR advertised ability. */
        uint32_t pause                 : 1;  /**< [  2:  2](RO/H) Link partner Pause advertised ability. */
        uint32_t echoed_nonce_4_3      : 2;  /**< [  1:  0](RO/H) Link partner Echoed Nonce Field bits 4-3. */
#else /* Word 0 - Little Endian */
        uint32_t echoed_nonce_4_3      : 2;  /**< [  1:  0](RO/H) Link partner Echoed Nonce Field bits 4-3. */
        uint32_t pause                 : 1;  /**< [  2:  2](RO/H) Link partner Pause advertised ability. */
        uint32_t asm_dir               : 1;  /**< [  3:  3](RO/H) Link partner Pause ASM_DIR advertised ability. */
        uint32_t c2                    : 1;  /**< [  4:  4](RO/H) Link partner C2 field always 0. */
        uint32_t remote_fault          : 1;  /**< [  5:  5](RO/H) Link partner Remote Fault. */
        uint32_t ack                   : 1;  /**< [  6:  6](RO/H) Link partner Acknowledge always 0. */
        uint32_t next_page             : 1;  /**< [  7:  7](RO/H) Link partner Next Page. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_aneg_lp_base_page1_s cn; */
};
typedef union cavm_gsercx_lnx_aneg_lp_base_page1 cavm_gsercx_lnx_aneg_lp_base_page1_t;

static inline uint64_t CAVM_GSERCX_LNX_ANEG_LP_BASE_PAGE1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_ANEG_LP_BASE_PAGE1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8010d48ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010d48ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_ANEG_LP_BASE_PAGE1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_ANEG_LP_BASE_PAGE1(a,b) cavm_gsercx_lnx_aneg_lp_base_page1_t
#define bustype_CAVM_GSERCX_LNX_ANEG_LP_BASE_PAGE1(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_ANEG_LP_BASE_PAGE1(a,b) "GSERCX_LNX_ANEG_LP_BASE_PAGE1"
#define device_bar_CAVM_GSERCX_LNX_ANEG_LP_BASE_PAGE1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_ANEG_LP_BASE_PAGE1(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_ANEG_LP_BASE_PAGE1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_lp_base_page2
 *
 * GSERC Ln Aneg Lp Base Page2 Register
 */
union cavm_gsercx_lnx_aneg_lp_base_page2
{
    uint32_t u;
    struct cavm_gsercx_lnx_aneg_lp_base_page2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t tx_nonce              : 5;  /**< [  4:  0](RO/H) Transmitted Nonce Field from Link partner. */
#else /* Word 0 - Little Endian */
        uint32_t tx_nonce              : 5;  /**< [  4:  0](RO/H) Transmitted Nonce Field from Link partner. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_aneg_lp_base_page2_s cn; */
};
typedef union cavm_gsercx_lnx_aneg_lp_base_page2 cavm_gsercx_lnx_aneg_lp_base_page2_t;

static inline uint64_t CAVM_GSERCX_LNX_ANEG_LP_BASE_PAGE2(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_ANEG_LP_BASE_PAGE2(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8010d50ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010d50ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_ANEG_LP_BASE_PAGE2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_ANEG_LP_BASE_PAGE2(a,b) cavm_gsercx_lnx_aneg_lp_base_page2_t
#define bustype_CAVM_GSERCX_LNX_ANEG_LP_BASE_PAGE2(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_ANEG_LP_BASE_PAGE2(a,b) "GSERCX_LNX_ANEG_LP_BASE_PAGE2"
#define device_bar_CAVM_GSERCX_LNX_ANEG_LP_BASE_PAGE2(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_ANEG_LP_BASE_PAGE2(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_ANEG_LP_BASE_PAGE2(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_lp_base_page_fec
 *
 * GSERC Ln Aneg Lp Base Page Fec Register
 */
union cavm_gsercx_lnx_aneg_lp_base_page_fec
{
    uint32_t u;
    struct cavm_gsercx_lnx_aneg_lp_base_page_fec_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t fc_fec_req_25g        : 1;  /**< [  3:  3](RO/H) Link partner base page bit F3.  It requests FC-FEC Base-R FEC for 25G-GR or 25G-
                                                                 GR-S 25G-KR/-CR or 25G-KR-S/-CR-S link.  It is defined in IEEE 802.3by.  For
                                                                 prior versions, it corresponds to A24 in base page. */
        uint32_t rs_fec_req_25g        : 1;  /**< [  2:  2](RO/H) Link partner base page bit F2.  It requests RS-FEC for 25G-GR 25G-KR/-CR link.
                                                                 It is defined in IEEE 802.3by.  For prior versions, it corresponds to A23 in
                                                                 base page. */
        uint32_t fec_req               : 1;  /**< [  1:  1](RO/H) Link partner base page bit F1.  It requests FEC to be turned on when supported
                                                                 at the both ends of link. */
        uint32_t fec_ability           : 1;  /**< [  0:  0](RO/H) Link partner base page bit F0.  It advertises FEC ability. */
#else /* Word 0 - Little Endian */
        uint32_t fec_ability           : 1;  /**< [  0:  0](RO/H) Link partner base page bit F0.  It advertises FEC ability. */
        uint32_t fec_req               : 1;  /**< [  1:  1](RO/H) Link partner base page bit F1.  It requests FEC to be turned on when supported
                                                                 at the both ends of link. */
        uint32_t rs_fec_req_25g        : 1;  /**< [  2:  2](RO/H) Link partner base page bit F2.  It requests RS-FEC for 25G-GR 25G-KR/-CR link.
                                                                 It is defined in IEEE 802.3by.  For prior versions, it corresponds to A23 in
                                                                 base page. */
        uint32_t fc_fec_req_25g        : 1;  /**< [  3:  3](RO/H) Link partner base page bit F3.  It requests FC-FEC Base-R FEC for 25G-GR or 25G-
                                                                 GR-S 25G-KR/-CR or 25G-KR-S/-CR-S link.  It is defined in IEEE 802.3by.  For
                                                                 prior versions, it corresponds to A24 in base page. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_aneg_lp_base_page_fec_s cn; */
};
typedef union cavm_gsercx_lnx_aneg_lp_base_page_fec cavm_gsercx_lnx_aneg_lp_base_page_fec_t;

static inline uint64_t CAVM_GSERCX_LNX_ANEG_LP_BASE_PAGE_FEC(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_ANEG_LP_BASE_PAGE_FEC(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8010d70ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010d70ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_ANEG_LP_BASE_PAGE_FEC", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_ANEG_LP_BASE_PAGE_FEC(a,b) cavm_gsercx_lnx_aneg_lp_base_page_fec_t
#define bustype_CAVM_GSERCX_LNX_ANEG_LP_BASE_PAGE_FEC(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_ANEG_LP_BASE_PAGE_FEC(a,b) "GSERCX_LNX_ANEG_LP_BASE_PAGE_FEC"
#define device_bar_CAVM_GSERCX_LNX_ANEG_LP_BASE_PAGE_FEC(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_ANEG_LP_BASE_PAGE_FEC(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_ANEG_LP_BASE_PAGE_FEC(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_lp_base_page_tech0
 *
 * GSERC Ln Aneg Lp Base Page Tech0 Register
 */
union cavm_gsercx_lnx_aneg_lp_base_page_tech0
{
    uint32_t u;
    struct cavm_gsercx_lnx_aneg_lp_base_page_tech0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t ability_100g_kr4      : 1;  /**< [  7:  7](RO/H) Link partner 100GBase-KR4 technology advertised ability. */
        uint32_t ability_100g_kp4      : 1;  /**< [  6:  6](RO/H) Link partner 100GBase-KP4 technology advertised ability. */
        uint32_t ability_100g_cr10     : 1;  /**< [  5:  5](RO/H) Link partner 100GBase-CR10 technology advertised ability. */
        uint32_t ability_40g_cr4       : 1;  /**< [  4:  4](RO/H) Link partner 40GBase-CR4 technology advertised ability. */
        uint32_t ability_40g_kr4       : 1;  /**< [  3:  3](RO/H) Link partner 40GBase-KR4 technology advertised ability. */
        uint32_t ability_10g_kr        : 1;  /**< [  2:  2](RO/H) Link partner 10GBase-KR technology advertised ability. */
        uint32_t ability_10g_kx4       : 1;  /**< [  1:  1](RO/H) Link partner 10GBase-KX4 technology advertised ability. */
        uint32_t ability_1g_kx         : 1;  /**< [  0:  0](RO/H) Link partner 1000Base-KX technology advertised ability. */
#else /* Word 0 - Little Endian */
        uint32_t ability_1g_kx         : 1;  /**< [  0:  0](RO/H) Link partner 1000Base-KX technology advertised ability. */
        uint32_t ability_10g_kx4       : 1;  /**< [  1:  1](RO/H) Link partner 10GBase-KX4 technology advertised ability. */
        uint32_t ability_10g_kr        : 1;  /**< [  2:  2](RO/H) Link partner 10GBase-KR technology advertised ability. */
        uint32_t ability_40g_kr4       : 1;  /**< [  3:  3](RO/H) Link partner 40GBase-KR4 technology advertised ability. */
        uint32_t ability_40g_cr4       : 1;  /**< [  4:  4](RO/H) Link partner 40GBase-CR4 technology advertised ability. */
        uint32_t ability_100g_cr10     : 1;  /**< [  5:  5](RO/H) Link partner 100GBase-CR10 technology advertised ability. */
        uint32_t ability_100g_kp4      : 1;  /**< [  6:  6](RO/H) Link partner 100GBase-KP4 technology advertised ability. */
        uint32_t ability_100g_kr4      : 1;  /**< [  7:  7](RO/H) Link partner 100GBase-KR4 technology advertised ability. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_aneg_lp_base_page_tech0_s cn; */
};
typedef union cavm_gsercx_lnx_aneg_lp_base_page_tech0 cavm_gsercx_lnx_aneg_lp_base_page_tech0_t;

static inline uint64_t CAVM_GSERCX_LNX_ANEG_LP_BASE_PAGE_TECH0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_ANEG_LP_BASE_PAGE_TECH0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8010d58ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010d58ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_ANEG_LP_BASE_PAGE_TECH0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_ANEG_LP_BASE_PAGE_TECH0(a,b) cavm_gsercx_lnx_aneg_lp_base_page_tech0_t
#define bustype_CAVM_GSERCX_LNX_ANEG_LP_BASE_PAGE_TECH0(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_ANEG_LP_BASE_PAGE_TECH0(a,b) "GSERCX_LNX_ANEG_LP_BASE_PAGE_TECH0"
#define device_bar_CAVM_GSERCX_LNX_ANEG_LP_BASE_PAGE_TECH0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_ANEG_LP_BASE_PAGE_TECH0(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_ANEG_LP_BASE_PAGE_TECH0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_lp_base_page_tech1
 *
 * GSERC Ln Aneg Lp Base Page Tech1 Register
 */
union cavm_gsercx_lnx_aneg_lp_base_page_tech1
{
    uint32_t u;
    struct cavm_gsercx_lnx_aneg_lp_base_page_tech1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t ability_a15_a11       : 5;  /**< [  7:  3](RO/H) Link partner technology advertised ability Field A15-A11. */
        uint32_t ability_25g_gr        : 1;  /**< [  2:  2](RO/H) Link partner 25GBase-GR KR or CR technology advertised ability.  It is defined
                                                                 in IEEE 802.3by.  For prior versions, it corresponds to A10 in base page. */
        uint32_t ability_25g_gr_s      : 1;  /**< [  1:  1](RO/H) Link partner 25GBase-GR-S KR or CR technology advertised ability.  It is defined
                                                                 in IEEE 802.3by.  For prior versions, it corresponds to A9 in base page. */
        uint32_t ability_100g_cr4      : 1;  /**< [  0:  0](RO/H) Link partner 100GBase-CR4 technology advertised ability. */
#else /* Word 0 - Little Endian */
        uint32_t ability_100g_cr4      : 1;  /**< [  0:  0](RO/H) Link partner 100GBase-CR4 technology advertised ability. */
        uint32_t ability_25g_gr_s      : 1;  /**< [  1:  1](RO/H) Link partner 25GBase-GR-S KR or CR technology advertised ability.  It is defined
                                                                 in IEEE 802.3by.  For prior versions, it corresponds to A9 in base page. */
        uint32_t ability_25g_gr        : 1;  /**< [  2:  2](RO/H) Link partner 25GBase-GR KR or CR technology advertised ability.  It is defined
                                                                 in IEEE 802.3by.  For prior versions, it corresponds to A10 in base page. */
        uint32_t ability_a15_a11       : 5;  /**< [  7:  3](RO/H) Link partner technology advertised ability Field A15-A11. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_aneg_lp_base_page_tech1_s cn; */
};
typedef union cavm_gsercx_lnx_aneg_lp_base_page_tech1 cavm_gsercx_lnx_aneg_lp_base_page_tech1_t;

static inline uint64_t CAVM_GSERCX_LNX_ANEG_LP_BASE_PAGE_TECH1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_ANEG_LP_BASE_PAGE_TECH1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8010d60ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010d60ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_ANEG_LP_BASE_PAGE_TECH1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_ANEG_LP_BASE_PAGE_TECH1(a,b) cavm_gsercx_lnx_aneg_lp_base_page_tech1_t
#define bustype_CAVM_GSERCX_LNX_ANEG_LP_BASE_PAGE_TECH1(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_ANEG_LP_BASE_PAGE_TECH1(a,b) "GSERCX_LNX_ANEG_LP_BASE_PAGE_TECH1"
#define device_bar_CAVM_GSERCX_LNX_ANEG_LP_BASE_PAGE_TECH1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_ANEG_LP_BASE_PAGE_TECH1(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_ANEG_LP_BASE_PAGE_TECH1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_lp_base_page_tech2
 *
 * GSERC Ln Aneg Lp Base Page Tech2 Register
 */
union cavm_gsercx_lnx_aneg_lp_base_page_tech2
{
    uint32_t u;
    struct cavm_gsercx_lnx_aneg_lp_base_page_tech2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t ability_a22_a16       : 7;  /**< [  6:  0](RO/H) Link partner technology advertised ability Field A22-A16. */
#else /* Word 0 - Little Endian */
        uint32_t ability_a22_a16       : 7;  /**< [  6:  0](RO/H) Link partner technology advertised ability Field A22-A16. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_aneg_lp_base_page_tech2_s cn; */
};
typedef union cavm_gsercx_lnx_aneg_lp_base_page_tech2 cavm_gsercx_lnx_aneg_lp_base_page_tech2_t;

static inline uint64_t CAVM_GSERCX_LNX_ANEG_LP_BASE_PAGE_TECH2(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_ANEG_LP_BASE_PAGE_TECH2(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8010d68ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010d68ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_ANEG_LP_BASE_PAGE_TECH2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_ANEG_LP_BASE_PAGE_TECH2(a,b) cavm_gsercx_lnx_aneg_lp_base_page_tech2_t
#define bustype_CAVM_GSERCX_LNX_ANEG_LP_BASE_PAGE_TECH2(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_ANEG_LP_BASE_PAGE_TECH2(a,b) "GSERCX_LNX_ANEG_LP_BASE_PAGE_TECH2"
#define device_bar_CAVM_GSERCX_LNX_ANEG_LP_BASE_PAGE_TECH2(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_ANEG_LP_BASE_PAGE_TECH2(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_ANEG_LP_BASE_PAGE_TECH2(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_lp_extended0
 *
 * GSERC Ln Aneg Lp Extended0 Register
 */
union cavm_gsercx_lnx_aneg_lp_extended0
{
    uint32_t u;
    struct cavm_gsercx_lnx_aneg_lp_extended0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t fc_fec_req            : 1;  /**< [  7:  7](R/W/H) Link partner extended advertised FEC field 3.  It requests Fire code FEC to be
                                                                 turned on when supported at the both ends of link for 25G/50G consortium
                                                                 specification non-IEEE.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t rs_fec_req            : 1;  /**< [  6:  6](R/W/H) Link partner extended advertised FEC field 2.  It requests Reed-Solomon FEC to
                                                                 be turned on when supported at the both ends of link for 25G/50G consortium
                                                                 specification non-IEEE.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t fc_fec_ability        : 1;  /**< [  5:  5](R/W/H) Link partner extended advertised FEC field 1.  It advertises Fire code FEC CL74
                                                                 ability for 25G/50G consortium specification non-IEEE.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t rs_fec_ability        : 1;  /**< [  4:  4](R/W/H) Link partner extended advertised FEC field 0.  It advertises Reed-Solomon FEC
                                                                 CL91 ability for 25G/50G consortium specification non-IEEE.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_50g_cr2       : 1;  /**< [  3:  3](R/W/H) Link partner 50GBase-CR2 technology advertised ability for 25G/50G consortium
                                                                 specification non-IEEE.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_50g_kr2       : 1;  /**< [  2:  2](R/W/H) Link partner 50GBase-KR2 technology advertised ability for 25G/50G consortium
                                                                 specification non-IEEE.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_25g_cr        : 1;  /**< [  1:  1](R/W/H) Link partner 25GBase-CR technology advertised ability for 25G/50G consortium
                                                                 specification non-IEEE.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_25g_kr        : 1;  /**< [  0:  0](R/W/H) Link partner 25GBase-KR technology advertised ability for 25G/50G consortium
                                                                 specification non-IEEE.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
#else /* Word 0 - Little Endian */
        uint32_t ability_25g_kr        : 1;  /**< [  0:  0](R/W/H) Link partner 25GBase-KR technology advertised ability for 25G/50G consortium
                                                                 specification non-IEEE.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_25g_cr        : 1;  /**< [  1:  1](R/W/H) Link partner 25GBase-CR technology advertised ability for 25G/50G consortium
                                                                 specification non-IEEE.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_50g_kr2       : 1;  /**< [  2:  2](R/W/H) Link partner 50GBase-KR2 technology advertised ability for 25G/50G consortium
                                                                 specification non-IEEE.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_50g_cr2       : 1;  /**< [  3:  3](R/W/H) Link partner 50GBase-CR2 technology advertised ability for 25G/50G consortium
                                                                 specification non-IEEE.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t rs_fec_ability        : 1;  /**< [  4:  4](R/W/H) Link partner extended advertised FEC field 0.  It advertises Reed-Solomon FEC
                                                                 CL91 ability for 25G/50G consortium specification non-IEEE.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t fc_fec_ability        : 1;  /**< [  5:  5](R/W/H) Link partner extended advertised FEC field 1.  It advertises Fire code FEC CL74
                                                                 ability for 25G/50G consortium specification non-IEEE.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t rs_fec_req            : 1;  /**< [  6:  6](R/W/H) Link partner extended advertised FEC field 2.  It requests Reed-Solomon FEC to
                                                                 be turned on when supported at the both ends of link for 25G/50G consortium
                                                                 specification non-IEEE.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t fc_fec_req            : 1;  /**< [  7:  7](R/W/H) Link partner extended advertised FEC field 3.  It requests Fire code FEC to be
                                                                 turned on when supported at the both ends of link for 25G/50G consortium
                                                                 specification non-IEEE.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_aneg_lp_extended0_s cn; */
};
typedef union cavm_gsercx_lnx_aneg_lp_extended0 cavm_gsercx_lnx_aneg_lp_extended0_t;

static inline uint64_t CAVM_GSERCX_LNX_ANEG_LP_EXTENDED0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_ANEG_LP_EXTENDED0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8010d78ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010d78ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_ANEG_LP_EXTENDED0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_ANEG_LP_EXTENDED0(a,b) cavm_gsercx_lnx_aneg_lp_extended0_t
#define bustype_CAVM_GSERCX_LNX_ANEG_LP_EXTENDED0(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_ANEG_LP_EXTENDED0(a,b) "GSERCX_LNX_ANEG_LP_EXTENDED0"
#define device_bar_CAVM_GSERCX_LNX_ANEG_LP_EXTENDED0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_ANEG_LP_EXTENDED0(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_ANEG_LP_EXTENDED0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_lp_np_data0
 *
 * GSERC Ln Aneg Lp Np Data0 Register
 */
union cavm_gsercx_lnx_aneg_lp_np_data0
{
    uint32_t u;
    struct cavm_gsercx_lnx_aneg_lp_np_data0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](RO/H) Link partner next page codeword bits 7-0. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](RO/H) Link partner next page codeword bits 7-0. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_aneg_lp_np_data0_s cn; */
};
typedef union cavm_gsercx_lnx_aneg_lp_np_data0 cavm_gsercx_lnx_aneg_lp_np_data0_t;

static inline uint64_t CAVM_GSERCX_LNX_ANEG_LP_NP_DATA0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_ANEG_LP_NP_DATA0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8010d80ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010d80ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_ANEG_LP_NP_DATA0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_ANEG_LP_NP_DATA0(a,b) cavm_gsercx_lnx_aneg_lp_np_data0_t
#define bustype_CAVM_GSERCX_LNX_ANEG_LP_NP_DATA0(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_ANEG_LP_NP_DATA0(a,b) "GSERCX_LNX_ANEG_LP_NP_DATA0"
#define device_bar_CAVM_GSERCX_LNX_ANEG_LP_NP_DATA0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_ANEG_LP_NP_DATA0(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_ANEG_LP_NP_DATA0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_lp_np_data1
 *
 * GSERC Ln Aneg Lp Np Data1 Register
 */
union cavm_gsercx_lnx_aneg_lp_np_data1
{
    uint32_t u;
    struct cavm_gsercx_lnx_aneg_lp_np_data1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t next_page             : 1;  /**< [  7:  7](RO/H) Link partner next page codeword field 'Next Page'. */
        uint32_t reserved_6            : 1;
        uint32_t msg_page              : 1;  /**< [  5:  5](RO/H) Link partner next page codeword field 'Massage Page'. */
        uint32_t ack2                  : 1;  /**< [  4:  4](RO/H) Link partner next page codeword field 'ACK2'. */
        uint32_t toggle                : 1;  /**< [  3:  3](RO/H) Link partner next page codeword field 'Toggle'. */
        uint32_t d10_d8                : 3;  /**< [  2:  0](RO/H) Link partner next page codeword bits 10-8. */
#else /* Word 0 - Little Endian */
        uint32_t d10_d8                : 3;  /**< [  2:  0](RO/H) Link partner next page codeword bits 10-8. */
        uint32_t toggle                : 1;  /**< [  3:  3](RO/H) Link partner next page codeword field 'Toggle'. */
        uint32_t ack2                  : 1;  /**< [  4:  4](RO/H) Link partner next page codeword field 'ACK2'. */
        uint32_t msg_page              : 1;  /**< [  5:  5](RO/H) Link partner next page codeword field 'Massage Page'. */
        uint32_t reserved_6            : 1;
        uint32_t next_page             : 1;  /**< [  7:  7](RO/H) Link partner next page codeword field 'Next Page'. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_aneg_lp_np_data1_s cn; */
};
typedef union cavm_gsercx_lnx_aneg_lp_np_data1 cavm_gsercx_lnx_aneg_lp_np_data1_t;

static inline uint64_t CAVM_GSERCX_LNX_ANEG_LP_NP_DATA1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_ANEG_LP_NP_DATA1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8010d88ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010d88ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_ANEG_LP_NP_DATA1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_ANEG_LP_NP_DATA1(a,b) cavm_gsercx_lnx_aneg_lp_np_data1_t
#define bustype_CAVM_GSERCX_LNX_ANEG_LP_NP_DATA1(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_ANEG_LP_NP_DATA1(a,b) "GSERCX_LNX_ANEG_LP_NP_DATA1"
#define device_bar_CAVM_GSERCX_LNX_ANEG_LP_NP_DATA1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_ANEG_LP_NP_DATA1(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_ANEG_LP_NP_DATA1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_lp_np_data2
 *
 * GSERC Ln Aneg Lp Np Data2 Register
 */
union cavm_gsercx_lnx_aneg_lp_np_data2
{
    uint32_t u;
    struct cavm_gsercx_lnx_aneg_lp_np_data2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](RO/H) Link partner next page codeword bits 23-16. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](RO/H) Link partner next page codeword bits 23-16. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_aneg_lp_np_data2_s cn; */
};
typedef union cavm_gsercx_lnx_aneg_lp_np_data2 cavm_gsercx_lnx_aneg_lp_np_data2_t;

static inline uint64_t CAVM_GSERCX_LNX_ANEG_LP_NP_DATA2(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_ANEG_LP_NP_DATA2(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8010d90ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010d90ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_ANEG_LP_NP_DATA2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_ANEG_LP_NP_DATA2(a,b) cavm_gsercx_lnx_aneg_lp_np_data2_t
#define bustype_CAVM_GSERCX_LNX_ANEG_LP_NP_DATA2(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_ANEG_LP_NP_DATA2(a,b) "GSERCX_LNX_ANEG_LP_NP_DATA2"
#define device_bar_CAVM_GSERCX_LNX_ANEG_LP_NP_DATA2(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_ANEG_LP_NP_DATA2(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_ANEG_LP_NP_DATA2(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_lp_np_data3
 *
 * GSERC Ln Aneg Lp Np Data3 Register
 */
union cavm_gsercx_lnx_aneg_lp_np_data3
{
    uint32_t u;
    struct cavm_gsercx_lnx_aneg_lp_np_data3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](RO/H) Link partner next page codeword bits 31-24. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](RO/H) Link partner next page codeword bits 31-24. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_aneg_lp_np_data3_s cn; */
};
typedef union cavm_gsercx_lnx_aneg_lp_np_data3 cavm_gsercx_lnx_aneg_lp_np_data3_t;

static inline uint64_t CAVM_GSERCX_LNX_ANEG_LP_NP_DATA3(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_ANEG_LP_NP_DATA3(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8010d98ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010d98ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_ANEG_LP_NP_DATA3", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_ANEG_LP_NP_DATA3(a,b) cavm_gsercx_lnx_aneg_lp_np_data3_t
#define bustype_CAVM_GSERCX_LNX_ANEG_LP_NP_DATA3(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_ANEG_LP_NP_DATA3(a,b) "GSERCX_LNX_ANEG_LP_NP_DATA3"
#define device_bar_CAVM_GSERCX_LNX_ANEG_LP_NP_DATA3(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_ANEG_LP_NP_DATA3(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_ANEG_LP_NP_DATA3(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_lp_np_data4
 *
 * GSERC Ln Aneg Lp Np Data4 Register
 */
union cavm_gsercx_lnx_aneg_lp_np_data4
{
    uint32_t u;
    struct cavm_gsercx_lnx_aneg_lp_np_data4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](RO/H) Link partner next page codeword  bits 39-32. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](RO/H) Link partner next page codeword  bits 39-32. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_aneg_lp_np_data4_s cn; */
};
typedef union cavm_gsercx_lnx_aneg_lp_np_data4 cavm_gsercx_lnx_aneg_lp_np_data4_t;

static inline uint64_t CAVM_GSERCX_LNX_ANEG_LP_NP_DATA4(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_ANEG_LP_NP_DATA4(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8010da0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010da0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_ANEG_LP_NP_DATA4", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_ANEG_LP_NP_DATA4(a,b) cavm_gsercx_lnx_aneg_lp_np_data4_t
#define bustype_CAVM_GSERCX_LNX_ANEG_LP_NP_DATA4(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_ANEG_LP_NP_DATA4(a,b) "GSERCX_LNX_ANEG_LP_NP_DATA4"
#define device_bar_CAVM_GSERCX_LNX_ANEG_LP_NP_DATA4(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_ANEG_LP_NP_DATA4(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_ANEG_LP_NP_DATA4(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_lp_np_data5
 *
 * GSERC Ln Aneg Lp Np Data5 Register
 */
union cavm_gsercx_lnx_aneg_lp_np_data5
{
    uint32_t u;
    struct cavm_gsercx_lnx_aneg_lp_np_data5_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](RO/H) Link partner next page codeword bits 47-40. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](RO/H) Link partner next page codeword bits 47-40. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_aneg_lp_np_data5_s cn; */
};
typedef union cavm_gsercx_lnx_aneg_lp_np_data5 cavm_gsercx_lnx_aneg_lp_np_data5_t;

static inline uint64_t CAVM_GSERCX_LNX_ANEG_LP_NP_DATA5(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_ANEG_LP_NP_DATA5(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8010da8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010da8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_ANEG_LP_NP_DATA5", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_ANEG_LP_NP_DATA5(a,b) cavm_gsercx_lnx_aneg_lp_np_data5_t
#define bustype_CAVM_GSERCX_LNX_ANEG_LP_NP_DATA5(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_ANEG_LP_NP_DATA5(a,b) "GSERCX_LNX_ANEG_LP_NP_DATA5"
#define device_bar_CAVM_GSERCX_LNX_ANEG_LP_NP_DATA5(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_ANEG_LP_NP_DATA5(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_ANEG_LP_NP_DATA5(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_resolution_eee
 *
 * GSERC Ln Aneg Resolution Eee Register
 */
union cavm_gsercx_lnx_aneg_resolution_eee
{
    uint32_t u;
    struct cavm_gsercx_lnx_aneg_resolution_eee_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Resolution result for EEE.  It is 1 if both the local device and the link
                                                                 partner advertise the EEE capability for the resolved PHY type.  It is 0
                                                                 otherwise.  It is valid when status0.an_link_good is 1.
                                                                 Note that it indicates EEE deep sleep capability. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Resolution result for EEE.  It is 1 if both the local device and the link
                                                                 partner advertise the EEE capability for the resolved PHY type.  It is 0
                                                                 otherwise.  It is valid when status0.an_link_good is 1.
                                                                 Note that it indicates EEE deep sleep capability. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_aneg_resolution_eee_s cn; */
};
typedef union cavm_gsercx_lnx_aneg_resolution_eee cavm_gsercx_lnx_aneg_resolution_eee_t;

static inline uint64_t CAVM_GSERCX_LNX_ANEG_RESOLUTION_EEE(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_ANEG_RESOLUTION_EEE(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8010de0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010de0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_ANEG_RESOLUTION_EEE", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_ANEG_RESOLUTION_EEE(a,b) cavm_gsercx_lnx_aneg_resolution_eee_t
#define bustype_CAVM_GSERCX_LNX_ANEG_RESOLUTION_EEE(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_ANEG_RESOLUTION_EEE(a,b) "GSERCX_LNX_ANEG_RESOLUTION_EEE"
#define device_bar_CAVM_GSERCX_LNX_ANEG_RESOLUTION_EEE(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_ANEG_RESOLUTION_EEE(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_ANEG_RESOLUTION_EEE(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_resolution_fec
 *
 * GSERC Ln Aneg Resolution Fec Register
 */
union cavm_gsercx_lnx_aneg_resolution_fec
{
    uint32_t u;
    struct cavm_gsercx_lnx_aneg_resolution_fec_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t fc                    : 1;  /**< [  1:  1](R/W/H) Resolution result for Firecode base page FEC.  It is valid when status0.an_link_good is 1. */
        uint32_t rs                    : 1;  /**< [  0:  0](R/W/H) Resolution result for Reed-Solomon FEC.  It is valid when status0.an_link_good is 1. */
#else /* Word 0 - Little Endian */
        uint32_t rs                    : 1;  /**< [  0:  0](R/W/H) Resolution result for Reed-Solomon FEC.  It is valid when status0.an_link_good is 1. */
        uint32_t fc                    : 1;  /**< [  1:  1](R/W/H) Resolution result for Firecode base page FEC.  It is valid when status0.an_link_good is 1. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_aneg_resolution_fec_s cn; */
};
typedef union cavm_gsercx_lnx_aneg_resolution_fec cavm_gsercx_lnx_aneg_resolution_fec_t;

static inline uint64_t CAVM_GSERCX_LNX_ANEG_RESOLUTION_FEC(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_ANEG_RESOLUTION_FEC(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8010dd0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010dd0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_ANEG_RESOLUTION_FEC", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_ANEG_RESOLUTION_FEC(a,b) cavm_gsercx_lnx_aneg_resolution_fec_t
#define bustype_CAVM_GSERCX_LNX_ANEG_RESOLUTION_FEC(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_ANEG_RESOLUTION_FEC(a,b) "GSERCX_LNX_ANEG_RESOLUTION_FEC"
#define device_bar_CAVM_GSERCX_LNX_ANEG_RESOLUTION_FEC(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_ANEG_RESOLUTION_FEC(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_ANEG_RESOLUTION_FEC(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_resolution_pause
 *
 * GSERC Ln Aneg Resolution Pause Register
 */
union cavm_gsercx_lnx_aneg_resolution_pause
{
    uint32_t u;
    struct cavm_gsercx_lnx_aneg_resolution_pause_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t tx                    : 1;  /**< [  1:  1](RO/H) Resolution result for TX PAUSE enable.    It is valid when status0.an_link_good is 1. */
        uint32_t rx                    : 1;  /**< [  0:  0](RO/H) Resolution result for RX PAUSE enable.    It is valid when status0.an_link_good is 1. */
#else /* Word 0 - Little Endian */
        uint32_t rx                    : 1;  /**< [  0:  0](RO/H) Resolution result for RX PAUSE enable.    It is valid when status0.an_link_good is 1. */
        uint32_t tx                    : 1;  /**< [  1:  1](RO/H) Resolution result for TX PAUSE enable.    It is valid when status0.an_link_good is 1. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_aneg_resolution_pause_s cn; */
};
typedef union cavm_gsercx_lnx_aneg_resolution_pause cavm_gsercx_lnx_aneg_resolution_pause_t;

static inline uint64_t CAVM_GSERCX_LNX_ANEG_RESOLUTION_PAUSE(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_ANEG_RESOLUTION_PAUSE(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8010dd8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010dd8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_ANEG_RESOLUTION_PAUSE", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_ANEG_RESOLUTION_PAUSE(a,b) cavm_gsercx_lnx_aneg_resolution_pause_t
#define bustype_CAVM_GSERCX_LNX_ANEG_RESOLUTION_PAUSE(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_ANEG_RESOLUTION_PAUSE(a,b) "GSERCX_LNX_ANEG_RESOLUTION_PAUSE"
#define device_bar_CAVM_GSERCX_LNX_ANEG_RESOLUTION_PAUSE(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_ANEG_RESOLUTION_PAUSE(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_ANEG_RESOLUTION_PAUSE(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_resolution_tech0
 *
 * GSERC Ln Aneg Resolution Tech0 Register
 */
union cavm_gsercx_lnx_aneg_resolution_tech0
{
    uint32_t u;
    struct cavm_gsercx_lnx_aneg_resolution_tech0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t ability_100g_kr4      : 1;  /**< [  7:  7](R/W/H) Resolution result for 100GBase-KR4.  It is valid when status0.an_link_good is 1.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_100g_kp4      : 1;  /**< [  6:  6](R/W/H) Resolution result for 100GBase-KP4.  It is valid when status0.an_link_good is 1.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_100g_cr10     : 1;  /**< [  5:  5](R/W/H) Resolution result for 100GBase-CR10.  It is valid when status0.an_link_good is 1.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_40g_cr4       : 1;  /**< [  4:  4](R/W/H) Resolution result for 40GBase-CR4.  It is valid when status0.an_link_good is 1.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_40g_kr4       : 1;  /**< [  3:  3](R/W/H) Resolution result for 40GBase-KR4.  It is valid when status0.an_link_good is 1.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_10g_kr        : 1;  /**< [  2:  2](R/W/H) Resolution result for 10GBase-KR.  It is valid when status0.an_link_good is 1.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_10g_kx4       : 1;  /**< [  1:  1](R/W/H) Resolution result for 10GBase-KX4.  It is valid when status0.an_link_good is 1.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_1g_kx         : 1;  /**< [  0:  0](R/W/H) Resolution result for 1000Base-KX.  It is valid when status0.an_link_good is 1.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
#else /* Word 0 - Little Endian */
        uint32_t ability_1g_kx         : 1;  /**< [  0:  0](R/W/H) Resolution result for 1000Base-KX.  It is valid when status0.an_link_good is 1.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_10g_kx4       : 1;  /**< [  1:  1](R/W/H) Resolution result for 10GBase-KX4.  It is valid when status0.an_link_good is 1.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_10g_kr        : 1;  /**< [  2:  2](R/W/H) Resolution result for 10GBase-KR.  It is valid when status0.an_link_good is 1.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_40g_kr4       : 1;  /**< [  3:  3](R/W/H) Resolution result for 40GBase-KR4.  It is valid when status0.an_link_good is 1.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_40g_cr4       : 1;  /**< [  4:  4](R/W/H) Resolution result for 40GBase-CR4.  It is valid when status0.an_link_good is 1.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_100g_cr10     : 1;  /**< [  5:  5](R/W/H) Resolution result for 100GBase-CR10.  It is valid when status0.an_link_good is 1.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_100g_kp4      : 1;  /**< [  6:  6](R/W/H) Resolution result for 100GBase-KP4.  It is valid when status0.an_link_good is 1.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_100g_kr4      : 1;  /**< [  7:  7](R/W/H) Resolution result for 100GBase-KR4.  It is valid when status0.an_link_good is 1.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_aneg_resolution_tech0_s cn; */
};
typedef union cavm_gsercx_lnx_aneg_resolution_tech0 cavm_gsercx_lnx_aneg_resolution_tech0_t;

static inline uint64_t CAVM_GSERCX_LNX_ANEG_RESOLUTION_TECH0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_ANEG_RESOLUTION_TECH0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8010dc0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010dc0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_ANEG_RESOLUTION_TECH0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_ANEG_RESOLUTION_TECH0(a,b) cavm_gsercx_lnx_aneg_resolution_tech0_t
#define bustype_CAVM_GSERCX_LNX_ANEG_RESOLUTION_TECH0(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_ANEG_RESOLUTION_TECH0(a,b) "GSERCX_LNX_ANEG_RESOLUTION_TECH0"
#define device_bar_CAVM_GSERCX_LNX_ANEG_RESOLUTION_TECH0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_ANEG_RESOLUTION_TECH0(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_ANEG_RESOLUTION_TECH0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_resolution_tech1
 *
 * GSERC Ln Aneg Resolution Tech1 Register
 */
union cavm_gsercx_lnx_aneg_resolution_tech1
{
    uint32_t u;
    struct cavm_gsercx_lnx_aneg_resolution_tech1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t ability_50g_cr2       : 1;  /**< [  6:  6](R/W/H) Resolution result for 50GBase-CR2.  It is valid when status0.an_link_good is 1. */
        uint32_t ability_50g_kr2       : 1;  /**< [  5:  5](R/W/H) Resolution result for 50GBase-KR2.  It is valid when status0.an_link_good is 1.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_25g_cr        : 1;  /**< [  4:  4](R/W/H) Resolution result for 25GBase-CR4.  It is valid when status0.an_link_good is 1.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_25g_kr        : 1;  /**< [  3:  3](R/W/H) Resolution result for 25GBase-KR.  It is valid when status0.an_link_good is 1.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_25g_gr        : 1;  /**< [  2:  2](R/W/H) Resolution result for 25GBase-GR KR or CR.  It is valid when status0.an_link_good is 1.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_25g_gr_s      : 1;  /**< [  1:  1](R/W/H) Resolution result for 25GBase-GR-S KR or CR.  It is valid when status0.an_link_good is 1.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_100g_cr4      : 1;  /**< [  0:  0](R/W/H) Resolution result for 100GBase-CR4.  It is valid when status0.an_link_good is 1.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
#else /* Word 0 - Little Endian */
        uint32_t ability_100g_cr4      : 1;  /**< [  0:  0](R/W/H) Resolution result for 100GBase-CR4.  It is valid when status0.an_link_good is 1.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_25g_gr_s      : 1;  /**< [  1:  1](R/W/H) Resolution result for 25GBase-GR-S KR or CR.  It is valid when status0.an_link_good is 1.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_25g_gr        : 1;  /**< [  2:  2](R/W/H) Resolution result for 25GBase-GR KR or CR.  It is valid when status0.an_link_good is 1.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_25g_kr        : 1;  /**< [  3:  3](R/W/H) Resolution result for 25GBase-KR.  It is valid when status0.an_link_good is 1.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_25g_cr        : 1;  /**< [  4:  4](R/W/H) Resolution result for 25GBase-CR4.  It is valid when status0.an_link_good is 1.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_50g_kr2       : 1;  /**< [  5:  5](R/W/H) Resolution result for 50GBase-KR2.  It is valid when status0.an_link_good is 1.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_50g_cr2       : 1;  /**< [  6:  6](R/W/H) Resolution result for 50GBase-CR2.  It is valid when status0.an_link_good is 1. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_aneg_resolution_tech1_s cn; */
};
typedef union cavm_gsercx_lnx_aneg_resolution_tech1 cavm_gsercx_lnx_aneg_resolution_tech1_t;

static inline uint64_t CAVM_GSERCX_LNX_ANEG_RESOLUTION_TECH1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_ANEG_RESOLUTION_TECH1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8010dc8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010dc8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_ANEG_RESOLUTION_TECH1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_ANEG_RESOLUTION_TECH1(a,b) cavm_gsercx_lnx_aneg_resolution_tech1_t
#define bustype_CAVM_GSERCX_LNX_ANEG_RESOLUTION_TECH1(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_ANEG_RESOLUTION_TECH1(a,b) "GSERCX_LNX_ANEG_RESOLUTION_TECH1"
#define device_bar_CAVM_GSERCX_LNX_ANEG_RESOLUTION_TECH1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_ANEG_RESOLUTION_TECH1(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_ANEG_RESOLUTION_TECH1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_status0
 *
 * GSERC Ln Aneg Status0 Register
 */
union cavm_gsercx_lnx_aneg_status0
{
    uint32_t u;
    struct cavm_gsercx_lnx_aneg_status0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t autoneg_complete      : 1;  /**< [  5:  5](RO/H) Autoneg has completed and autoneg arbitration FSM is in AN GOOD state. */
        uint32_t autoneg_remote_fault  : 1;  /**< [  4:  4](RO/H) Remote Fault. */
        uint32_t autoneg_ability       : 1;  /**< [  3:  3](RO/H) Autoneg ability.  When read as a one, it indicates that the PMA/PMD has the
                                                                 ability to perform Auto-Negotiation.  When read as a zero, it indicates that the
                                                                 PMA/PMD lacks the ability to perform Auto-Negotiation. */
        uint32_t link_status           : 1;  /**< [  2:  2](RO/H) Local link Status.  When read as a one, it indicates that the PMA/PMD has
                                                                 determined that a valid link has been established i.e. link_status[HDC] equals
                                                                 OK. When read as a zero, it indicates that the link is not valid. */
        uint32_t reserved_1            : 1;
        uint32_t lp_autoneg_able       : 1;  /**< [  0:  0](RO/H) The link partner Auto-Negotiation ability bit shall be set to one to indicate
                                                                 that the link partner is able to
                                                                 participate in the Auto-Negotiation function. This bit shall be reset to zero if
                                                                 the link partner is not Auto-
                                                                 Negotiation able. */
#else /* Word 0 - Little Endian */
        uint32_t lp_autoneg_able       : 1;  /**< [  0:  0](RO/H) The link partner Auto-Negotiation ability bit shall be set to one to indicate
                                                                 that the link partner is able to
                                                                 participate in the Auto-Negotiation function. This bit shall be reset to zero if
                                                                 the link partner is not Auto-
                                                                 Negotiation able. */
        uint32_t reserved_1            : 1;
        uint32_t link_status           : 1;  /**< [  2:  2](RO/H) Local link Status.  When read as a one, it indicates that the PMA/PMD has
                                                                 determined that a valid link has been established i.e. link_status[HDC] equals
                                                                 OK. When read as a zero, it indicates that the link is not valid. */
        uint32_t autoneg_ability       : 1;  /**< [  3:  3](RO/H) Autoneg ability.  When read as a one, it indicates that the PMA/PMD has the
                                                                 ability to perform Auto-Negotiation.  When read as a zero, it indicates that the
                                                                 PMA/PMD lacks the ability to perform Auto-Negotiation. */
        uint32_t autoneg_remote_fault  : 1;  /**< [  4:  4](RO/H) Remote Fault. */
        uint32_t autoneg_complete      : 1;  /**< [  5:  5](RO/H) Autoneg has completed and autoneg arbitration FSM is in AN GOOD state. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_aneg_status0_s cn; */
};
typedef union cavm_gsercx_lnx_aneg_status0 cavm_gsercx_lnx_aneg_status0_t;

static inline uint64_t CAVM_GSERCX_LNX_ANEG_STATUS0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_ANEG_STATUS0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8010c80ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010c80ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_ANEG_STATUS0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_ANEG_STATUS0(a,b) cavm_gsercx_lnx_aneg_status0_t
#define bustype_CAVM_GSERCX_LNX_ANEG_STATUS0(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_ANEG_STATUS0(a,b) "GSERCX_LNX_ANEG_STATUS0"
#define device_bar_CAVM_GSERCX_LNX_ANEG_STATUS0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_ANEG_STATUS0(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_ANEG_STATUS0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_status1
 *
 * GSERC Ln Aneg Status1 Register
 */
union cavm_gsercx_lnx_aneg_status1
{
    uint32_t u;
    struct cavm_gsercx_lnx_aneg_status1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t resolve_handshake     : 1;  /**< [  5:  5](R/W1C/H) Reserved. */
        uint32_t init_handshake        : 1;  /**< [  4:  4](R/W1C/H) Reserved. */
        uint32_t np_loaded             : 1;  /**< [  3:  3](RO/H) MR_NP_LOADED status. */
        uint32_t parallel_det_fault    : 1;  /**< [  2:  2](R/W1C/H) Autoneg Parallel Detection Fault.  Write 1 to clear it. */
        uint32_t an_link_good          : 1;  /**< [  1:  1](RO/H) Autoneg has completed and autoneg arbitration FSM is in either AN GOOD CHECK or AN GOOD state. */
        uint32_t page_rx               : 1;  /**< [  0:  0](R/W1C/H) Page Received.   To clear it, write 1 to it.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
#else /* Word 0 - Little Endian */
        uint32_t page_rx               : 1;  /**< [  0:  0](R/W1C/H) Page Received.   To clear it, write 1 to it.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t an_link_good          : 1;  /**< [  1:  1](RO/H) Autoneg has completed and autoneg arbitration FSM is in either AN GOOD CHECK or AN GOOD state. */
        uint32_t parallel_det_fault    : 1;  /**< [  2:  2](R/W1C/H) Autoneg Parallel Detection Fault.  Write 1 to clear it. */
        uint32_t np_loaded             : 1;  /**< [  3:  3](RO/H) MR_NP_LOADED status. */
        uint32_t init_handshake        : 1;  /**< [  4:  4](R/W1C/H) Reserved. */
        uint32_t resolve_handshake     : 1;  /**< [  5:  5](R/W1C/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_aneg_status1_s cn; */
};
typedef union cavm_gsercx_lnx_aneg_status1 cavm_gsercx_lnx_aneg_status1_t;

static inline uint64_t CAVM_GSERCX_LNX_ANEG_STATUS1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_ANEG_STATUS1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8010c88ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010c88ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_ANEG_STATUS1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_ANEG_STATUS1(a,b) cavm_gsercx_lnx_aneg_status1_t
#define bustype_CAVM_GSERCX_LNX_ANEG_STATUS1(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_ANEG_STATUS1(a,b) "GSERCX_LNX_ANEG_STATUS1"
#define device_bar_CAVM_GSERCX_LNX_ANEG_STATUS1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_ANEG_STATUS1(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_ANEG_STATUS1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_status_dbg0
 *
 * GSERC Ln Aneg Status Dbg0 Register
 */
union cavm_gsercx_lnx_aneg_status_dbg0
{
    uint32_t u;
    struct cavm_gsercx_lnx_aneg_status_dbg0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t state_one_hot_sticky_7_0 : 8;/**< [  7:  0](RO/H) One-hot sticky capture of AN FSM states.  Bits 7-0. */
#else /* Word 0 - Little Endian */
        uint32_t state_one_hot_sticky_7_0 : 8;/**< [  7:  0](RO/H) One-hot sticky capture of AN FSM states.  Bits 7-0. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_aneg_status_dbg0_s cn; */
};
typedef union cavm_gsercx_lnx_aneg_status_dbg0 cavm_gsercx_lnx_aneg_status_dbg0_t;

static inline uint64_t CAVM_GSERCX_LNX_ANEG_STATUS_DBG0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_ANEG_STATUS_DBG0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8010ca0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010ca0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_ANEG_STATUS_DBG0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_ANEG_STATUS_DBG0(a,b) cavm_gsercx_lnx_aneg_status_dbg0_t
#define bustype_CAVM_GSERCX_LNX_ANEG_STATUS_DBG0(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_ANEG_STATUS_DBG0(a,b) "GSERCX_LNX_ANEG_STATUS_DBG0"
#define device_bar_CAVM_GSERCX_LNX_ANEG_STATUS_DBG0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_ANEG_STATUS_DBG0(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_ANEG_STATUS_DBG0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_status_dbg1
 *
 * GSERC Ln Aneg Status Dbg1 Register
 */
union cavm_gsercx_lnx_aneg_status_dbg1
{
    uint32_t u;
    struct cavm_gsercx_lnx_aneg_status_dbg1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t state_one_hot_sticky_15_8 : 8;/**< [  7:  0](RO/H) One-hot sticky capture of AN FSM states.  Bits 15-8. */
#else /* Word 0 - Little Endian */
        uint32_t state_one_hot_sticky_15_8 : 8;/**< [  7:  0](RO/H) One-hot sticky capture of AN FSM states.  Bits 15-8. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_aneg_status_dbg1_s cn; */
};
typedef union cavm_gsercx_lnx_aneg_status_dbg1 cavm_gsercx_lnx_aneg_status_dbg1_t;

static inline uint64_t CAVM_GSERCX_LNX_ANEG_STATUS_DBG1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_ANEG_STATUS_DBG1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8010ca8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010ca8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_ANEG_STATUS_DBG1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_ANEG_STATUS_DBG1(a,b) cavm_gsercx_lnx_aneg_status_dbg1_t
#define bustype_CAVM_GSERCX_LNX_ANEG_STATUS_DBG1(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_ANEG_STATUS_DBG1(a,b) "GSERCX_LNX_ANEG_STATUS_DBG1"
#define device_bar_CAVM_GSERCX_LNX_ANEG_STATUS_DBG1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_ANEG_STATUS_DBG1(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_ANEG_STATUS_DBG1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_ber_status0
 *
 * GSERC Ln Bist Rx Ber Status0 Register
 */
union cavm_gsercx_lnx_bist_rx_ber_status0
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_rx_ber_status0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t bit_error_count_7_0   : 8;  /**< [  7:  0](RO/H) Number of bit errors. */
#else /* Word 0 - Little Endian */
        uint32_t bit_error_count_7_0   : 8;  /**< [  7:  0](RO/H) Number of bit errors. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_rx_ber_status0_s cn; */
};
typedef union cavm_gsercx_lnx_bist_rx_ber_status0 cavm_gsercx_lnx_bist_rx_ber_status0_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_BER_STATUS0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_BER_STATUS0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013040ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013040ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_RX_BER_STATUS0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_RX_BER_STATUS0(a,b) cavm_gsercx_lnx_bist_rx_ber_status0_t
#define bustype_CAVM_GSERCX_LNX_BIST_RX_BER_STATUS0(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_RX_BER_STATUS0(a,b) "GSERCX_LNX_BIST_RX_BER_STATUS0"
#define device_bar_CAVM_GSERCX_LNX_BIST_RX_BER_STATUS0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_RX_BER_STATUS0(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_RX_BER_STATUS0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_ber_status1
 *
 * GSERC Ln Bist Rx Ber Status1 Register
 */
union cavm_gsercx_lnx_bist_rx_ber_status1
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_rx_ber_status1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t bit_error_count_15_8  : 8;  /**< [  7:  0](RO/H) Number of bit errors. */
#else /* Word 0 - Little Endian */
        uint32_t bit_error_count_15_8  : 8;  /**< [  7:  0](RO/H) Number of bit errors. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_rx_ber_status1_s cn; */
};
typedef union cavm_gsercx_lnx_bist_rx_ber_status1 cavm_gsercx_lnx_bist_rx_ber_status1_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_BER_STATUS1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_BER_STATUS1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013048ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013048ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_RX_BER_STATUS1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_RX_BER_STATUS1(a,b) cavm_gsercx_lnx_bist_rx_ber_status1_t
#define bustype_CAVM_GSERCX_LNX_BIST_RX_BER_STATUS1(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_RX_BER_STATUS1(a,b) "GSERCX_LNX_BIST_RX_BER_STATUS1"
#define device_bar_CAVM_GSERCX_LNX_BIST_RX_BER_STATUS1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_RX_BER_STATUS1(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_RX_BER_STATUS1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_ber_status2
 *
 * GSERC Ln Bist Rx Ber Status2 Register
 */
union cavm_gsercx_lnx_bist_rx_ber_status2
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_rx_ber_status2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t bit_error_count_23_16 : 8;  /**< [  7:  0](RO/H) Number of bit errors. */
#else /* Word 0 - Little Endian */
        uint32_t bit_error_count_23_16 : 8;  /**< [  7:  0](RO/H) Number of bit errors. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_rx_ber_status2_s cn; */
};
typedef union cavm_gsercx_lnx_bist_rx_ber_status2 cavm_gsercx_lnx_bist_rx_ber_status2_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_BER_STATUS2(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_BER_STATUS2(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013050ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013050ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_RX_BER_STATUS2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_RX_BER_STATUS2(a,b) cavm_gsercx_lnx_bist_rx_ber_status2_t
#define bustype_CAVM_GSERCX_LNX_BIST_RX_BER_STATUS2(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_RX_BER_STATUS2(a,b) "GSERCX_LNX_BIST_RX_BER_STATUS2"
#define device_bar_CAVM_GSERCX_LNX_BIST_RX_BER_STATUS2(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_RX_BER_STATUS2(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_RX_BER_STATUS2(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_ber_status4
 *
 * GSERC Ln Bist Rx Ber Status4 Register
 */
union cavm_gsercx_lnx_bist_rx_ber_status4
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_rx_ber_status4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t cycle_count_7_0       : 8;  /**< [  7:  0](RO/H) Number of cycles that errors have been counted. */
#else /* Word 0 - Little Endian */
        uint32_t cycle_count_7_0       : 8;  /**< [  7:  0](RO/H) Number of cycles that errors have been counted. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_rx_ber_status4_s cn; */
};
typedef union cavm_gsercx_lnx_bist_rx_ber_status4 cavm_gsercx_lnx_bist_rx_ber_status4_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_BER_STATUS4(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_BER_STATUS4(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013060ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013060ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_RX_BER_STATUS4", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_RX_BER_STATUS4(a,b) cavm_gsercx_lnx_bist_rx_ber_status4_t
#define bustype_CAVM_GSERCX_LNX_BIST_RX_BER_STATUS4(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_RX_BER_STATUS4(a,b) "GSERCX_LNX_BIST_RX_BER_STATUS4"
#define device_bar_CAVM_GSERCX_LNX_BIST_RX_BER_STATUS4(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_RX_BER_STATUS4(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_RX_BER_STATUS4(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_ber_status5
 *
 * GSERC Ln Bist Rx Ber Status5 Register
 */
union cavm_gsercx_lnx_bist_rx_ber_status5
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_rx_ber_status5_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t cycle_count_15_8      : 8;  /**< [  7:  0](RO/H) Number of cycles that errors have been counted. */
#else /* Word 0 - Little Endian */
        uint32_t cycle_count_15_8      : 8;  /**< [  7:  0](RO/H) Number of cycles that errors have been counted. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_rx_ber_status5_s cn; */
};
typedef union cavm_gsercx_lnx_bist_rx_ber_status5 cavm_gsercx_lnx_bist_rx_ber_status5_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_BER_STATUS5(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_BER_STATUS5(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013068ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013068ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_RX_BER_STATUS5", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_RX_BER_STATUS5(a,b) cavm_gsercx_lnx_bist_rx_ber_status5_t
#define bustype_CAVM_GSERCX_LNX_BIST_RX_BER_STATUS5(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_RX_BER_STATUS5(a,b) "GSERCX_LNX_BIST_RX_BER_STATUS5"
#define device_bar_CAVM_GSERCX_LNX_BIST_RX_BER_STATUS5(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_RX_BER_STATUS5(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_RX_BER_STATUS5(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_ber_status6
 *
 * GSERC Ln Bist Rx Ber Status6 Register
 */
union cavm_gsercx_lnx_bist_rx_ber_status6
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_rx_ber_status6_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t cycle_count_23_16     : 8;  /**< [  7:  0](RO/H) Number of cycles that errors have been counted. */
#else /* Word 0 - Little Endian */
        uint32_t cycle_count_23_16     : 8;  /**< [  7:  0](RO/H) Number of cycles that errors have been counted. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_rx_ber_status6_s cn; */
};
typedef union cavm_gsercx_lnx_bist_rx_ber_status6 cavm_gsercx_lnx_bist_rx_ber_status6_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_BER_STATUS6(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_BER_STATUS6(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013070ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013070ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_RX_BER_STATUS6", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_RX_BER_STATUS6(a,b) cavm_gsercx_lnx_bist_rx_ber_status6_t
#define bustype_CAVM_GSERCX_LNX_BIST_RX_BER_STATUS6(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_RX_BER_STATUS6(a,b) "GSERCX_LNX_BIST_RX_BER_STATUS6"
#define device_bar_CAVM_GSERCX_LNX_BIST_RX_BER_STATUS6(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_RX_BER_STATUS6(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_RX_BER_STATUS6(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_ctrl
 *
 * GSERC Ln Bist Rx Ctrl Register
 */
union cavm_gsercx_lnx_bist_rx_ctrl
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_rx_ctrl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t force_lfsr_with_rxdata : 1; /**< [  7:  7](R/W/H) Forces the PRBS LFSR to reseed with Rx data every cycle.  This will cause the
                                                                 bit error counter to be inaccurate. */
        uint32_t stop_error_count      : 1;  /**< [  6:  6](R/W/H) Stops the error count from incrementing.  Can be used to read back the BER data coherently. */
        uint32_t clear_ber             : 1;  /**< [  5:  5](R/W/H) Clears the bit error counter. */
        uint32_t pattern_sel           : 4;  /**< [  4:  1](R/W/H) Selects the pattern to search for:
                                                                 0x1 = PRBS 0xC1
                                                                 0x2 = PRBS 0x221
                                                                 0x3 = PRBS 0xA01
                                                                 0x4 = PRBS 0xC001
                                                                 0x5 = PRBS 0x840001
                                                                 0x6 = PRBS 0x90000001
                                                                 0x7 = User defined pattern UDP
                                                                 0x8 = Auto-detect */
        uint32_t en                    : 1;  /**< [  0:  0](R/W/H) Enables BIST Rx data checking. */
#else /* Word 0 - Little Endian */
        uint32_t en                    : 1;  /**< [  0:  0](R/W/H) Enables BIST Rx data checking. */
        uint32_t pattern_sel           : 4;  /**< [  4:  1](R/W/H) Selects the pattern to search for:
                                                                 0x1 = PRBS 0xC1
                                                                 0x2 = PRBS 0x221
                                                                 0x3 = PRBS 0xA01
                                                                 0x4 = PRBS 0xC001
                                                                 0x5 = PRBS 0x840001
                                                                 0x6 = PRBS 0x90000001
                                                                 0x7 = User defined pattern UDP
                                                                 0x8 = Auto-detect */
        uint32_t clear_ber             : 1;  /**< [  5:  5](R/W/H) Clears the bit error counter. */
        uint32_t stop_error_count      : 1;  /**< [  6:  6](R/W/H) Stops the error count from incrementing.  Can be used to read back the BER data coherently. */
        uint32_t force_lfsr_with_rxdata : 1; /**< [  7:  7](R/W/H) Forces the PRBS LFSR to reseed with Rx data every cycle.  This will cause the
                                                                 bit error counter to be inaccurate. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_rx_ctrl_s cn; */
};
typedef union cavm_gsercx_lnx_bist_rx_ctrl cavm_gsercx_lnx_bist_rx_ctrl_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_CTRL(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_CTRL(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013000ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013000ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_RX_CTRL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_RX_CTRL(a,b) cavm_gsercx_lnx_bist_rx_ctrl_t
#define bustype_CAVM_GSERCX_LNX_BIST_RX_CTRL(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_RX_CTRL(a,b) "GSERCX_LNX_BIST_RX_CTRL"
#define device_bar_CAVM_GSERCX_LNX_BIST_RX_CTRL(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_RX_CTRL(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_RX_CTRL(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_lock_ctrl0
 *
 * GSERC Ln Bist Rx Lock Ctrl0 Register
 */
union cavm_gsercx_lnx_bist_rx_lock_ctrl0
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_rx_lock_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t num_cycles_7_0        : 8;  /**< [  7:  0](R/W/H) Size of error sampling window to trigger pattern lock. */
#else /* Word 0 - Little Endian */
        uint32_t num_cycles_7_0        : 8;  /**< [  7:  0](R/W/H) Size of error sampling window to trigger pattern lock. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_rx_lock_ctrl0_s cn; */
};
typedef union cavm_gsercx_lnx_bist_rx_lock_ctrl0 cavm_gsercx_lnx_bist_rx_lock_ctrl0_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_LOCK_CTRL0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_LOCK_CTRL0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a80130a0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80130a0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_RX_LOCK_CTRL0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_RX_LOCK_CTRL0(a,b) cavm_gsercx_lnx_bist_rx_lock_ctrl0_t
#define bustype_CAVM_GSERCX_LNX_BIST_RX_LOCK_CTRL0(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_RX_LOCK_CTRL0(a,b) "GSERCX_LNX_BIST_RX_LOCK_CTRL0"
#define device_bar_CAVM_GSERCX_LNX_BIST_RX_LOCK_CTRL0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_RX_LOCK_CTRL0(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_RX_LOCK_CTRL0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_lock_ctrl1
 *
 * GSERC Ln Bist Rx Lock Ctrl1 Register
 */
union cavm_gsercx_lnx_bist_rx_lock_ctrl1
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_rx_lock_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t num_cycles_15_8       : 8;  /**< [  7:  0](R/W/H) Size of error sampling window to trigger pattern lock. */
#else /* Word 0 - Little Endian */
        uint32_t num_cycles_15_8       : 8;  /**< [  7:  0](R/W/H) Size of error sampling window to trigger pattern lock. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_rx_lock_ctrl1_s cn; */
};
typedef union cavm_gsercx_lnx_bist_rx_lock_ctrl1 cavm_gsercx_lnx_bist_rx_lock_ctrl1_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_LOCK_CTRL1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_LOCK_CTRL1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a80130a8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80130a8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_RX_LOCK_CTRL1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_RX_LOCK_CTRL1(a,b) cavm_gsercx_lnx_bist_rx_lock_ctrl1_t
#define bustype_CAVM_GSERCX_LNX_BIST_RX_LOCK_CTRL1(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_RX_LOCK_CTRL1(a,b) "GSERCX_LNX_BIST_RX_LOCK_CTRL1"
#define device_bar_CAVM_GSERCX_LNX_BIST_RX_LOCK_CTRL1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_RX_LOCK_CTRL1(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_RX_LOCK_CTRL1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_lock_ctrl2
 *
 * GSERC Ln Bist Rx Lock Ctrl2 Register
 */
union cavm_gsercx_lnx_bist_rx_lock_ctrl2
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_rx_lock_ctrl2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t max_errors_7_0        : 8;  /**< [  7:  0](R/W/H) Maximum number of errors allowed to trigger pattern lock. */
#else /* Word 0 - Little Endian */
        uint32_t max_errors_7_0        : 8;  /**< [  7:  0](R/W/H) Maximum number of errors allowed to trigger pattern lock. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_rx_lock_ctrl2_s cn; */
};
typedef union cavm_gsercx_lnx_bist_rx_lock_ctrl2 cavm_gsercx_lnx_bist_rx_lock_ctrl2_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_LOCK_CTRL2(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_LOCK_CTRL2(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a80130b0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80130b0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_RX_LOCK_CTRL2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_RX_LOCK_CTRL2(a,b) cavm_gsercx_lnx_bist_rx_lock_ctrl2_t
#define bustype_CAVM_GSERCX_LNX_BIST_RX_LOCK_CTRL2(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_RX_LOCK_CTRL2(a,b) "GSERCX_LNX_BIST_RX_LOCK_CTRL2"
#define device_bar_CAVM_GSERCX_LNX_BIST_RX_LOCK_CTRL2(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_RX_LOCK_CTRL2(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_RX_LOCK_CTRL2(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_lock_ctrl3
 *
 * GSERC Ln Bist Rx Lock Ctrl3 Register
 */
union cavm_gsercx_lnx_bist_rx_lock_ctrl3
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_rx_lock_ctrl3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t max_errors_15_8       : 8;  /**< [  7:  0](R/W/H) Maximum number of errors allowed to trigger pattern lock. */
#else /* Word 0 - Little Endian */
        uint32_t max_errors_15_8       : 8;  /**< [  7:  0](R/W/H) Maximum number of errors allowed to trigger pattern lock. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_rx_lock_ctrl3_s cn; */
};
typedef union cavm_gsercx_lnx_bist_rx_lock_ctrl3 cavm_gsercx_lnx_bist_rx_lock_ctrl3_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_LOCK_CTRL3(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_LOCK_CTRL3(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a80130b8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80130b8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_RX_LOCK_CTRL3", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_RX_LOCK_CTRL3(a,b) cavm_gsercx_lnx_bist_rx_lock_ctrl3_t
#define bustype_CAVM_GSERCX_LNX_BIST_RX_LOCK_CTRL3(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_RX_LOCK_CTRL3(a,b) "GSERCX_LNX_BIST_RX_LOCK_CTRL3"
#define device_bar_CAVM_GSERCX_LNX_BIST_RX_LOCK_CTRL3(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_RX_LOCK_CTRL3(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_RX_LOCK_CTRL3(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_loss_lock_ctrl0
 *
 * GSERC Ln Bist Rx Loss Lock Ctrl0 Register
 */
union cavm_gsercx_lnx_bist_rx_loss_lock_ctrl0
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_rx_loss_lock_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t num_cycles_7_0        : 8;  /**< [  7:  0](R/W/H) Size of error sampling window to trigger pattern loss-of-lock. */
#else /* Word 0 - Little Endian */
        uint32_t num_cycles_7_0        : 8;  /**< [  7:  0](R/W/H) Size of error sampling window to trigger pattern loss-of-lock. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_rx_loss_lock_ctrl0_s cn; */
};
typedef union cavm_gsercx_lnx_bist_rx_loss_lock_ctrl0 cavm_gsercx_lnx_bist_rx_loss_lock_ctrl0_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013100ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013100ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL0(a,b) cavm_gsercx_lnx_bist_rx_loss_lock_ctrl0_t
#define bustype_CAVM_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL0(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL0(a,b) "GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL0"
#define device_bar_CAVM_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL0(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_loss_lock_ctrl1
 *
 * GSERC Ln Bist Rx Loss Lock Ctrl1 Register
 */
union cavm_gsercx_lnx_bist_rx_loss_lock_ctrl1
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_rx_loss_lock_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t num_cycles_15_8       : 8;  /**< [  7:  0](R/W/H) Size of error sampling window to trigger pattern loss-of-lock. */
#else /* Word 0 - Little Endian */
        uint32_t num_cycles_15_8       : 8;  /**< [  7:  0](R/W/H) Size of error sampling window to trigger pattern loss-of-lock. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_rx_loss_lock_ctrl1_s cn; */
};
typedef union cavm_gsercx_lnx_bist_rx_loss_lock_ctrl1 cavm_gsercx_lnx_bist_rx_loss_lock_ctrl1_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013108ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013108ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL1(a,b) cavm_gsercx_lnx_bist_rx_loss_lock_ctrl1_t
#define bustype_CAVM_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL1(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL1(a,b) "GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL1"
#define device_bar_CAVM_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL1(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_loss_lock_ctrl2
 *
 * GSERC Ln Bist Rx Loss Lock Ctrl2 Register
 */
union cavm_gsercx_lnx_bist_rx_loss_lock_ctrl2
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_rx_loss_lock_ctrl2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t min_errors_7_0        : 8;  /**< [  7:  0](R/W/H) Minimum number of errors allowed to trigger pattern loss-of-lock. */
#else /* Word 0 - Little Endian */
        uint32_t min_errors_7_0        : 8;  /**< [  7:  0](R/W/H) Minimum number of errors allowed to trigger pattern loss-of-lock. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_rx_loss_lock_ctrl2_s cn; */
};
typedef union cavm_gsercx_lnx_bist_rx_loss_lock_ctrl2 cavm_gsercx_lnx_bist_rx_loss_lock_ctrl2_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL2(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL2(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013110ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013110ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL2(a,b) cavm_gsercx_lnx_bist_rx_loss_lock_ctrl2_t
#define bustype_CAVM_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL2(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL2(a,b) "GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL2"
#define device_bar_CAVM_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL2(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL2(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL2(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_loss_lock_ctrl3
 *
 * GSERC Ln Bist Rx Loss Lock Ctrl3 Register
 */
union cavm_gsercx_lnx_bist_rx_loss_lock_ctrl3
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_rx_loss_lock_ctrl3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t min_errors_15_8       : 8;  /**< [  7:  0](R/W/H) Minimum number of errors allowed to trigger pattern loss-of-lock. */
#else /* Word 0 - Little Endian */
        uint32_t min_errors_15_8       : 8;  /**< [  7:  0](R/W/H) Minimum number of errors allowed to trigger pattern loss-of-lock. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_rx_loss_lock_ctrl3_s cn; */
};
typedef union cavm_gsercx_lnx_bist_rx_loss_lock_ctrl3 cavm_gsercx_lnx_bist_rx_loss_lock_ctrl3_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL3(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL3(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013118ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013118ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL3", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL3(a,b) cavm_gsercx_lnx_bist_rx_loss_lock_ctrl3_t
#define bustype_CAVM_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL3(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL3(a,b) "GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL3"
#define device_bar_CAVM_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL3(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL3(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL3(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_loss_lock_ctrl4
 *
 * GSERC Ln Bist Rx Loss Lock Ctrl4 Register
 */
union cavm_gsercx_lnx_bist_rx_loss_lock_ctrl4
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_rx_loss_lock_ctrl4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t stop_on_loss_lock     : 1;  /**< [  0:  0](R/W/H) Stops pattern from being re-locked when loss-of-lock occurs. */
#else /* Word 0 - Little Endian */
        uint32_t stop_on_loss_lock     : 1;  /**< [  0:  0](R/W/H) Stops pattern from being re-locked when loss-of-lock occurs. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_rx_loss_lock_ctrl4_s cn; */
};
typedef union cavm_gsercx_lnx_bist_rx_loss_lock_ctrl4 cavm_gsercx_lnx_bist_rx_loss_lock_ctrl4_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL4(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL4(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013120ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013120ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL4", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL4(a,b) cavm_gsercx_lnx_bist_rx_loss_lock_ctrl4_t
#define bustype_CAVM_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL4(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL4(a,b) "GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL4"
#define device_bar_CAVM_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL4(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL4(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL4(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_status
 *
 * GSERC Ln Bist Rx Status Register
 */
union cavm_gsercx_lnx_bist_rx_status
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_rx_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t pattern_det           : 4;  /**< [  6:  3](RO/H) Indicates the pattern  detected:
                                                                 0x0 = No pattern detected
                                                                 0x1 = PRBS 0xC1
                                                                 0x2 = PRBS 0x221
                                                                 0x3 = PRBS 0xA01
                                                                 0x4 = PRBS 0xC001
                                                                 0x5 = PRBS 0x840001
                                                                 0x6 = PRBS 0x90000001
                                                                 0x7 = User defined pattern UDP */
        uint32_t state                 : 3;  /**< [  2:  0](RO/H) State of the BIST checker:
                                                                 0x0 = Off
                                                                 0x1 = Searching for pattern
                                                                 0x2 = Waiting for pattern lock conditions
                                                                 0x3 = Pattern lock acquired
                                                                 0x4 = Pattern lock lost */
#else /* Word 0 - Little Endian */
        uint32_t state                 : 3;  /**< [  2:  0](RO/H) State of the BIST checker:
                                                                 0x0 = Off
                                                                 0x1 = Searching for pattern
                                                                 0x2 = Waiting for pattern lock conditions
                                                                 0x3 = Pattern lock acquired
                                                                 0x4 = Pattern lock lost */
        uint32_t pattern_det           : 4;  /**< [  6:  3](RO/H) Indicates the pattern  detected:
                                                                 0x0 = No pattern detected
                                                                 0x1 = PRBS 0xC1
                                                                 0x2 = PRBS 0x221
                                                                 0x3 = PRBS 0xA01
                                                                 0x4 = PRBS 0xC001
                                                                 0x5 = PRBS 0x840001
                                                                 0x6 = PRBS 0x90000001
                                                                 0x7 = User defined pattern UDP */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_rx_status_s cn; */
};
typedef union cavm_gsercx_lnx_bist_rx_status cavm_gsercx_lnx_bist_rx_status_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_STATUS(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_STATUS(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013020ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013020ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_RX_STATUS", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_RX_STATUS(a,b) cavm_gsercx_lnx_bist_rx_status_t
#define bustype_CAVM_GSERCX_LNX_BIST_RX_STATUS(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_RX_STATUS(a,b) "GSERCX_LNX_BIST_RX_STATUS"
#define device_bar_CAVM_GSERCX_LNX_BIST_RX_STATUS(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_RX_STATUS(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_RX_STATUS(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_udp_103_96
 *
 * GSERC Ln Bist Rx Udp 103 96 Register
 */
union cavm_gsercx_lnx_bist_rx_udp_103_96
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_rx_udp_103_96_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_rx_udp_103_96_s cn; */
};
typedef union cavm_gsercx_lnx_bist_rx_udp_103_96 cavm_gsercx_lnx_bist_rx_udp_103_96_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_UDP_103_96(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_UDP_103_96(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013200ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013200ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_RX_UDP_103_96", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_RX_UDP_103_96(a,b) cavm_gsercx_lnx_bist_rx_udp_103_96_t
#define bustype_CAVM_GSERCX_LNX_BIST_RX_UDP_103_96(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_RX_UDP_103_96(a,b) "GSERCX_LNX_BIST_RX_UDP_103_96"
#define device_bar_CAVM_GSERCX_LNX_BIST_RX_UDP_103_96(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_RX_UDP_103_96(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_RX_UDP_103_96(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_udp_111_104
 *
 * GSERC Ln Bist Rx Udp 111 104 Register
 */
union cavm_gsercx_lnx_bist_rx_udp_111_104
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_rx_udp_111_104_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_rx_udp_111_104_s cn; */
};
typedef union cavm_gsercx_lnx_bist_rx_udp_111_104 cavm_gsercx_lnx_bist_rx_udp_111_104_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_UDP_111_104(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_UDP_111_104(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013208ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013208ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_RX_UDP_111_104", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_RX_UDP_111_104(a,b) cavm_gsercx_lnx_bist_rx_udp_111_104_t
#define bustype_CAVM_GSERCX_LNX_BIST_RX_UDP_111_104(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_RX_UDP_111_104(a,b) "GSERCX_LNX_BIST_RX_UDP_111_104"
#define device_bar_CAVM_GSERCX_LNX_BIST_RX_UDP_111_104(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_RX_UDP_111_104(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_RX_UDP_111_104(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_udp_119_112
 *
 * GSERC Ln Bist Rx Udp 119 112 Register
 */
union cavm_gsercx_lnx_bist_rx_udp_119_112
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_rx_udp_119_112_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_rx_udp_119_112_s cn; */
};
typedef union cavm_gsercx_lnx_bist_rx_udp_119_112 cavm_gsercx_lnx_bist_rx_udp_119_112_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_UDP_119_112(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_UDP_119_112(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013210ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013210ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_RX_UDP_119_112", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_RX_UDP_119_112(a,b) cavm_gsercx_lnx_bist_rx_udp_119_112_t
#define bustype_CAVM_GSERCX_LNX_BIST_RX_UDP_119_112(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_RX_UDP_119_112(a,b) "GSERCX_LNX_BIST_RX_UDP_119_112"
#define device_bar_CAVM_GSERCX_LNX_BIST_RX_UDP_119_112(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_RX_UDP_119_112(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_RX_UDP_119_112(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_udp_127_120
 *
 * GSERC Ln Bist Rx Udp 127 120 Register
 */
union cavm_gsercx_lnx_bist_rx_udp_127_120
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_rx_udp_127_120_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_rx_udp_127_120_s cn; */
};
typedef union cavm_gsercx_lnx_bist_rx_udp_127_120 cavm_gsercx_lnx_bist_rx_udp_127_120_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_UDP_127_120(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_UDP_127_120(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013218ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013218ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_RX_UDP_127_120", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_RX_UDP_127_120(a,b) cavm_gsercx_lnx_bist_rx_udp_127_120_t
#define bustype_CAVM_GSERCX_LNX_BIST_RX_UDP_127_120(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_RX_UDP_127_120(a,b) "GSERCX_LNX_BIST_RX_UDP_127_120"
#define device_bar_CAVM_GSERCX_LNX_BIST_RX_UDP_127_120(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_RX_UDP_127_120(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_RX_UDP_127_120(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_udp_135_128
 *
 * GSERC Ln Bist Rx Udp 135 128 Register
 */
union cavm_gsercx_lnx_bist_rx_udp_135_128
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_rx_udp_135_128_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_rx_udp_135_128_s cn; */
};
typedef union cavm_gsercx_lnx_bist_rx_udp_135_128 cavm_gsercx_lnx_bist_rx_udp_135_128_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_UDP_135_128(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_UDP_135_128(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013220ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013220ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_RX_UDP_135_128", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_RX_UDP_135_128(a,b) cavm_gsercx_lnx_bist_rx_udp_135_128_t
#define bustype_CAVM_GSERCX_LNX_BIST_RX_UDP_135_128(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_RX_UDP_135_128(a,b) "GSERCX_LNX_BIST_RX_UDP_135_128"
#define device_bar_CAVM_GSERCX_LNX_BIST_RX_UDP_135_128(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_RX_UDP_135_128(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_RX_UDP_135_128(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_udp_143_136
 *
 * GSERC Ln Bist Rx Udp 143 136 Register
 */
union cavm_gsercx_lnx_bist_rx_udp_143_136
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_rx_udp_143_136_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_rx_udp_143_136_s cn; */
};
typedef union cavm_gsercx_lnx_bist_rx_udp_143_136 cavm_gsercx_lnx_bist_rx_udp_143_136_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_UDP_143_136(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_UDP_143_136(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013228ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013228ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_RX_UDP_143_136", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_RX_UDP_143_136(a,b) cavm_gsercx_lnx_bist_rx_udp_143_136_t
#define bustype_CAVM_GSERCX_LNX_BIST_RX_UDP_143_136(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_RX_UDP_143_136(a,b) "GSERCX_LNX_BIST_RX_UDP_143_136"
#define device_bar_CAVM_GSERCX_LNX_BIST_RX_UDP_143_136(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_RX_UDP_143_136(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_RX_UDP_143_136(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_udp_151_144
 *
 * GSERC Ln Bist Rx Udp 151 144 Register
 */
union cavm_gsercx_lnx_bist_rx_udp_151_144
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_rx_udp_151_144_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_rx_udp_151_144_s cn; */
};
typedef union cavm_gsercx_lnx_bist_rx_udp_151_144 cavm_gsercx_lnx_bist_rx_udp_151_144_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_UDP_151_144(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_UDP_151_144(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013230ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013230ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_RX_UDP_151_144", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_RX_UDP_151_144(a,b) cavm_gsercx_lnx_bist_rx_udp_151_144_t
#define bustype_CAVM_GSERCX_LNX_BIST_RX_UDP_151_144(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_RX_UDP_151_144(a,b) "GSERCX_LNX_BIST_RX_UDP_151_144"
#define device_bar_CAVM_GSERCX_LNX_BIST_RX_UDP_151_144(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_RX_UDP_151_144(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_RX_UDP_151_144(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_udp_159_152
 *
 * GSERC Ln Bist Rx Udp 159 152 Register
 */
union cavm_gsercx_lnx_bist_rx_udp_159_152
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_rx_udp_159_152_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_rx_udp_159_152_s cn; */
};
typedef union cavm_gsercx_lnx_bist_rx_udp_159_152 cavm_gsercx_lnx_bist_rx_udp_159_152_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_UDP_159_152(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_UDP_159_152(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013238ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013238ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_RX_UDP_159_152", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_RX_UDP_159_152(a,b) cavm_gsercx_lnx_bist_rx_udp_159_152_t
#define bustype_CAVM_GSERCX_LNX_BIST_RX_UDP_159_152(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_RX_UDP_159_152(a,b) "GSERCX_LNX_BIST_RX_UDP_159_152"
#define device_bar_CAVM_GSERCX_LNX_BIST_RX_UDP_159_152(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_RX_UDP_159_152(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_RX_UDP_159_152(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_udp_15_8
 *
 * GSERC Ln Bist Rx Udp 15 8 Register
 */
union cavm_gsercx_lnx_bist_rx_udp_15_8
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_rx_udp_15_8_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_rx_udp_15_8_s cn; */
};
typedef union cavm_gsercx_lnx_bist_rx_udp_15_8 cavm_gsercx_lnx_bist_rx_udp_15_8_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_UDP_15_8(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_UDP_15_8(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a80131a8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80131a8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_RX_UDP_15_8", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_RX_UDP_15_8(a,b) cavm_gsercx_lnx_bist_rx_udp_15_8_t
#define bustype_CAVM_GSERCX_LNX_BIST_RX_UDP_15_8(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_RX_UDP_15_8(a,b) "GSERCX_LNX_BIST_RX_UDP_15_8"
#define device_bar_CAVM_GSERCX_LNX_BIST_RX_UDP_15_8(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_RX_UDP_15_8(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_RX_UDP_15_8(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_udp_167_160
 *
 * GSERC Ln Bist Rx Udp 167 160 Register
 */
union cavm_gsercx_lnx_bist_rx_udp_167_160
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_rx_udp_167_160_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern extension bits. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern extension bits. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_rx_udp_167_160_s cn; */
};
typedef union cavm_gsercx_lnx_bist_rx_udp_167_160 cavm_gsercx_lnx_bist_rx_udp_167_160_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_UDP_167_160(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_UDP_167_160(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013240ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013240ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_RX_UDP_167_160", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_RX_UDP_167_160(a,b) cavm_gsercx_lnx_bist_rx_udp_167_160_t
#define bustype_CAVM_GSERCX_LNX_BIST_RX_UDP_167_160(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_RX_UDP_167_160(a,b) "GSERCX_LNX_BIST_RX_UDP_167_160"
#define device_bar_CAVM_GSERCX_LNX_BIST_RX_UDP_167_160(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_RX_UDP_167_160(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_RX_UDP_167_160(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_udp_175_168
 *
 * GSERC Ln Bist Rx Udp 175 168 Register
 */
union cavm_gsercx_lnx_bist_rx_udp_175_168
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_rx_udp_175_168_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern extension bits. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern extension bits. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_rx_udp_175_168_s cn; */
};
typedef union cavm_gsercx_lnx_bist_rx_udp_175_168 cavm_gsercx_lnx_bist_rx_udp_175_168_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_UDP_175_168(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_UDP_175_168(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013248ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013248ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_RX_UDP_175_168", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_RX_UDP_175_168(a,b) cavm_gsercx_lnx_bist_rx_udp_175_168_t
#define bustype_CAVM_GSERCX_LNX_BIST_RX_UDP_175_168(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_RX_UDP_175_168(a,b) "GSERCX_LNX_BIST_RX_UDP_175_168"
#define device_bar_CAVM_GSERCX_LNX_BIST_RX_UDP_175_168(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_RX_UDP_175_168(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_RX_UDP_175_168(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_udp_183_176
 *
 * GSERC Ln Bist Rx Udp 183 176 Register
 */
union cavm_gsercx_lnx_bist_rx_udp_183_176
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_rx_udp_183_176_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern extension bits. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern extension bits. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_rx_udp_183_176_s cn; */
};
typedef union cavm_gsercx_lnx_bist_rx_udp_183_176 cavm_gsercx_lnx_bist_rx_udp_183_176_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_UDP_183_176(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_UDP_183_176(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013250ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013250ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_RX_UDP_183_176", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_RX_UDP_183_176(a,b) cavm_gsercx_lnx_bist_rx_udp_183_176_t
#define bustype_CAVM_GSERCX_LNX_BIST_RX_UDP_183_176(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_RX_UDP_183_176(a,b) "GSERCX_LNX_BIST_RX_UDP_183_176"
#define device_bar_CAVM_GSERCX_LNX_BIST_RX_UDP_183_176(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_RX_UDP_183_176(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_RX_UDP_183_176(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_udp_191_184
 *
 * GSERC Ln Bist Rx Udp 191 184 Register
 */
union cavm_gsercx_lnx_bist_rx_udp_191_184
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_rx_udp_191_184_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern extension bits. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern extension bits. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_rx_udp_191_184_s cn; */
};
typedef union cavm_gsercx_lnx_bist_rx_udp_191_184 cavm_gsercx_lnx_bist_rx_udp_191_184_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_UDP_191_184(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_UDP_191_184(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013258ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013258ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_RX_UDP_191_184", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_RX_UDP_191_184(a,b) cavm_gsercx_lnx_bist_rx_udp_191_184_t
#define bustype_CAVM_GSERCX_LNX_BIST_RX_UDP_191_184(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_RX_UDP_191_184(a,b) "GSERCX_LNX_BIST_RX_UDP_191_184"
#define device_bar_CAVM_GSERCX_LNX_BIST_RX_UDP_191_184(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_RX_UDP_191_184(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_RX_UDP_191_184(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_udp_199_192
 *
 * GSERC Ln Bist Rx Udp 199 192 Register
 */
union cavm_gsercx_lnx_bist_rx_udp_199_192
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_rx_udp_199_192_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern extension bits. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern extension bits. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_rx_udp_199_192_s cn; */
};
typedef union cavm_gsercx_lnx_bist_rx_udp_199_192 cavm_gsercx_lnx_bist_rx_udp_199_192_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_UDP_199_192(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_UDP_199_192(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013260ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013260ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_RX_UDP_199_192", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_RX_UDP_199_192(a,b) cavm_gsercx_lnx_bist_rx_udp_199_192_t
#define bustype_CAVM_GSERCX_LNX_BIST_RX_UDP_199_192(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_RX_UDP_199_192(a,b) "GSERCX_LNX_BIST_RX_UDP_199_192"
#define device_bar_CAVM_GSERCX_LNX_BIST_RX_UDP_199_192(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_RX_UDP_199_192(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_RX_UDP_199_192(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_udp_23_16
 *
 * GSERC Ln Bist Rx Udp 23 16 Register
 */
union cavm_gsercx_lnx_bist_rx_udp_23_16
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_rx_udp_23_16_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_rx_udp_23_16_s cn; */
};
typedef union cavm_gsercx_lnx_bist_rx_udp_23_16 cavm_gsercx_lnx_bist_rx_udp_23_16_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_UDP_23_16(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_UDP_23_16(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a80131b0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80131b0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_RX_UDP_23_16", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_RX_UDP_23_16(a,b) cavm_gsercx_lnx_bist_rx_udp_23_16_t
#define bustype_CAVM_GSERCX_LNX_BIST_RX_UDP_23_16(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_RX_UDP_23_16(a,b) "GSERCX_LNX_BIST_RX_UDP_23_16"
#define device_bar_CAVM_GSERCX_LNX_BIST_RX_UDP_23_16(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_RX_UDP_23_16(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_RX_UDP_23_16(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_udp_31_24
 *
 * GSERC Ln Bist Rx Udp 31 24 Register
 */
union cavm_gsercx_lnx_bist_rx_udp_31_24
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_rx_udp_31_24_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_rx_udp_31_24_s cn; */
};
typedef union cavm_gsercx_lnx_bist_rx_udp_31_24 cavm_gsercx_lnx_bist_rx_udp_31_24_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_UDP_31_24(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_UDP_31_24(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a80131b8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80131b8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_RX_UDP_31_24", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_RX_UDP_31_24(a,b) cavm_gsercx_lnx_bist_rx_udp_31_24_t
#define bustype_CAVM_GSERCX_LNX_BIST_RX_UDP_31_24(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_RX_UDP_31_24(a,b) "GSERCX_LNX_BIST_RX_UDP_31_24"
#define device_bar_CAVM_GSERCX_LNX_BIST_RX_UDP_31_24(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_RX_UDP_31_24(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_RX_UDP_31_24(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_udp_39_32
 *
 * GSERC Ln Bist Rx Udp 39 32 Register
 */
union cavm_gsercx_lnx_bist_rx_udp_39_32
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_rx_udp_39_32_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_rx_udp_39_32_s cn; */
};
typedef union cavm_gsercx_lnx_bist_rx_udp_39_32 cavm_gsercx_lnx_bist_rx_udp_39_32_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_UDP_39_32(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_UDP_39_32(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a80131c0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80131c0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_RX_UDP_39_32", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_RX_UDP_39_32(a,b) cavm_gsercx_lnx_bist_rx_udp_39_32_t
#define bustype_CAVM_GSERCX_LNX_BIST_RX_UDP_39_32(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_RX_UDP_39_32(a,b) "GSERCX_LNX_BIST_RX_UDP_39_32"
#define device_bar_CAVM_GSERCX_LNX_BIST_RX_UDP_39_32(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_RX_UDP_39_32(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_RX_UDP_39_32(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_udp_47_40
 *
 * GSERC Ln Bist Rx Udp 47 40 Register
 */
union cavm_gsercx_lnx_bist_rx_udp_47_40
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_rx_udp_47_40_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_rx_udp_47_40_s cn; */
};
typedef union cavm_gsercx_lnx_bist_rx_udp_47_40 cavm_gsercx_lnx_bist_rx_udp_47_40_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_UDP_47_40(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_UDP_47_40(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a80131c8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80131c8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_RX_UDP_47_40", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_RX_UDP_47_40(a,b) cavm_gsercx_lnx_bist_rx_udp_47_40_t
#define bustype_CAVM_GSERCX_LNX_BIST_RX_UDP_47_40(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_RX_UDP_47_40(a,b) "GSERCX_LNX_BIST_RX_UDP_47_40"
#define device_bar_CAVM_GSERCX_LNX_BIST_RX_UDP_47_40(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_RX_UDP_47_40(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_RX_UDP_47_40(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_udp_55_48
 *
 * GSERC Ln Bist Rx Udp 55 48 Register
 */
union cavm_gsercx_lnx_bist_rx_udp_55_48
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_rx_udp_55_48_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_rx_udp_55_48_s cn; */
};
typedef union cavm_gsercx_lnx_bist_rx_udp_55_48 cavm_gsercx_lnx_bist_rx_udp_55_48_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_UDP_55_48(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_UDP_55_48(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a80131d0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80131d0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_RX_UDP_55_48", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_RX_UDP_55_48(a,b) cavm_gsercx_lnx_bist_rx_udp_55_48_t
#define bustype_CAVM_GSERCX_LNX_BIST_RX_UDP_55_48(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_RX_UDP_55_48(a,b) "GSERCX_LNX_BIST_RX_UDP_55_48"
#define device_bar_CAVM_GSERCX_LNX_BIST_RX_UDP_55_48(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_RX_UDP_55_48(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_RX_UDP_55_48(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_udp_63_56
 *
 * GSERC Ln Bist Rx Udp 63 56 Register
 */
union cavm_gsercx_lnx_bist_rx_udp_63_56
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_rx_udp_63_56_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_rx_udp_63_56_s cn; */
};
typedef union cavm_gsercx_lnx_bist_rx_udp_63_56 cavm_gsercx_lnx_bist_rx_udp_63_56_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_UDP_63_56(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_UDP_63_56(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a80131d8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80131d8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_RX_UDP_63_56", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_RX_UDP_63_56(a,b) cavm_gsercx_lnx_bist_rx_udp_63_56_t
#define bustype_CAVM_GSERCX_LNX_BIST_RX_UDP_63_56(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_RX_UDP_63_56(a,b) "GSERCX_LNX_BIST_RX_UDP_63_56"
#define device_bar_CAVM_GSERCX_LNX_BIST_RX_UDP_63_56(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_RX_UDP_63_56(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_RX_UDP_63_56(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_udp_71_64
 *
 * GSERC Ln Bist Rx Udp 71 64 Register
 */
union cavm_gsercx_lnx_bist_rx_udp_71_64
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_rx_udp_71_64_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_rx_udp_71_64_s cn; */
};
typedef union cavm_gsercx_lnx_bist_rx_udp_71_64 cavm_gsercx_lnx_bist_rx_udp_71_64_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_UDP_71_64(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_UDP_71_64(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a80131e0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80131e0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_RX_UDP_71_64", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_RX_UDP_71_64(a,b) cavm_gsercx_lnx_bist_rx_udp_71_64_t
#define bustype_CAVM_GSERCX_LNX_BIST_RX_UDP_71_64(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_RX_UDP_71_64(a,b) "GSERCX_LNX_BIST_RX_UDP_71_64"
#define device_bar_CAVM_GSERCX_LNX_BIST_RX_UDP_71_64(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_RX_UDP_71_64(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_RX_UDP_71_64(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_udp_79_72
 *
 * GSERC Ln Bist Rx Udp 79 72 Register
 */
union cavm_gsercx_lnx_bist_rx_udp_79_72
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_rx_udp_79_72_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_rx_udp_79_72_s cn; */
};
typedef union cavm_gsercx_lnx_bist_rx_udp_79_72 cavm_gsercx_lnx_bist_rx_udp_79_72_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_UDP_79_72(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_UDP_79_72(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a80131e8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80131e8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_RX_UDP_79_72", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_RX_UDP_79_72(a,b) cavm_gsercx_lnx_bist_rx_udp_79_72_t
#define bustype_CAVM_GSERCX_LNX_BIST_RX_UDP_79_72(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_RX_UDP_79_72(a,b) "GSERCX_LNX_BIST_RX_UDP_79_72"
#define device_bar_CAVM_GSERCX_LNX_BIST_RX_UDP_79_72(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_RX_UDP_79_72(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_RX_UDP_79_72(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_udp_7_0
 *
 * GSERC Ln Bist Rx Udp 7 0 Register
 */
union cavm_gsercx_lnx_bist_rx_udp_7_0
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_rx_udp_7_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_rx_udp_7_0_s cn; */
};
typedef union cavm_gsercx_lnx_bist_rx_udp_7_0 cavm_gsercx_lnx_bist_rx_udp_7_0_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_UDP_7_0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_UDP_7_0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a80131a0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80131a0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_RX_UDP_7_0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_RX_UDP_7_0(a,b) cavm_gsercx_lnx_bist_rx_udp_7_0_t
#define bustype_CAVM_GSERCX_LNX_BIST_RX_UDP_7_0(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_RX_UDP_7_0(a,b) "GSERCX_LNX_BIST_RX_UDP_7_0"
#define device_bar_CAVM_GSERCX_LNX_BIST_RX_UDP_7_0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_RX_UDP_7_0(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_RX_UDP_7_0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_udp_87_80
 *
 * GSERC Ln Bist Rx Udp 87 80 Register
 */
union cavm_gsercx_lnx_bist_rx_udp_87_80
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_rx_udp_87_80_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_rx_udp_87_80_s cn; */
};
typedef union cavm_gsercx_lnx_bist_rx_udp_87_80 cavm_gsercx_lnx_bist_rx_udp_87_80_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_UDP_87_80(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_UDP_87_80(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a80131f0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80131f0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_RX_UDP_87_80", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_RX_UDP_87_80(a,b) cavm_gsercx_lnx_bist_rx_udp_87_80_t
#define bustype_CAVM_GSERCX_LNX_BIST_RX_UDP_87_80(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_RX_UDP_87_80(a,b) "GSERCX_LNX_BIST_RX_UDP_87_80"
#define device_bar_CAVM_GSERCX_LNX_BIST_RX_UDP_87_80(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_RX_UDP_87_80(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_RX_UDP_87_80(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_udp_95_88
 *
 * GSERC Ln Bist Rx Udp 95 88 Register
 */
union cavm_gsercx_lnx_bist_rx_udp_95_88
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_rx_udp_95_88_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_rx_udp_95_88_s cn; */
};
typedef union cavm_gsercx_lnx_bist_rx_udp_95_88 cavm_gsercx_lnx_bist_rx_udp_95_88_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_UDP_95_88(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_UDP_95_88(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a80131f8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80131f8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_RX_UDP_95_88", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_RX_UDP_95_88(a,b) cavm_gsercx_lnx_bist_rx_udp_95_88_t
#define bustype_CAVM_GSERCX_LNX_BIST_RX_UDP_95_88(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_RX_UDP_95_88(a,b) "GSERCX_LNX_BIST_RX_UDP_95_88"
#define device_bar_CAVM_GSERCX_LNX_BIST_RX_UDP_95_88(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_RX_UDP_95_88(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_RX_UDP_95_88(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_udp_shift_amount
 *
 * GSERC Ln Bist Rx Udp Shift Amount Register
 */
union cavm_gsercx_lnx_bist_rx_udp_shift_amount
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_rx_udp_shift_amount_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Determines the length of the UDP.  Must be set to d160 modulus udp_length. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Determines the length of the UDP.  Must be set to d160 modulus udp_length. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_rx_udp_shift_amount_s cn; */
};
typedef union cavm_gsercx_lnx_bist_rx_udp_shift_amount cavm_gsercx_lnx_bist_rx_udp_shift_amount_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_UDP_SHIFT_AMOUNT(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_RX_UDP_SHIFT_AMOUNT(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013180ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013180ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_RX_UDP_SHIFT_AMOUNT", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_RX_UDP_SHIFT_AMOUNT(a,b) cavm_gsercx_lnx_bist_rx_udp_shift_amount_t
#define bustype_CAVM_GSERCX_LNX_BIST_RX_UDP_SHIFT_AMOUNT(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_RX_UDP_SHIFT_AMOUNT(a,b) "GSERCX_LNX_BIST_RX_UDP_SHIFT_AMOUNT"
#define device_bar_CAVM_GSERCX_LNX_BIST_RX_UDP_SHIFT_AMOUNT(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_RX_UDP_SHIFT_AMOUNT(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_RX_UDP_SHIFT_AMOUNT(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_ber_ctrl0
 *
 * GSERC Ln Bist Tx Ber Ctrl0 Register
 */
union cavm_gsercx_lnx_bist_tx_ber_ctrl0
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_tx_ber_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t mode                  : 2;  /**< [  1:  0](R/W/H) Controls what type of error injection is used:
                                                                 0x0 = None
                                                                 0x1 = Single cycle error
                                                                 0x2 = Timer based */
#else /* Word 0 - Little Endian */
        uint32_t mode                  : 2;  /**< [  1:  0](R/W/H) Controls what type of error injection is used:
                                                                 0x0 = None
                                                                 0x1 = Single cycle error
                                                                 0x2 = Timer based */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_tx_ber_ctrl0_s cn; */
};
typedef union cavm_gsercx_lnx_bist_tx_ber_ctrl0 cavm_gsercx_lnx_bist_tx_ber_ctrl0_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_BER_CTRL0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_BER_CTRL0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8012c28ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012c28ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_TX_BER_CTRL0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_TX_BER_CTRL0(a,b) cavm_gsercx_lnx_bist_tx_ber_ctrl0_t
#define bustype_CAVM_GSERCX_LNX_BIST_TX_BER_CTRL0(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_TX_BER_CTRL0(a,b) "GSERCX_LNX_BIST_TX_BER_CTRL0"
#define device_bar_CAVM_GSERCX_LNX_BIST_TX_BER_CTRL0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_TX_BER_CTRL0(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_TX_BER_CTRL0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_ber_ctrl1
 *
 * GSERC Ln Bist Tx Ber Ctrl1 Register
 */
union cavm_gsercx_lnx_bist_tx_ber_ctrl1
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_tx_ber_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t timer_7_0             : 8;  /**< [  7:  0](R/W/H) Number of cycles between single bit-error injection. */
#else /* Word 0 - Little Endian */
        uint32_t timer_7_0             : 8;  /**< [  7:  0](R/W/H) Number of cycles between single bit-error injection. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_tx_ber_ctrl1_s cn; */
};
typedef union cavm_gsercx_lnx_bist_tx_ber_ctrl1 cavm_gsercx_lnx_bist_tx_ber_ctrl1_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_BER_CTRL1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_BER_CTRL1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8012c30ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012c30ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_TX_BER_CTRL1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_TX_BER_CTRL1(a,b) cavm_gsercx_lnx_bist_tx_ber_ctrl1_t
#define bustype_CAVM_GSERCX_LNX_BIST_TX_BER_CTRL1(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_TX_BER_CTRL1(a,b) "GSERCX_LNX_BIST_TX_BER_CTRL1"
#define device_bar_CAVM_GSERCX_LNX_BIST_TX_BER_CTRL1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_TX_BER_CTRL1(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_TX_BER_CTRL1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_ber_ctrl2
 *
 * GSERC Ln Bist Tx Ber Ctrl2 Register
 */
union cavm_gsercx_lnx_bist_tx_ber_ctrl2
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_tx_ber_ctrl2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t timer_15_8            : 8;  /**< [  7:  0](R/W/H) Number of cycles between single bit-error injection. */
#else /* Word 0 - Little Endian */
        uint32_t timer_15_8            : 8;  /**< [  7:  0](R/W/H) Number of cycles between single bit-error injection. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_tx_ber_ctrl2_s cn; */
};
typedef union cavm_gsercx_lnx_bist_tx_ber_ctrl2 cavm_gsercx_lnx_bist_tx_ber_ctrl2_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_BER_CTRL2(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_BER_CTRL2(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8012c38ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012c38ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_TX_BER_CTRL2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_TX_BER_CTRL2(a,b) cavm_gsercx_lnx_bist_tx_ber_ctrl2_t
#define bustype_CAVM_GSERCX_LNX_BIST_TX_BER_CTRL2(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_TX_BER_CTRL2(a,b) "GSERCX_LNX_BIST_TX_BER_CTRL2"
#define device_bar_CAVM_GSERCX_LNX_BIST_TX_BER_CTRL2(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_TX_BER_CTRL2(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_TX_BER_CTRL2(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_ber_ctrl3
 *
 * GSERC Ln Bist Tx Ber Ctrl3 Register
 */
union cavm_gsercx_lnx_bist_tx_ber_ctrl3
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_tx_ber_ctrl3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t bit_error_field_7_0   : 8;  /**< [  7:  0](R/W/H) Sets the Tx data bits to be flipped. */
#else /* Word 0 - Little Endian */
        uint32_t bit_error_field_7_0   : 8;  /**< [  7:  0](R/W/H) Sets the Tx data bits to be flipped. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_tx_ber_ctrl3_s cn; */
};
typedef union cavm_gsercx_lnx_bist_tx_ber_ctrl3 cavm_gsercx_lnx_bist_tx_ber_ctrl3_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_BER_CTRL3(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_BER_CTRL3(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8012c40ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012c40ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_TX_BER_CTRL3", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_TX_BER_CTRL3(a,b) cavm_gsercx_lnx_bist_tx_ber_ctrl3_t
#define bustype_CAVM_GSERCX_LNX_BIST_TX_BER_CTRL3(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_TX_BER_CTRL3(a,b) "GSERCX_LNX_BIST_TX_BER_CTRL3"
#define device_bar_CAVM_GSERCX_LNX_BIST_TX_BER_CTRL3(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_TX_BER_CTRL3(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_TX_BER_CTRL3(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_ber_ctrl4
 *
 * GSERC Ln Bist Tx Ber Ctrl4 Register
 */
union cavm_gsercx_lnx_bist_tx_ber_ctrl4
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_tx_ber_ctrl4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t bit_error_field_15_8  : 8;  /**< [  7:  0](R/W/H) Sets the Tx data bits to be flipped. */
#else /* Word 0 - Little Endian */
        uint32_t bit_error_field_15_8  : 8;  /**< [  7:  0](R/W/H) Sets the Tx data bits to be flipped. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_tx_ber_ctrl4_s cn; */
};
typedef union cavm_gsercx_lnx_bist_tx_ber_ctrl4 cavm_gsercx_lnx_bist_tx_ber_ctrl4_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_BER_CTRL4(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_BER_CTRL4(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8012c48ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012c48ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_TX_BER_CTRL4", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_TX_BER_CTRL4(a,b) cavm_gsercx_lnx_bist_tx_ber_ctrl4_t
#define bustype_CAVM_GSERCX_LNX_BIST_TX_BER_CTRL4(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_TX_BER_CTRL4(a,b) "GSERCX_LNX_BIST_TX_BER_CTRL4"
#define device_bar_CAVM_GSERCX_LNX_BIST_TX_BER_CTRL4(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_TX_BER_CTRL4(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_TX_BER_CTRL4(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_ber_ctrl5
 *
 * GSERC Ln Bist Tx Ber Ctrl5 Register
 */
union cavm_gsercx_lnx_bist_tx_ber_ctrl5
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_tx_ber_ctrl5_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t bit_error_field_23_16 : 8;  /**< [  7:  0](R/W/H) Sets the Tx data bits to be flipped. */
#else /* Word 0 - Little Endian */
        uint32_t bit_error_field_23_16 : 8;  /**< [  7:  0](R/W/H) Sets the Tx data bits to be flipped. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_tx_ber_ctrl5_s cn; */
};
typedef union cavm_gsercx_lnx_bist_tx_ber_ctrl5 cavm_gsercx_lnx_bist_tx_ber_ctrl5_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_BER_CTRL5(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_BER_CTRL5(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8012c50ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012c50ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_TX_BER_CTRL5", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_TX_BER_CTRL5(a,b) cavm_gsercx_lnx_bist_tx_ber_ctrl5_t
#define bustype_CAVM_GSERCX_LNX_BIST_TX_BER_CTRL5(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_TX_BER_CTRL5(a,b) "GSERCX_LNX_BIST_TX_BER_CTRL5"
#define device_bar_CAVM_GSERCX_LNX_BIST_TX_BER_CTRL5(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_TX_BER_CTRL5(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_TX_BER_CTRL5(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_ber_ctrl6
 *
 * GSERC Ln Bist Tx Ber Ctrl6 Register
 */
union cavm_gsercx_lnx_bist_tx_ber_ctrl6
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_tx_ber_ctrl6_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t bit_error_field_31_24 : 8;  /**< [  7:  0](R/W/H) Sets the Tx data bits to be flipped. */
#else /* Word 0 - Little Endian */
        uint32_t bit_error_field_31_24 : 8;  /**< [  7:  0](R/W/H) Sets the Tx data bits to be flipped. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_tx_ber_ctrl6_s cn; */
};
typedef union cavm_gsercx_lnx_bist_tx_ber_ctrl6 cavm_gsercx_lnx_bist_tx_ber_ctrl6_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_BER_CTRL6(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_BER_CTRL6(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8012c58ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012c58ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_TX_BER_CTRL6", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_TX_BER_CTRL6(a,b) cavm_gsercx_lnx_bist_tx_ber_ctrl6_t
#define bustype_CAVM_GSERCX_LNX_BIST_TX_BER_CTRL6(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_TX_BER_CTRL6(a,b) "GSERCX_LNX_BIST_TX_BER_CTRL6"
#define device_bar_CAVM_GSERCX_LNX_BIST_TX_BER_CTRL6(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_TX_BER_CTRL6(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_TX_BER_CTRL6(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_ber_ctrl7
 *
 * GSERC Ln Bist Tx Ber Ctrl7 Register
 */
union cavm_gsercx_lnx_bist_tx_ber_ctrl7
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_tx_ber_ctrl7_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t bit_error_field_39_32 : 8;  /**< [  7:  0](R/W/H) Sets the Tx data bits to be flipped. */
#else /* Word 0 - Little Endian */
        uint32_t bit_error_field_39_32 : 8;  /**< [  7:  0](R/W/H) Sets the Tx data bits to be flipped. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_tx_ber_ctrl7_s cn; */
};
typedef union cavm_gsercx_lnx_bist_tx_ber_ctrl7 cavm_gsercx_lnx_bist_tx_ber_ctrl7_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_BER_CTRL7(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_BER_CTRL7(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8012c60ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012c60ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_TX_BER_CTRL7", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_TX_BER_CTRL7(a,b) cavm_gsercx_lnx_bist_tx_ber_ctrl7_t
#define bustype_CAVM_GSERCX_LNX_BIST_TX_BER_CTRL7(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_TX_BER_CTRL7(a,b) "GSERCX_LNX_BIST_TX_BER_CTRL7"
#define device_bar_CAVM_GSERCX_LNX_BIST_TX_BER_CTRL7(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_TX_BER_CTRL7(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_TX_BER_CTRL7(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_ctrl
 *
 * GSERC Ln Bist Tx Ctrl Register
 */
union cavm_gsercx_lnx_bist_tx_ctrl
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_tx_ctrl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t pattern_sel           : 4;  /**< [  4:  1](R/W/H) Indicates the pattern to detected:
                                                                 0x0 = No pattern detected
                                                                 0x1 = PRBS 0xC1
                                                                 0x2 = PRBS 0x221
                                                                 0x3 = PRBS 0xA01
                                                                 0x4 = PRBS 0xC001
                                                                 0x5 = PRBS 0x840001
                                                                 0x6 = PRBS 0x90000001
                                                                 0x7 = User defined pattern UDP
                                                                 0x9 = MAC Tx data */
        uint32_t en                    : 1;  /**< [  0:  0](R/W/H) Enables BIST Tx data generation. */
#else /* Word 0 - Little Endian */
        uint32_t en                    : 1;  /**< [  0:  0](R/W/H) Enables BIST Tx data generation. */
        uint32_t pattern_sel           : 4;  /**< [  4:  1](R/W/H) Indicates the pattern to detected:
                                                                 0x0 = No pattern detected
                                                                 0x1 = PRBS 0xC1
                                                                 0x2 = PRBS 0x221
                                                                 0x3 = PRBS 0xA01
                                                                 0x4 = PRBS 0xC001
                                                                 0x5 = PRBS 0x840001
                                                                 0x6 = PRBS 0x90000001
                                                                 0x7 = User defined pattern UDP
                                                                 0x9 = MAC Tx data */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_tx_ctrl_s cn; */
};
typedef union cavm_gsercx_lnx_bist_tx_ctrl cavm_gsercx_lnx_bist_tx_ctrl_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_CTRL(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_CTRL(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8012c00ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012c00ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_TX_CTRL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_TX_CTRL(a,b) cavm_gsercx_lnx_bist_tx_ctrl_t
#define bustype_CAVM_GSERCX_LNX_BIST_TX_CTRL(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_TX_CTRL(a,b) "GSERCX_LNX_BIST_TX_CTRL"
#define device_bar_CAVM_GSERCX_LNX_BIST_TX_CTRL(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_TX_CTRL(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_TX_CTRL(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_prbs_ctrl0
 *
 * GSERC Ln Bist Tx Prbs Ctrl0 Register
 */
union cavm_gsercx_lnx_bist_tx_prbs_ctrl0
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_tx_prbs_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t seed_7_0              : 8;  /**< [  7:  0](R/W/H) Controls the initial seed of the PRBS generator.  Do not set to all zero. */
#else /* Word 0 - Little Endian */
        uint32_t seed_7_0              : 8;  /**< [  7:  0](R/W/H) Controls the initial seed of the PRBS generator.  Do not set to all zero. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_tx_prbs_ctrl0_s cn; */
};
typedef union cavm_gsercx_lnx_bist_tx_prbs_ctrl0 cavm_gsercx_lnx_bist_tx_prbs_ctrl0_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_PRBS_CTRL0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_PRBS_CTRL0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8012c08ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012c08ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_TX_PRBS_CTRL0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_TX_PRBS_CTRL0(a,b) cavm_gsercx_lnx_bist_tx_prbs_ctrl0_t
#define bustype_CAVM_GSERCX_LNX_BIST_TX_PRBS_CTRL0(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_TX_PRBS_CTRL0(a,b) "GSERCX_LNX_BIST_TX_PRBS_CTRL0"
#define device_bar_CAVM_GSERCX_LNX_BIST_TX_PRBS_CTRL0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_TX_PRBS_CTRL0(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_TX_PRBS_CTRL0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_prbs_ctrl1
 *
 * GSERC Ln Bist Tx Prbs Ctrl1 Register
 */
union cavm_gsercx_lnx_bist_tx_prbs_ctrl1
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_tx_prbs_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t seed_15_8             : 8;  /**< [  7:  0](R/W/H) Controls the initial seed of the PRBS generator.  Do not set to all zero. */
#else /* Word 0 - Little Endian */
        uint32_t seed_15_8             : 8;  /**< [  7:  0](R/W/H) Controls the initial seed of the PRBS generator.  Do not set to all zero. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_tx_prbs_ctrl1_s cn; */
};
typedef union cavm_gsercx_lnx_bist_tx_prbs_ctrl1 cavm_gsercx_lnx_bist_tx_prbs_ctrl1_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_PRBS_CTRL1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_PRBS_CTRL1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8012c10ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012c10ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_TX_PRBS_CTRL1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_TX_PRBS_CTRL1(a,b) cavm_gsercx_lnx_bist_tx_prbs_ctrl1_t
#define bustype_CAVM_GSERCX_LNX_BIST_TX_PRBS_CTRL1(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_TX_PRBS_CTRL1(a,b) "GSERCX_LNX_BIST_TX_PRBS_CTRL1"
#define device_bar_CAVM_GSERCX_LNX_BIST_TX_PRBS_CTRL1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_TX_PRBS_CTRL1(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_TX_PRBS_CTRL1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_prbs_ctrl2
 *
 * GSERC Ln Bist Tx Prbs Ctrl2 Register
 */
union cavm_gsercx_lnx_bist_tx_prbs_ctrl2
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_tx_prbs_ctrl2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t seed_23_16            : 8;  /**< [  7:  0](R/W/H) Controls the initial seed of the PRBS generator.  Do not set to all zero. */
#else /* Word 0 - Little Endian */
        uint32_t seed_23_16            : 8;  /**< [  7:  0](R/W/H) Controls the initial seed of the PRBS generator.  Do not set to all zero. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_tx_prbs_ctrl2_s cn; */
};
typedef union cavm_gsercx_lnx_bist_tx_prbs_ctrl2 cavm_gsercx_lnx_bist_tx_prbs_ctrl2_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_PRBS_CTRL2(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_PRBS_CTRL2(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8012c18ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012c18ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_TX_PRBS_CTRL2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_TX_PRBS_CTRL2(a,b) cavm_gsercx_lnx_bist_tx_prbs_ctrl2_t
#define bustype_CAVM_GSERCX_LNX_BIST_TX_PRBS_CTRL2(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_TX_PRBS_CTRL2(a,b) "GSERCX_LNX_BIST_TX_PRBS_CTRL2"
#define device_bar_CAVM_GSERCX_LNX_BIST_TX_PRBS_CTRL2(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_TX_PRBS_CTRL2(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_TX_PRBS_CTRL2(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_prbs_ctrl3
 *
 * GSERC Ln Bist Tx Prbs Ctrl3 Register
 */
union cavm_gsercx_lnx_bist_tx_prbs_ctrl3
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_tx_prbs_ctrl3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t seed_31_24            : 8;  /**< [  7:  0](R/W/H) Controls the initial seed of the PRBS generator.  Do not set to all zero. */
#else /* Word 0 - Little Endian */
        uint32_t seed_31_24            : 8;  /**< [  7:  0](R/W/H) Controls the initial seed of the PRBS generator.  Do not set to all zero. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_tx_prbs_ctrl3_s cn; */
};
typedef union cavm_gsercx_lnx_bist_tx_prbs_ctrl3 cavm_gsercx_lnx_bist_tx_prbs_ctrl3_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_PRBS_CTRL3(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_PRBS_CTRL3(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8012c20ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012c20ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_TX_PRBS_CTRL3", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_TX_PRBS_CTRL3(a,b) cavm_gsercx_lnx_bist_tx_prbs_ctrl3_t
#define bustype_CAVM_GSERCX_LNX_BIST_TX_PRBS_CTRL3(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_TX_PRBS_CTRL3(a,b) "GSERCX_LNX_BIST_TX_PRBS_CTRL3"
#define device_bar_CAVM_GSERCX_LNX_BIST_TX_PRBS_CTRL3(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_TX_PRBS_CTRL3(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_TX_PRBS_CTRL3(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_udp_103_96
 *
 * GSERC Ln Bist Tx Udp 103 96 Register
 */
union cavm_gsercx_lnx_bist_tx_udp_103_96
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_tx_udp_103_96_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_tx_udp_103_96_s cn; */
};
typedef union cavm_gsercx_lnx_bist_tx_udp_103_96 cavm_gsercx_lnx_bist_tx_udp_103_96_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_UDP_103_96(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_UDP_103_96(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8012d80ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012d80ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_TX_UDP_103_96", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_TX_UDP_103_96(a,b) cavm_gsercx_lnx_bist_tx_udp_103_96_t
#define bustype_CAVM_GSERCX_LNX_BIST_TX_UDP_103_96(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_TX_UDP_103_96(a,b) "GSERCX_LNX_BIST_TX_UDP_103_96"
#define device_bar_CAVM_GSERCX_LNX_BIST_TX_UDP_103_96(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_TX_UDP_103_96(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_TX_UDP_103_96(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_udp_111_104
 *
 * GSERC Ln Bist Tx Udp 111 104 Register
 */
union cavm_gsercx_lnx_bist_tx_udp_111_104
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_tx_udp_111_104_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_tx_udp_111_104_s cn; */
};
typedef union cavm_gsercx_lnx_bist_tx_udp_111_104 cavm_gsercx_lnx_bist_tx_udp_111_104_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_UDP_111_104(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_UDP_111_104(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8012d88ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012d88ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_TX_UDP_111_104", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_TX_UDP_111_104(a,b) cavm_gsercx_lnx_bist_tx_udp_111_104_t
#define bustype_CAVM_GSERCX_LNX_BIST_TX_UDP_111_104(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_TX_UDP_111_104(a,b) "GSERCX_LNX_BIST_TX_UDP_111_104"
#define device_bar_CAVM_GSERCX_LNX_BIST_TX_UDP_111_104(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_TX_UDP_111_104(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_TX_UDP_111_104(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_udp_119_112
 *
 * GSERC Ln Bist Tx Udp 119 112 Register
 */
union cavm_gsercx_lnx_bist_tx_udp_119_112
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_tx_udp_119_112_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_tx_udp_119_112_s cn; */
};
typedef union cavm_gsercx_lnx_bist_tx_udp_119_112 cavm_gsercx_lnx_bist_tx_udp_119_112_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_UDP_119_112(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_UDP_119_112(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8012d90ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012d90ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_TX_UDP_119_112", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_TX_UDP_119_112(a,b) cavm_gsercx_lnx_bist_tx_udp_119_112_t
#define bustype_CAVM_GSERCX_LNX_BIST_TX_UDP_119_112(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_TX_UDP_119_112(a,b) "GSERCX_LNX_BIST_TX_UDP_119_112"
#define device_bar_CAVM_GSERCX_LNX_BIST_TX_UDP_119_112(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_TX_UDP_119_112(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_TX_UDP_119_112(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_udp_127_120
 *
 * GSERC Ln Bist Tx Udp 127 120 Register
 */
union cavm_gsercx_lnx_bist_tx_udp_127_120
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_tx_udp_127_120_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_tx_udp_127_120_s cn; */
};
typedef union cavm_gsercx_lnx_bist_tx_udp_127_120 cavm_gsercx_lnx_bist_tx_udp_127_120_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_UDP_127_120(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_UDP_127_120(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8012d98ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012d98ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_TX_UDP_127_120", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_TX_UDP_127_120(a,b) cavm_gsercx_lnx_bist_tx_udp_127_120_t
#define bustype_CAVM_GSERCX_LNX_BIST_TX_UDP_127_120(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_TX_UDP_127_120(a,b) "GSERCX_LNX_BIST_TX_UDP_127_120"
#define device_bar_CAVM_GSERCX_LNX_BIST_TX_UDP_127_120(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_TX_UDP_127_120(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_TX_UDP_127_120(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_udp_135_128
 *
 * GSERC Ln Bist Tx Udp 135 128 Register
 */
union cavm_gsercx_lnx_bist_tx_udp_135_128
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_tx_udp_135_128_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_tx_udp_135_128_s cn; */
};
typedef union cavm_gsercx_lnx_bist_tx_udp_135_128 cavm_gsercx_lnx_bist_tx_udp_135_128_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_UDP_135_128(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_UDP_135_128(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8012da0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012da0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_TX_UDP_135_128", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_TX_UDP_135_128(a,b) cavm_gsercx_lnx_bist_tx_udp_135_128_t
#define bustype_CAVM_GSERCX_LNX_BIST_TX_UDP_135_128(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_TX_UDP_135_128(a,b) "GSERCX_LNX_BIST_TX_UDP_135_128"
#define device_bar_CAVM_GSERCX_LNX_BIST_TX_UDP_135_128(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_TX_UDP_135_128(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_TX_UDP_135_128(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_udp_143_136
 *
 * GSERC Ln Bist Tx Udp 143 136 Register
 */
union cavm_gsercx_lnx_bist_tx_udp_143_136
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_tx_udp_143_136_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_tx_udp_143_136_s cn; */
};
typedef union cavm_gsercx_lnx_bist_tx_udp_143_136 cavm_gsercx_lnx_bist_tx_udp_143_136_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_UDP_143_136(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_UDP_143_136(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8012da8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012da8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_TX_UDP_143_136", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_TX_UDP_143_136(a,b) cavm_gsercx_lnx_bist_tx_udp_143_136_t
#define bustype_CAVM_GSERCX_LNX_BIST_TX_UDP_143_136(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_TX_UDP_143_136(a,b) "GSERCX_LNX_BIST_TX_UDP_143_136"
#define device_bar_CAVM_GSERCX_LNX_BIST_TX_UDP_143_136(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_TX_UDP_143_136(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_TX_UDP_143_136(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_udp_151_144
 *
 * GSERC Ln Bist Tx Udp 151 144 Register
 */
union cavm_gsercx_lnx_bist_tx_udp_151_144
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_tx_udp_151_144_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_tx_udp_151_144_s cn; */
};
typedef union cavm_gsercx_lnx_bist_tx_udp_151_144 cavm_gsercx_lnx_bist_tx_udp_151_144_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_UDP_151_144(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_UDP_151_144(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8012db0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012db0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_TX_UDP_151_144", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_TX_UDP_151_144(a,b) cavm_gsercx_lnx_bist_tx_udp_151_144_t
#define bustype_CAVM_GSERCX_LNX_BIST_TX_UDP_151_144(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_TX_UDP_151_144(a,b) "GSERCX_LNX_BIST_TX_UDP_151_144"
#define device_bar_CAVM_GSERCX_LNX_BIST_TX_UDP_151_144(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_TX_UDP_151_144(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_TX_UDP_151_144(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_udp_159_152
 *
 * GSERC Ln Bist Tx Udp 159 152 Register
 */
union cavm_gsercx_lnx_bist_tx_udp_159_152
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_tx_udp_159_152_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_tx_udp_159_152_s cn; */
};
typedef union cavm_gsercx_lnx_bist_tx_udp_159_152 cavm_gsercx_lnx_bist_tx_udp_159_152_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_UDP_159_152(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_UDP_159_152(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8012db8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012db8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_TX_UDP_159_152", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_TX_UDP_159_152(a,b) cavm_gsercx_lnx_bist_tx_udp_159_152_t
#define bustype_CAVM_GSERCX_LNX_BIST_TX_UDP_159_152(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_TX_UDP_159_152(a,b) "GSERCX_LNX_BIST_TX_UDP_159_152"
#define device_bar_CAVM_GSERCX_LNX_BIST_TX_UDP_159_152(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_TX_UDP_159_152(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_TX_UDP_159_152(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_udp_15_8
 *
 * GSERC Ln Bist Tx Udp 15 8 Register
 */
union cavm_gsercx_lnx_bist_tx_udp_15_8
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_tx_udp_15_8_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_tx_udp_15_8_s cn; */
};
typedef union cavm_gsercx_lnx_bist_tx_udp_15_8 cavm_gsercx_lnx_bist_tx_udp_15_8_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_UDP_15_8(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_UDP_15_8(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8012d28ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012d28ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_TX_UDP_15_8", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_TX_UDP_15_8(a,b) cavm_gsercx_lnx_bist_tx_udp_15_8_t
#define bustype_CAVM_GSERCX_LNX_BIST_TX_UDP_15_8(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_TX_UDP_15_8(a,b) "GSERCX_LNX_BIST_TX_UDP_15_8"
#define device_bar_CAVM_GSERCX_LNX_BIST_TX_UDP_15_8(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_TX_UDP_15_8(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_TX_UDP_15_8(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_udp_167_160
 *
 * GSERC Ln Bist Tx Udp 167 160 Register
 */
union cavm_gsercx_lnx_bist_tx_udp_167_160
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_tx_udp_167_160_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern extension bits. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern extension bits. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_tx_udp_167_160_s cn; */
};
typedef union cavm_gsercx_lnx_bist_tx_udp_167_160 cavm_gsercx_lnx_bist_tx_udp_167_160_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_UDP_167_160(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_UDP_167_160(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8012dc0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012dc0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_TX_UDP_167_160", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_TX_UDP_167_160(a,b) cavm_gsercx_lnx_bist_tx_udp_167_160_t
#define bustype_CAVM_GSERCX_LNX_BIST_TX_UDP_167_160(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_TX_UDP_167_160(a,b) "GSERCX_LNX_BIST_TX_UDP_167_160"
#define device_bar_CAVM_GSERCX_LNX_BIST_TX_UDP_167_160(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_TX_UDP_167_160(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_TX_UDP_167_160(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_udp_175_168
 *
 * GSERC Ln Bist Tx Udp 175 168 Register
 */
union cavm_gsercx_lnx_bist_tx_udp_175_168
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_tx_udp_175_168_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern extension bits. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern extension bits. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_tx_udp_175_168_s cn; */
};
typedef union cavm_gsercx_lnx_bist_tx_udp_175_168 cavm_gsercx_lnx_bist_tx_udp_175_168_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_UDP_175_168(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_UDP_175_168(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8012dc8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012dc8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_TX_UDP_175_168", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_TX_UDP_175_168(a,b) cavm_gsercx_lnx_bist_tx_udp_175_168_t
#define bustype_CAVM_GSERCX_LNX_BIST_TX_UDP_175_168(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_TX_UDP_175_168(a,b) "GSERCX_LNX_BIST_TX_UDP_175_168"
#define device_bar_CAVM_GSERCX_LNX_BIST_TX_UDP_175_168(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_TX_UDP_175_168(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_TX_UDP_175_168(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_udp_183_176
 *
 * GSERC Ln Bist Tx Udp 183 176 Register
 */
union cavm_gsercx_lnx_bist_tx_udp_183_176
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_tx_udp_183_176_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern extension bits. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern extension bits. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_tx_udp_183_176_s cn; */
};
typedef union cavm_gsercx_lnx_bist_tx_udp_183_176 cavm_gsercx_lnx_bist_tx_udp_183_176_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_UDP_183_176(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_UDP_183_176(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8012dd0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012dd0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_TX_UDP_183_176", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_TX_UDP_183_176(a,b) cavm_gsercx_lnx_bist_tx_udp_183_176_t
#define bustype_CAVM_GSERCX_LNX_BIST_TX_UDP_183_176(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_TX_UDP_183_176(a,b) "GSERCX_LNX_BIST_TX_UDP_183_176"
#define device_bar_CAVM_GSERCX_LNX_BIST_TX_UDP_183_176(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_TX_UDP_183_176(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_TX_UDP_183_176(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_udp_191_184
 *
 * GSERC Ln Bist Tx Udp 191 184 Register
 */
union cavm_gsercx_lnx_bist_tx_udp_191_184
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_tx_udp_191_184_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern extension bits. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern extension bits. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_tx_udp_191_184_s cn; */
};
typedef union cavm_gsercx_lnx_bist_tx_udp_191_184 cavm_gsercx_lnx_bist_tx_udp_191_184_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_UDP_191_184(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_UDP_191_184(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8012dd8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012dd8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_TX_UDP_191_184", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_TX_UDP_191_184(a,b) cavm_gsercx_lnx_bist_tx_udp_191_184_t
#define bustype_CAVM_GSERCX_LNX_BIST_TX_UDP_191_184(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_TX_UDP_191_184(a,b) "GSERCX_LNX_BIST_TX_UDP_191_184"
#define device_bar_CAVM_GSERCX_LNX_BIST_TX_UDP_191_184(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_TX_UDP_191_184(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_TX_UDP_191_184(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_udp_199_192
 *
 * GSERC Ln Bist Tx Udp 199 192 Register
 */
union cavm_gsercx_lnx_bist_tx_udp_199_192
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_tx_udp_199_192_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern extension bits. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern extension bits. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_tx_udp_199_192_s cn; */
};
typedef union cavm_gsercx_lnx_bist_tx_udp_199_192 cavm_gsercx_lnx_bist_tx_udp_199_192_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_UDP_199_192(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_UDP_199_192(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8012de0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012de0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_TX_UDP_199_192", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_TX_UDP_199_192(a,b) cavm_gsercx_lnx_bist_tx_udp_199_192_t
#define bustype_CAVM_GSERCX_LNX_BIST_TX_UDP_199_192(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_TX_UDP_199_192(a,b) "GSERCX_LNX_BIST_TX_UDP_199_192"
#define device_bar_CAVM_GSERCX_LNX_BIST_TX_UDP_199_192(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_TX_UDP_199_192(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_TX_UDP_199_192(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_udp_23_16
 *
 * GSERC Ln Bist Tx Udp 23 16 Register
 */
union cavm_gsercx_lnx_bist_tx_udp_23_16
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_tx_udp_23_16_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_tx_udp_23_16_s cn; */
};
typedef union cavm_gsercx_lnx_bist_tx_udp_23_16 cavm_gsercx_lnx_bist_tx_udp_23_16_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_UDP_23_16(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_UDP_23_16(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8012d30ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012d30ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_TX_UDP_23_16", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_TX_UDP_23_16(a,b) cavm_gsercx_lnx_bist_tx_udp_23_16_t
#define bustype_CAVM_GSERCX_LNX_BIST_TX_UDP_23_16(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_TX_UDP_23_16(a,b) "GSERCX_LNX_BIST_TX_UDP_23_16"
#define device_bar_CAVM_GSERCX_LNX_BIST_TX_UDP_23_16(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_TX_UDP_23_16(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_TX_UDP_23_16(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_udp_31_24
 *
 * GSERC Ln Bist Tx Udp 31 24 Register
 */
union cavm_gsercx_lnx_bist_tx_udp_31_24
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_tx_udp_31_24_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_tx_udp_31_24_s cn; */
};
typedef union cavm_gsercx_lnx_bist_tx_udp_31_24 cavm_gsercx_lnx_bist_tx_udp_31_24_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_UDP_31_24(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_UDP_31_24(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8012d38ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012d38ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_TX_UDP_31_24", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_TX_UDP_31_24(a,b) cavm_gsercx_lnx_bist_tx_udp_31_24_t
#define bustype_CAVM_GSERCX_LNX_BIST_TX_UDP_31_24(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_TX_UDP_31_24(a,b) "GSERCX_LNX_BIST_TX_UDP_31_24"
#define device_bar_CAVM_GSERCX_LNX_BIST_TX_UDP_31_24(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_TX_UDP_31_24(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_TX_UDP_31_24(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_udp_39_32
 *
 * GSERC Ln Bist Tx Udp 39 32 Register
 */
union cavm_gsercx_lnx_bist_tx_udp_39_32
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_tx_udp_39_32_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_tx_udp_39_32_s cn; */
};
typedef union cavm_gsercx_lnx_bist_tx_udp_39_32 cavm_gsercx_lnx_bist_tx_udp_39_32_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_UDP_39_32(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_UDP_39_32(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8012d40ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012d40ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_TX_UDP_39_32", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_TX_UDP_39_32(a,b) cavm_gsercx_lnx_bist_tx_udp_39_32_t
#define bustype_CAVM_GSERCX_LNX_BIST_TX_UDP_39_32(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_TX_UDP_39_32(a,b) "GSERCX_LNX_BIST_TX_UDP_39_32"
#define device_bar_CAVM_GSERCX_LNX_BIST_TX_UDP_39_32(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_TX_UDP_39_32(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_TX_UDP_39_32(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_udp_47_40
 *
 * GSERC Ln Bist Tx Udp 47 40 Register
 */
union cavm_gsercx_lnx_bist_tx_udp_47_40
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_tx_udp_47_40_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_tx_udp_47_40_s cn; */
};
typedef union cavm_gsercx_lnx_bist_tx_udp_47_40 cavm_gsercx_lnx_bist_tx_udp_47_40_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_UDP_47_40(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_UDP_47_40(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8012d48ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012d48ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_TX_UDP_47_40", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_TX_UDP_47_40(a,b) cavm_gsercx_lnx_bist_tx_udp_47_40_t
#define bustype_CAVM_GSERCX_LNX_BIST_TX_UDP_47_40(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_TX_UDP_47_40(a,b) "GSERCX_LNX_BIST_TX_UDP_47_40"
#define device_bar_CAVM_GSERCX_LNX_BIST_TX_UDP_47_40(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_TX_UDP_47_40(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_TX_UDP_47_40(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_udp_55_48
 *
 * GSERC Ln Bist Tx Udp 55 48 Register
 */
union cavm_gsercx_lnx_bist_tx_udp_55_48
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_tx_udp_55_48_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_tx_udp_55_48_s cn; */
};
typedef union cavm_gsercx_lnx_bist_tx_udp_55_48 cavm_gsercx_lnx_bist_tx_udp_55_48_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_UDP_55_48(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_UDP_55_48(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8012d50ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012d50ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_TX_UDP_55_48", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_TX_UDP_55_48(a,b) cavm_gsercx_lnx_bist_tx_udp_55_48_t
#define bustype_CAVM_GSERCX_LNX_BIST_TX_UDP_55_48(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_TX_UDP_55_48(a,b) "GSERCX_LNX_BIST_TX_UDP_55_48"
#define device_bar_CAVM_GSERCX_LNX_BIST_TX_UDP_55_48(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_TX_UDP_55_48(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_TX_UDP_55_48(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_udp_63_56
 *
 * GSERC Ln Bist Tx Udp 63 56 Register
 */
union cavm_gsercx_lnx_bist_tx_udp_63_56
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_tx_udp_63_56_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_tx_udp_63_56_s cn; */
};
typedef union cavm_gsercx_lnx_bist_tx_udp_63_56 cavm_gsercx_lnx_bist_tx_udp_63_56_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_UDP_63_56(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_UDP_63_56(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8012d58ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012d58ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_TX_UDP_63_56", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_TX_UDP_63_56(a,b) cavm_gsercx_lnx_bist_tx_udp_63_56_t
#define bustype_CAVM_GSERCX_LNX_BIST_TX_UDP_63_56(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_TX_UDP_63_56(a,b) "GSERCX_LNX_BIST_TX_UDP_63_56"
#define device_bar_CAVM_GSERCX_LNX_BIST_TX_UDP_63_56(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_TX_UDP_63_56(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_TX_UDP_63_56(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_udp_71_64
 *
 * GSERC Ln Bist Tx Udp 71 64 Register
 */
union cavm_gsercx_lnx_bist_tx_udp_71_64
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_tx_udp_71_64_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_tx_udp_71_64_s cn; */
};
typedef union cavm_gsercx_lnx_bist_tx_udp_71_64 cavm_gsercx_lnx_bist_tx_udp_71_64_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_UDP_71_64(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_UDP_71_64(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8012d60ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012d60ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_TX_UDP_71_64", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_TX_UDP_71_64(a,b) cavm_gsercx_lnx_bist_tx_udp_71_64_t
#define bustype_CAVM_GSERCX_LNX_BIST_TX_UDP_71_64(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_TX_UDP_71_64(a,b) "GSERCX_LNX_BIST_TX_UDP_71_64"
#define device_bar_CAVM_GSERCX_LNX_BIST_TX_UDP_71_64(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_TX_UDP_71_64(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_TX_UDP_71_64(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_udp_79_72
 *
 * GSERC Ln Bist Tx Udp 79 72 Register
 */
union cavm_gsercx_lnx_bist_tx_udp_79_72
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_tx_udp_79_72_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_tx_udp_79_72_s cn; */
};
typedef union cavm_gsercx_lnx_bist_tx_udp_79_72 cavm_gsercx_lnx_bist_tx_udp_79_72_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_UDP_79_72(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_UDP_79_72(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8012d68ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012d68ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_TX_UDP_79_72", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_TX_UDP_79_72(a,b) cavm_gsercx_lnx_bist_tx_udp_79_72_t
#define bustype_CAVM_GSERCX_LNX_BIST_TX_UDP_79_72(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_TX_UDP_79_72(a,b) "GSERCX_LNX_BIST_TX_UDP_79_72"
#define device_bar_CAVM_GSERCX_LNX_BIST_TX_UDP_79_72(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_TX_UDP_79_72(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_TX_UDP_79_72(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_udp_7_0
 *
 * GSERC Ln Bist Tx Udp 7 0 Register
 */
union cavm_gsercx_lnx_bist_tx_udp_7_0
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_tx_udp_7_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_tx_udp_7_0_s cn; */
};
typedef union cavm_gsercx_lnx_bist_tx_udp_7_0 cavm_gsercx_lnx_bist_tx_udp_7_0_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_UDP_7_0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_UDP_7_0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8012d20ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012d20ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_TX_UDP_7_0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_TX_UDP_7_0(a,b) cavm_gsercx_lnx_bist_tx_udp_7_0_t
#define bustype_CAVM_GSERCX_LNX_BIST_TX_UDP_7_0(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_TX_UDP_7_0(a,b) "GSERCX_LNX_BIST_TX_UDP_7_0"
#define device_bar_CAVM_GSERCX_LNX_BIST_TX_UDP_7_0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_TX_UDP_7_0(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_TX_UDP_7_0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_udp_87_80
 *
 * GSERC Ln Bist Tx Udp 87 80 Register
 */
union cavm_gsercx_lnx_bist_tx_udp_87_80
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_tx_udp_87_80_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_tx_udp_87_80_s cn; */
};
typedef union cavm_gsercx_lnx_bist_tx_udp_87_80 cavm_gsercx_lnx_bist_tx_udp_87_80_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_UDP_87_80(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_UDP_87_80(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8012d70ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012d70ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_TX_UDP_87_80", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_TX_UDP_87_80(a,b) cavm_gsercx_lnx_bist_tx_udp_87_80_t
#define bustype_CAVM_GSERCX_LNX_BIST_TX_UDP_87_80(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_TX_UDP_87_80(a,b) "GSERCX_LNX_BIST_TX_UDP_87_80"
#define device_bar_CAVM_GSERCX_LNX_BIST_TX_UDP_87_80(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_TX_UDP_87_80(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_TX_UDP_87_80(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_udp_95_88
 *
 * GSERC Ln Bist Tx Udp 95 88 Register
 */
union cavm_gsercx_lnx_bist_tx_udp_95_88
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_tx_udp_95_88_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_tx_udp_95_88_s cn; */
};
typedef union cavm_gsercx_lnx_bist_tx_udp_95_88 cavm_gsercx_lnx_bist_tx_udp_95_88_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_UDP_95_88(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_UDP_95_88(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8012d78ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012d78ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_TX_UDP_95_88", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_TX_UDP_95_88(a,b) cavm_gsercx_lnx_bist_tx_udp_95_88_t
#define bustype_CAVM_GSERCX_LNX_BIST_TX_UDP_95_88(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_TX_UDP_95_88(a,b) "GSERCX_LNX_BIST_TX_UDP_95_88"
#define device_bar_CAVM_GSERCX_LNX_BIST_TX_UDP_95_88(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_TX_UDP_95_88(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_TX_UDP_95_88(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_udp_shift_amount
 *
 * GSERC Ln Bist Tx Udp Shift Amount Register
 */
union cavm_gsercx_lnx_bist_tx_udp_shift_amount
{
    uint32_t u;
    struct cavm_gsercx_lnx_bist_tx_udp_shift_amount_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Determines the length of the UDP.  Must be set to d160 modulus udp_length. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Determines the length of the UDP.  Must be set to d160 modulus udp_length. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_bist_tx_udp_shift_amount_s cn; */
};
typedef union cavm_gsercx_lnx_bist_tx_udp_shift_amount cavm_gsercx_lnx_bist_tx_udp_shift_amount_t;

static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_UDP_SHIFT_AMOUNT(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_BIST_TX_UDP_SHIFT_AMOUNT(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8012d00ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012d00ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_BIST_TX_UDP_SHIFT_AMOUNT", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_BIST_TX_UDP_SHIFT_AMOUNT(a,b) cavm_gsercx_lnx_bist_tx_udp_shift_amount_t
#define bustype_CAVM_GSERCX_LNX_BIST_TX_UDP_SHIFT_AMOUNT(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_BIST_TX_UDP_SHIFT_AMOUNT(a,b) "GSERCX_LNX_BIST_TX_UDP_SHIFT_AMOUNT"
#define device_bar_CAVM_GSERCX_LNX_BIST_TX_UDP_SHIFT_AMOUNT(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_BIST_TX_UDP_SHIFT_AMOUNT(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_BIST_TX_UDP_SHIFT_AMOUNT(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_refclk_afe_cal_ctrl1
 *
 * GSERC Ln Cdr Refclk Afe Cal Ctrl1 Register
 */
union cavm_gsercx_lnx_cdr_refclk_afe_cal_ctrl1
{
    uint32_t u;
    struct cavm_gsercx_lnx_cdr_refclk_afe_cal_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t rxcdr_vcocal_load_val_11_8 : 4;/**< [  3:  0](R/W/H) CDR VCO calibration frequency counter load value aka starting value. MSB bits of 12-bit load value.
                                                                 This register is configured by firmware at PHY initialization based on data rate
                                                                 and PHY mode determined by top-level interface pins. It is then used during the
                                                                 PHY RESET--    ACTIVE power state as part of CDR VCO frequency calibration. */
#else /* Word 0 - Little Endian */
        uint32_t rxcdr_vcocal_load_val_11_8 : 4;/**< [  3:  0](R/W/H) CDR VCO calibration frequency counter load value aka starting value. MSB bits of 12-bit load value.
                                                                 This register is configured by firmware at PHY initialization based on data rate
                                                                 and PHY mode determined by top-level interface pins. It is then used during the
                                                                 PHY RESET--    ACTIVE power state as part of CDR VCO frequency calibration. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_cdr_refclk_afe_cal_ctrl1_s cn; */
};
typedef union cavm_gsercx_lnx_cdr_refclk_afe_cal_ctrl1 cavm_gsercx_lnx_cdr_refclk_afe_cal_ctrl1_t;

static inline uint64_t CAVM_GSERCX_LNX_CDR_REFCLK_AFE_CAL_CTRL1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_CDR_REFCLK_AFE_CAL_CTRL1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8010908ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010908ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_CDR_REFCLK_AFE_CAL_CTRL1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_CDR_REFCLK_AFE_CAL_CTRL1(a,b) cavm_gsercx_lnx_cdr_refclk_afe_cal_ctrl1_t
#define bustype_CAVM_GSERCX_LNX_CDR_REFCLK_AFE_CAL_CTRL1(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_CDR_REFCLK_AFE_CAL_CTRL1(a,b) "GSERCX_LNX_CDR_REFCLK_AFE_CAL_CTRL1"
#define device_bar_CAVM_GSERCX_LNX_CDR_REFCLK_AFE_CAL_CTRL1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_CDR_REFCLK_AFE_CAL_CTRL1(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_CDR_REFCLK_AFE_CAL_CTRL1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_refclk_afe_cal_ctrl2
 *
 * GSERC Ln Cdr Refclk Afe Cal Ctrl2 Register
 */
union cavm_gsercx_lnx_cdr_refclk_afe_cal_ctrl2
{
    uint32_t u;
    struct cavm_gsercx_lnx_cdr_refclk_afe_cal_ctrl2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t rxcdr_vcocal_load_val_7_0 : 8;/**< [  7:  0](R/W/H) CDR VCO calibration frequency counter load value aka starting value. LSB bits of 12-bit load value.
                                                                 This register is configured by firmware at PHY initialization based on data rate
                                                                 and PHY mode determined by top-level interface pins. It is then used during the
                                                                 PHY RESET--    ACTIVE power state as part of CDR VCO frequency calibration. */
#else /* Word 0 - Little Endian */
        uint32_t rxcdr_vcocal_load_val_7_0 : 8;/**< [  7:  0](R/W/H) CDR VCO calibration frequency counter load value aka starting value. LSB bits of 12-bit load value.
                                                                 This register is configured by firmware at PHY initialization based on data rate
                                                                 and PHY mode determined by top-level interface pins. It is then used during the
                                                                 PHY RESET--    ACTIVE power state as part of CDR VCO frequency calibration. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_cdr_refclk_afe_cal_ctrl2_s cn; */
};
typedef union cavm_gsercx_lnx_cdr_refclk_afe_cal_ctrl2 cavm_gsercx_lnx_cdr_refclk_afe_cal_ctrl2_t;

static inline uint64_t CAVM_GSERCX_LNX_CDR_REFCLK_AFE_CAL_CTRL2(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_CDR_REFCLK_AFE_CAL_CTRL2(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8010910ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010910ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_CDR_REFCLK_AFE_CAL_CTRL2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_CDR_REFCLK_AFE_CAL_CTRL2(a,b) cavm_gsercx_lnx_cdr_refclk_afe_cal_ctrl2_t
#define bustype_CAVM_GSERCX_LNX_CDR_REFCLK_AFE_CAL_CTRL2(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_CDR_REFCLK_AFE_CAL_CTRL2(a,b) "GSERCX_LNX_CDR_REFCLK_AFE_CAL_CTRL2"
#define device_bar_CAVM_GSERCX_LNX_CDR_REFCLK_AFE_CAL_CTRL2(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_CDR_REFCLK_AFE_CAL_CTRL2(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_CDR_REFCLK_AFE_CAL_CTRL2(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_refclk_afe_ctrl0
 *
 * GSERC Ln Cdr Refclk Afe Ctrl0 Register
 */
union cavm_gsercx_lnx_cdr_refclk_afe_ctrl0
{
    uint32_t u;
    struct cavm_gsercx_lnx_cdr_refclk_afe_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t rxcdr_clkdiv          : 2;  /**< [  6:  5](R/W/H) Control for CDR clock divider
                                                                 0 = DIV1
                                                                 1 = DIV2
                                                                 2 = DIV4
                                                                 3 = DIV8
                                                                 This register is configured by firmware at PHY initialization based on data rate
                                                                 and PHY mode determined by top-level interface pins. It may then later by
                                                                 adjusted by firmware during the RESET--      ACTIVE power state sequence during
                                                                 CDR VCO frequency calibration. This occurs only if frequency calibration at the
                                                                 starting division setting is not able to reach the target VCO frequency. */
        uint32_t rxcdr_bbstep          : 5;  /**< [  4:  0](R/W/H) CDR proportional path gain adjustment.
                                                                 This signal controls the bang-bang step size of the CDR phase detector, which
                                                                 acts as a proportional path gain adjustment. */
#else /* Word 0 - Little Endian */
        uint32_t rxcdr_bbstep          : 5;  /**< [  4:  0](R/W/H) CDR proportional path gain adjustment.
                                                                 This signal controls the bang-bang step size of the CDR phase detector, which
                                                                 acts as a proportional path gain adjustment. */
        uint32_t rxcdr_clkdiv          : 2;  /**< [  6:  5](R/W/H) Control for CDR clock divider
                                                                 0 = DIV1
                                                                 1 = DIV2
                                                                 2 = DIV4
                                                                 3 = DIV8
                                                                 This register is configured by firmware at PHY initialization based on data rate
                                                                 and PHY mode determined by top-level interface pins. It may then later by
                                                                 adjusted by firmware during the RESET--      ACTIVE power state sequence during
                                                                 CDR VCO frequency calibration. This occurs only if frequency calibration at the
                                                                 starting division setting is not able to reach the target VCO frequency. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_cdr_refclk_afe_ctrl0_s cn; */
};
typedef union cavm_gsercx_lnx_cdr_refclk_afe_ctrl0 cavm_gsercx_lnx_cdr_refclk_afe_ctrl0_t;

static inline uint64_t CAVM_GSERCX_LNX_CDR_REFCLK_AFE_CTRL0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_CDR_REFCLK_AFE_CTRL0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8010880ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010880ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_CDR_REFCLK_AFE_CTRL0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_CDR_REFCLK_AFE_CTRL0(a,b) cavm_gsercx_lnx_cdr_refclk_afe_ctrl0_t
#define bustype_CAVM_GSERCX_LNX_CDR_REFCLK_AFE_CTRL0(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_CDR_REFCLK_AFE_CTRL0(a,b) "GSERCX_LNX_CDR_REFCLK_AFE_CTRL0"
#define device_bar_CAVM_GSERCX_LNX_CDR_REFCLK_AFE_CTRL0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_CDR_REFCLK_AFE_CTRL0(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_CDR_REFCLK_AFE_CTRL0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_refclk_afe_ctrl1_rsvd
 *
 * INTERNAL: GSERC Ln Cdr Refclk Afe Ctrl1 Register
 */
union cavm_gsercx_lnx_cdr_refclk_afe_ctrl1_rsvd
{
    uint32_t u;
    struct cavm_gsercx_lnx_cdr_refclk_afe_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t rxcdr_spare           : 4;  /**< [  6:  3](R/W/H) Reserved. */
        uint32_t rxcdr_toggle_en       : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t rxcdr_clkdiv_swing    : 2;  /**< [  1:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t rxcdr_clkdiv_swing    : 2;  /**< [  1:  0](R/W/H) Reserved. */
        uint32_t rxcdr_toggle_en       : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t rxcdr_spare           : 4;  /**< [  6:  3](R/W/H) Reserved. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_cdr_refclk_afe_ctrl1_rsvd_s cn; */
};
typedef union cavm_gsercx_lnx_cdr_refclk_afe_ctrl1_rsvd cavm_gsercx_lnx_cdr_refclk_afe_ctrl1_rsvd_t;

static inline uint64_t CAVM_GSERCX_LNX_CDR_REFCLK_AFE_CTRL1_RSVD(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_CDR_REFCLK_AFE_CTRL1_RSVD(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8010888ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010888ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_CDR_REFCLK_AFE_CTRL1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_CDR_REFCLK_AFE_CTRL1_RSVD(a,b) cavm_gsercx_lnx_cdr_refclk_afe_ctrl1_rsvd_t
#define bustype_CAVM_GSERCX_LNX_CDR_REFCLK_AFE_CTRL1_RSVD(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_CDR_REFCLK_AFE_CTRL1_RSVD(a,b) "GSERCX_LNX_CDR_REFCLK_AFE_CTRL1_RSVD"
#define device_bar_CAVM_GSERCX_LNX_CDR_REFCLK_AFE_CTRL1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_CDR_REFCLK_AFE_CTRL1_RSVD(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_CDR_REFCLK_AFE_CTRL1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_refclk_afe_pi_ctrl0
 *
 * GSERC Ln Cdr Refclk Afe Pi Ctrl0 Register
 */
union cavm_gsercx_lnx_cdr_refclk_afe_pi_ctrl0
{
    uint32_t u;
    struct cavm_gsercx_lnx_cdr_refclk_afe_pi_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t src_sel               : 1;  /**< [  7:  7](R/W/H) Mux select for rxcdr_hsacn_clkq input to AFE.
                                                                 0 = rxcdr_hscan_clkq fields of this register drive AFE
                                                                 1 = calibration block directly drives AFE */
        uint32_t rxcdr_hscan_clkq      : 7;  /**< [  6:  0](R/W/H) Horizontal scan control setting for CDR quadrature clock. This adjusts the in-
                                                                 phase to quadrature clock relationship, which in turn adjusts the timing between
                                                                 the DFE data and edge slicers.
                                                                 This register is controlled by firmware during the RESET--      ACTIVE power
                                                                 state sequence as part of CDR I/Q calibration. It may then also be controlled by
                                                                 firmware once the PHY is in the ACTIVE power state if CDR sampling phase
                                                                 adaptation is enabled. */
#else /* Word 0 - Little Endian */
        uint32_t rxcdr_hscan_clkq      : 7;  /**< [  6:  0](R/W/H) Horizontal scan control setting for CDR quadrature clock. This adjusts the in-
                                                                 phase to quadrature clock relationship, which in turn adjusts the timing between
                                                                 the DFE data and edge slicers.
                                                                 This register is controlled by firmware during the RESET--      ACTIVE power
                                                                 state sequence as part of CDR I/Q calibration. It may then also be controlled by
                                                                 firmware once the PHY is in the ACTIVE power state if CDR sampling phase
                                                                 adaptation is enabled. */
        uint32_t src_sel               : 1;  /**< [  7:  7](R/W/H) Mux select for rxcdr_hsacn_clkq input to AFE.
                                                                 0 = rxcdr_hscan_clkq fields of this register drive AFE
                                                                 1 = calibration block directly drives AFE */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_cdr_refclk_afe_pi_ctrl0_s cn; */
};
typedef union cavm_gsercx_lnx_cdr_refclk_afe_pi_ctrl0 cavm_gsercx_lnx_cdr_refclk_afe_pi_ctrl0_t;

static inline uint64_t CAVM_GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a80108c0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80108c0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL0(a,b) cavm_gsercx_lnx_cdr_refclk_afe_pi_ctrl0_t
#define bustype_CAVM_GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL0(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL0(a,b) "GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL0"
#define device_bar_CAVM_GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL0(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_refclk_afe_pi_ctrl1
 *
 * GSERC Ln Cdr Refclk Afe Pi Ctrl1 Register
 */
union cavm_gsercx_lnx_cdr_refclk_afe_pi_ctrl1
{
    uint32_t u;
    struct cavm_gsercx_lnx_cdr_refclk_afe_pi_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t src_sel               : 1;  /**< [  7:  7](R/W/H) Mux select for rxcdr_hsacn_clki input to AFE.
                                                                 0 = rxcdr_hscan_clki fields of this register drive AFE
                                                                 1 = calibration block directly drives AFE */
        uint32_t rxcdr_hscan_clki      : 7;  /**< [  6:  0](R/W/H) Horizontal scan control setting for CDR in-phase clock. This adjusts the in-
                                                                 phase to quadrature clock relationship, which in turn adjusts the timing between
                                                                 the DFE data and edge slicers.
                                                                 This register is controlled by firmware during the RESET--      ACTIVE power
                                                                 state sequence as part of CDR I/Q calibration. It may then also be controlled by
                                                                 firmware once the PHY is in the ACTIVE power state if CDR sampling phase
                                                                 adaptation is enabled. */
#else /* Word 0 - Little Endian */
        uint32_t rxcdr_hscan_clki      : 7;  /**< [  6:  0](R/W/H) Horizontal scan control setting for CDR in-phase clock. This adjusts the in-
                                                                 phase to quadrature clock relationship, which in turn adjusts the timing between
                                                                 the DFE data and edge slicers.
                                                                 This register is controlled by firmware during the RESET--      ACTIVE power
                                                                 state sequence as part of CDR I/Q calibration. It may then also be controlled by
                                                                 firmware once the PHY is in the ACTIVE power state if CDR sampling phase
                                                                 adaptation is enabled. */
        uint32_t src_sel               : 1;  /**< [  7:  7](R/W/H) Mux select for rxcdr_hsacn_clki input to AFE.
                                                                 0 = rxcdr_hscan_clki fields of this register drive AFE
                                                                 1 = calibration block directly drives AFE */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_cdr_refclk_afe_pi_ctrl1_s cn; */
};
typedef union cavm_gsercx_lnx_cdr_refclk_afe_pi_ctrl1 cavm_gsercx_lnx_cdr_refclk_afe_pi_ctrl1_t;

static inline uint64_t CAVM_GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a80108c8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80108c8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL1(a,b) cavm_gsercx_lnx_cdr_refclk_afe_pi_ctrl1_t
#define bustype_CAVM_GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL1(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL1(a,b) "GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL1"
#define device_bar_CAVM_GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL1(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_refclk_afe_pi_ctrl2
 *
 * GSERC Ln Cdr Refclk Afe Pi Ctrl2 Register
 */
union cavm_gsercx_lnx_cdr_refclk_afe_pi_ctrl2
{
    uint32_t u;
    struct cavm_gsercx_lnx_cdr_refclk_afe_pi_ctrl2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t rxcdr_hscan_eye       : 7;  /**< [  6:  0](R/W/H) Horizontal scan control setting for CDR eye monitor clock.
                                                                 This register is controlled by firmware during the RESET--      ACTIVE power
                                                                 state sequence, as part of some AFE calibrations. It may thenalso be controlled
                                                                 by firmware once the PHY is in the ACTIVE power state as part of some adaptive
                                                                 equalization algorithms if they are enabled, or part of an eye monitor or eye
                                                                 monitor LOS operation. */
#else /* Word 0 - Little Endian */
        uint32_t rxcdr_hscan_eye       : 7;  /**< [  6:  0](R/W/H) Horizontal scan control setting for CDR eye monitor clock.
                                                                 This register is controlled by firmware during the RESET--      ACTIVE power
                                                                 state sequence, as part of some AFE calibrations. It may thenalso be controlled
                                                                 by firmware once the PHY is in the ACTIVE power state as part of some adaptive
                                                                 equalization algorithms if they are enabled, or part of an eye monitor or eye
                                                                 monitor LOS operation. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_cdr_refclk_afe_pi_ctrl2_s cn; */
};
typedef union cavm_gsercx_lnx_cdr_refclk_afe_pi_ctrl2 cavm_gsercx_lnx_cdr_refclk_afe_pi_ctrl2_t;

static inline uint64_t CAVM_GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL2(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL2(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a80108d0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80108d0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL2(a,b) cavm_gsercx_lnx_cdr_refclk_afe_pi_ctrl2_t
#define bustype_CAVM_GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL2(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL2(a,b) "GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL2"
#define device_bar_CAVM_GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL2(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL2(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL2(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_refclk_afe_pi_ctrl3_rsvd
 *
 * INTERNAL: GSERC Ln Cdr Refclk Afe Pi Ctrl3 Register
 */
union cavm_gsercx_lnx_cdr_refclk_afe_pi_ctrl3_rsvd
{
    uint32_t u;
    struct cavm_gsercx_lnx_cdr_refclk_afe_pi_ctrl3_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t rxcdr_pi_swing        : 2;  /**< [  1:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t rxcdr_pi_swing        : 2;  /**< [  1:  0](R/W/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_cdr_refclk_afe_pi_ctrl3_rsvd_s cn; */
};
typedef union cavm_gsercx_lnx_cdr_refclk_afe_pi_ctrl3_rsvd cavm_gsercx_lnx_cdr_refclk_afe_pi_ctrl3_rsvd_t;

static inline uint64_t CAVM_GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL3_RSVD(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL3_RSVD(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a80108d8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80108d8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL3_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL3_RSVD(a,b) cavm_gsercx_lnx_cdr_refclk_afe_pi_ctrl3_rsvd_t
#define bustype_CAVM_GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL3_RSVD(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL3_RSVD(a,b) "GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL3_RSVD"
#define device_bar_CAVM_GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL3_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL3_RSVD(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL3_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_refclk_cdr_vcocal_ctrl0
 *
 * GSERC Ln Cdr Refclk Cdr Vcocal Ctrl0 Register
 */
union cavm_gsercx_lnx_cdr_refclk_cdr_vcocal_ctrl0
{
    uint32_t u;
    struct cavm_gsercx_lnx_cdr_refclk_cdr_vcocal_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t timing_window_15_8    : 8;  /**< [  7:  0](R/W/H) CDR VCO frequency calibraiton timing window. MSB of 16-bit value. */
#else /* Word 0 - Little Endian */
        uint32_t timing_window_15_8    : 8;  /**< [  7:  0](R/W/H) CDR VCO frequency calibraiton timing window. MSB of 16-bit value. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_cdr_refclk_cdr_vcocal_ctrl0_s cn; */
};
typedef union cavm_gsercx_lnx_cdr_refclk_cdr_vcocal_ctrl0 cavm_gsercx_lnx_cdr_refclk_cdr_vcocal_ctrl0_t;

static inline uint64_t CAVM_GSERCX_LNX_CDR_REFCLK_CDR_VCOCAL_CTRL0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_CDR_REFCLK_CDR_VCOCAL_CTRL0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8010918ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010918ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_CDR_REFCLK_CDR_VCOCAL_CTRL0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_CDR_REFCLK_CDR_VCOCAL_CTRL0(a,b) cavm_gsercx_lnx_cdr_refclk_cdr_vcocal_ctrl0_t
#define bustype_CAVM_GSERCX_LNX_CDR_REFCLK_CDR_VCOCAL_CTRL0(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_CDR_REFCLK_CDR_VCOCAL_CTRL0(a,b) "GSERCX_LNX_CDR_REFCLK_CDR_VCOCAL_CTRL0"
#define device_bar_CAVM_GSERCX_LNX_CDR_REFCLK_CDR_VCOCAL_CTRL0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_CDR_REFCLK_CDR_VCOCAL_CTRL0(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_CDR_REFCLK_CDR_VCOCAL_CTRL0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_refclk_cdr_vcocal_ctrl1
 *
 * GSERC Ln Cdr Refclk Cdr Vcocal Ctrl1 Register
 */
union cavm_gsercx_lnx_cdr_refclk_cdr_vcocal_ctrl1
{
    uint32_t u;
    struct cavm_gsercx_lnx_cdr_refclk_cdr_vcocal_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t timing_window_7_0     : 8;  /**< [  7:  0](R/W/H) CDR VCO frequency calibraiton timing window. LSB of 16-bit value. */
#else /* Word 0 - Little Endian */
        uint32_t timing_window_7_0     : 8;  /**< [  7:  0](R/W/H) CDR VCO frequency calibraiton timing window. LSB of 16-bit value. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_cdr_refclk_cdr_vcocal_ctrl1_s cn; */
};
typedef union cavm_gsercx_lnx_cdr_refclk_cdr_vcocal_ctrl1 cavm_gsercx_lnx_cdr_refclk_cdr_vcocal_ctrl1_t;

static inline uint64_t CAVM_GSERCX_LNX_CDR_REFCLK_CDR_VCOCAL_CTRL1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_CDR_REFCLK_CDR_VCOCAL_CTRL1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8010920ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010920ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_CDR_REFCLK_CDR_VCOCAL_CTRL1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_CDR_REFCLK_CDR_VCOCAL_CTRL1(a,b) cavm_gsercx_lnx_cdr_refclk_cdr_vcocal_ctrl1_t
#define bustype_CAVM_GSERCX_LNX_CDR_REFCLK_CDR_VCOCAL_CTRL1(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_CDR_REFCLK_CDR_VCOCAL_CTRL1(a,b) "GSERCX_LNX_CDR_REFCLK_CDR_VCOCAL_CTRL1"
#define device_bar_CAVM_GSERCX_LNX_CDR_REFCLK_CDR_VCOCAL_CTRL1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_CDR_REFCLK_CDR_VCOCAL_CTRL1(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_CDR_REFCLK_CDR_VCOCAL_CTRL1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_rxclk_dlpf_ctrl0
 *
 * GSERC Ln Cdr Rxclk Dlpf Ctrl0 Register
 */
union cavm_gsercx_lnx_cdr_rxclk_dlpf_ctrl0
{
    uint32_t u;
    struct cavm_gsercx_lnx_cdr_rxclk_dlpf_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t num_dither_bits       : 4;  /**< [  3:  0](R/W/H) CDR integral path gain control.
                                                                 Controls the number of dither bits in the digital low-pass filter DLPF accumulator. */
#else /* Word 0 - Little Endian */
        uint32_t num_dither_bits       : 4;  /**< [  3:  0](R/W/H) CDR integral path gain control.
                                                                 Controls the number of dither bits in the digital low-pass filter DLPF accumulator. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_cdr_rxclk_dlpf_ctrl0_s cn; */
};
typedef union cavm_gsercx_lnx_cdr_rxclk_dlpf_ctrl0 cavm_gsercx_lnx_cdr_rxclk_dlpf_ctrl0_t;

static inline uint64_t CAVM_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8010580ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010580ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_CDR_RXCLK_DLPF_CTRL0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL0(a,b) cavm_gsercx_lnx_cdr_rxclk_dlpf_ctrl0_t
#define bustype_CAVM_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL0(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL0(a,b) "GSERCX_LNX_CDR_RXCLK_DLPF_CTRL0"
#define device_bar_CAVM_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL0(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_rxclk_dlpf_ctrl8_rsvd
 *
 * INTERNAL: GSERC Ln Cdr Rxclk Dlpf Ctrl8 Register
 */
union cavm_gsercx_lnx_cdr_rxclk_dlpf_ctrl8_rsvd
{
    uint32_t u;
    struct cavm_gsercx_lnx_cdr_rxclk_dlpf_ctrl8_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t output_sample_period  : 6;  /**< [  5:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t output_sample_period  : 6;  /**< [  5:  0](R/W/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_cdr_rxclk_dlpf_ctrl8_rsvd_s cn; */
};
typedef union cavm_gsercx_lnx_cdr_rxclk_dlpf_ctrl8_rsvd cavm_gsercx_lnx_cdr_rxclk_dlpf_ctrl8_rsvd_t;

static inline uint64_t CAVM_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL8_RSVD(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL8_RSVD(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a80105d8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80105d8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_CDR_RXCLK_DLPF_CTRL8_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL8_RSVD(a,b) cavm_gsercx_lnx_cdr_rxclk_dlpf_ctrl8_rsvd_t
#define bustype_CAVM_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL8_RSVD(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL8_RSVD(a,b) "GSERCX_LNX_CDR_RXCLK_DLPF_CTRL8_RSVD"
#define device_bar_CAVM_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL8_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL8_RSVD(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL8_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_rxclk_dlpf_status2
 *
 * GSERC Ln Cdr Rxclk Dlpf Status2 Register
 */
union cavm_gsercx_lnx_cdr_rxclk_dlpf_status2
{
    uint32_t u;
    struct cavm_gsercx_lnx_cdr_rxclk_dlpf_status2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t binary_val_7_0        : 8;  /**< [  7:  0](RO/H) Binary-coded DLPF.  Need to read dlpf_status3 first and then read dlpf_status2.
                                                                 The buffered DLPF value is held constant when dlpf_status3 is read until
                                                                 dlpf_status2 is read. */
#else /* Word 0 - Little Endian */
        uint32_t binary_val_7_0        : 8;  /**< [  7:  0](RO/H) Binary-coded DLPF.  Need to read dlpf_status3 first and then read dlpf_status2.
                                                                 The buffered DLPF value is held constant when dlpf_status3 is read until
                                                                 dlpf_status2 is read. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_cdr_rxclk_dlpf_status2_s cn; */
};
typedef union cavm_gsercx_lnx_cdr_rxclk_dlpf_status2 cavm_gsercx_lnx_cdr_rxclk_dlpf_status2_t;

static inline uint64_t CAVM_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS2(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS2(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a80105f8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80105f8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_CDR_RXCLK_DLPF_STATUS2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS2(a,b) cavm_gsercx_lnx_cdr_rxclk_dlpf_status2_t
#define bustype_CAVM_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS2(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS2(a,b) "GSERCX_LNX_CDR_RXCLK_DLPF_STATUS2"
#define device_bar_CAVM_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS2(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS2(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS2(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_rxclk_dlpf_status3
 *
 * GSERC Ln Cdr Rxclk Dlpf Status3 Register
 */
union cavm_gsercx_lnx_cdr_rxclk_dlpf_status3
{
    uint32_t u;
    struct cavm_gsercx_lnx_cdr_rxclk_dlpf_status3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t binary_val_8          : 1;  /**< [  0:  0](RO/H) Binary-coded DLPF.  Need to read dlpf_status3 first and then read dlpf_status2.
                                                                 The buffered DLPF value is held constant when dlpf_status3 is read until
                                                                 dlpf_status2 is read. */
#else /* Word 0 - Little Endian */
        uint32_t binary_val_8          : 1;  /**< [  0:  0](RO/H) Binary-coded DLPF.  Need to read dlpf_status3 first and then read dlpf_status2.
                                                                 The buffered DLPF value is held constant when dlpf_status3 is read until
                                                                 dlpf_status2 is read. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_cdr_rxclk_dlpf_status3_s cn; */
};
typedef union cavm_gsercx_lnx_cdr_rxclk_dlpf_status3 cavm_gsercx_lnx_cdr_rxclk_dlpf_status3_t;

static inline uint64_t CAVM_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS3(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS3(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8010600ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010600ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_CDR_RXCLK_DLPF_STATUS3", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS3(a,b) cavm_gsercx_lnx_cdr_rxclk_dlpf_status3_t
#define bustype_CAVM_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS3(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS3(a,b) "GSERCX_LNX_CDR_RXCLK_DLPF_STATUS3"
#define device_bar_CAVM_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS3(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS3(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS3(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_rxclk_dlpf_status4
 *
 * GSERC Ln Cdr Rxclk Dlpf Status4 Register
 */
union cavm_gsercx_lnx_cdr_rxclk_dlpf_status4
{
    uint32_t u;
    struct cavm_gsercx_lnx_cdr_rxclk_dlpf_status4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t lock_lost             : 1;  /**< [  2:  2](RO/H) 1 indicates lock has been lost.
                                                                 This is sticky until cleared by disabling the loss-of-lock detector i.e. set lock_en_i to 0. */
        uint32_t dlpf_too_low          : 1;  /**< [  1:  1](RO/H) Indicates that DLPF is too low. */
        uint32_t dlpf_too_high         : 1;  /**< [  0:  0](RO/H) Indicates that DLPF is too high. */
#else /* Word 0 - Little Endian */
        uint32_t dlpf_too_high         : 1;  /**< [  0:  0](RO/H) Indicates that DLPF is too high. */
        uint32_t dlpf_too_low          : 1;  /**< [  1:  1](RO/H) Indicates that DLPF is too low. */
        uint32_t lock_lost             : 1;  /**< [  2:  2](RO/H) 1 indicates lock has been lost.
                                                                 This is sticky until cleared by disabling the loss-of-lock detector i.e. set lock_en_i to 0. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_cdr_rxclk_dlpf_status4_s cn; */
};
typedef union cavm_gsercx_lnx_cdr_rxclk_dlpf_status4 cavm_gsercx_lnx_cdr_rxclk_dlpf_status4_t;

static inline uint64_t CAVM_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS4(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS4(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8010608ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010608ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_CDR_RXCLK_DLPF_STATUS4", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS4(a,b) cavm_gsercx_lnx_cdr_rxclk_dlpf_status4_t
#define bustype_CAVM_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS4(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS4(a,b) "GSERCX_LNX_CDR_RXCLK_DLPF_STATUS4"
#define device_bar_CAVM_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS4(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS4(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS4(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_rxclk_dlpf_status5
 *
 * GSERC Ln Cdr Rxclk Dlpf Status5 Register
 */
union cavm_gsercx_lnx_cdr_rxclk_dlpf_status5
{
    uint32_t u;
    struct cavm_gsercx_lnx_cdr_rxclk_dlpf_status5_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t locked                : 1;  /**< [  0:  0](RO/H) 1 indicates lock has been detected.
                                                                 It is cleared when lock detector is disabled detector i.e. set lock_en_i to 0. */
#else /* Word 0 - Little Endian */
        uint32_t locked                : 1;  /**< [  0:  0](RO/H) 1 indicates lock has been detected.
                                                                 It is cleared when lock detector is disabled detector i.e. set lock_en_i to 0. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_cdr_rxclk_dlpf_status5_s cn; */
};
typedef union cavm_gsercx_lnx_cdr_rxclk_dlpf_status5 cavm_gsercx_lnx_cdr_rxclk_dlpf_status5_t;

static inline uint64_t CAVM_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS5(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS5(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8010620ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010620ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_CDR_RXCLK_DLPF_STATUS5", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS5(a,b) cavm_gsercx_lnx_cdr_rxclk_dlpf_status5_t
#define bustype_CAVM_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS5(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS5(a,b) "GSERCX_LNX_CDR_RXCLK_DLPF_STATUS5"
#define device_bar_CAVM_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS5(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS5(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS5(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_afe_pd_ctrl1
 *
 * GSERC Ln Dfe Refclk Afe Pd Ctrl1 Register
 */
union cavm_gsercx_lnx_dfe_refclk_afe_pd_ctrl1
{
    uint32_t u;
    struct cavm_gsercx_lnx_dfe_refclk_afe_pd_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t pd_rxdfe_tap          : 8;  /**< [  7:  0](R/W/H) DFE tap power down control. */
#else /* Word 0 - Little Endian */
        uint32_t pd_rxdfe_tap          : 8;  /**< [  7:  0](R/W/H) DFE tap power down control. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_dfe_refclk_afe_pd_ctrl1_s cn; */
};
typedef union cavm_gsercx_lnx_dfe_refclk_afe_pd_ctrl1 cavm_gsercx_lnx_dfe_refclk_afe_pd_ctrl1_t;

static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_AFE_PD_CTRL1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_AFE_PD_CTRL1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8012008ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012008ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_DFE_REFCLK_AFE_PD_CTRL1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_DFE_REFCLK_AFE_PD_CTRL1(a,b) cavm_gsercx_lnx_dfe_refclk_afe_pd_ctrl1_t
#define bustype_CAVM_GSERCX_LNX_DFE_REFCLK_AFE_PD_CTRL1(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_DFE_REFCLK_AFE_PD_CTRL1(a,b) "GSERCX_LNX_DFE_REFCLK_AFE_PD_CTRL1"
#define device_bar_CAVM_GSERCX_LNX_DFE_REFCLK_AFE_PD_CTRL1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_DFE_REFCLK_AFE_PD_CTRL1(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_DFE_REFCLK_AFE_PD_CTRL1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_afe_pd_ctrl3
 *
 * GSERC Ln Dfe Refclk Afe Pd Ctrl3 Register
 */
union cavm_gsercx_lnx_dfe_refclk_afe_pd_ctrl3
{
    uint32_t u;
    struct cavm_gsercx_lnx_dfe_refclk_afe_pd_ctrl3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t pd_rxdfe_eye          : 3;  /**< [  2:  0](R/W/H) DFE eye monitor power down control
                                                                 0   0    0     100% active
                                                                 1   0    0     80% active
                                                                 1   0    1     66% active power-ramp-up state
                                                                 1   1    1     33% active power-ramp-up state
                                                                 1   1    0     off */
#else /* Word 0 - Little Endian */
        uint32_t pd_rxdfe_eye          : 3;  /**< [  2:  0](R/W/H) DFE eye monitor power down control
                                                                 0   0    0     100% active
                                                                 1   0    0     80% active
                                                                 1   0    1     66% active power-ramp-up state
                                                                 1   1    1     33% active power-ramp-up state
                                                                 1   1    0     off */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_dfe_refclk_afe_pd_ctrl3_s cn; */
};
typedef union cavm_gsercx_lnx_dfe_refclk_afe_pd_ctrl3 cavm_gsercx_lnx_dfe_refclk_afe_pd_ctrl3_t;

static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_AFE_PD_CTRL3(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_AFE_PD_CTRL3(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8012018ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012018ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_DFE_REFCLK_AFE_PD_CTRL3", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_DFE_REFCLK_AFE_PD_CTRL3(a,b) cavm_gsercx_lnx_dfe_refclk_afe_pd_ctrl3_t
#define bustype_CAVM_GSERCX_LNX_DFE_REFCLK_AFE_PD_CTRL3(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_DFE_REFCLK_AFE_PD_CTRL3(a,b) "GSERCX_LNX_DFE_REFCLK_AFE_PD_CTRL3"
#define device_bar_CAVM_GSERCX_LNX_DFE_REFCLK_AFE_PD_CTRL3(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_DFE_REFCLK_AFE_PD_CTRL3(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_DFE_REFCLK_AFE_PD_CTRL3(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_eye_tap1_ctrl0
 *
 * GSERC Ln Dfe Refclk Eye Tap1 Ctrl0 Register
 */
union cavm_gsercx_lnx_dfe_refclk_eye_tap1_ctrl0
{
    uint32_t u;
    struct cavm_gsercx_lnx_dfe_refclk_eye_tap1_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t pol                   : 1;  /**< [  7:  7](R/W/H) Eye monitor tap1 polarity control 0 = negative, 1 = positive. */
        uint32_t mag                   : 7;  /**< [  6:  0](R/W/H) Eye monitor tap1 magnitude control. */
#else /* Word 0 - Little Endian */
        uint32_t mag                   : 7;  /**< [  6:  0](R/W/H) Eye monitor tap1 magnitude control. */
        uint32_t pol                   : 1;  /**< [  7:  7](R/W/H) Eye monitor tap1 polarity control 0 = negative, 1 = positive. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_dfe_refclk_eye_tap1_ctrl0_s cn; */
};
typedef union cavm_gsercx_lnx_dfe_refclk_eye_tap1_ctrl0 cavm_gsercx_lnx_dfe_refclk_eye_tap1_ctrl0_t;

static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_EYE_TAP1_CTRL0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_EYE_TAP1_CTRL0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a80120d8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80120d8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_DFE_REFCLK_EYE_TAP1_CTRL0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_DFE_REFCLK_EYE_TAP1_CTRL0(a,b) cavm_gsercx_lnx_dfe_refclk_eye_tap1_ctrl0_t
#define bustype_CAVM_GSERCX_LNX_DFE_REFCLK_EYE_TAP1_CTRL0(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_DFE_REFCLK_EYE_TAP1_CTRL0(a,b) "GSERCX_LNX_DFE_REFCLK_EYE_TAP1_CTRL0"
#define device_bar_CAVM_GSERCX_LNX_DFE_REFCLK_EYE_TAP1_CTRL0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_DFE_REFCLK_EYE_TAP1_CTRL0(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_DFE_REFCLK_EYE_TAP1_CTRL0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_eye_vscan_ctrl0
 *
 * GSERC Ln Dfe Refclk Eye Vscan Ctrl0 Register
 */
union cavm_gsercx_lnx_dfe_refclk_eye_vscan_ctrl0
{
    uint32_t u;
    struct cavm_gsercx_lnx_dfe_refclk_eye_vscan_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t mag                   : 8;  /**< [  7:  0](R/W/H) Eye monitor vertical scan magnitude control. */
#else /* Word 0 - Little Endian */
        uint32_t mag                   : 8;  /**< [  7:  0](R/W/H) Eye monitor vertical scan magnitude control. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_dfe_refclk_eye_vscan_ctrl0_s cn; */
};
typedef union cavm_gsercx_lnx_dfe_refclk_eye_vscan_ctrl0 cavm_gsercx_lnx_dfe_refclk_eye_vscan_ctrl0_t;

static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_EYE_VSCAN_CTRL0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_EYE_VSCAN_CTRL0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a80120c0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80120c0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_DFE_REFCLK_EYE_VSCAN_CTRL0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_DFE_REFCLK_EYE_VSCAN_CTRL0(a,b) cavm_gsercx_lnx_dfe_refclk_eye_vscan_ctrl0_t
#define bustype_CAVM_GSERCX_LNX_DFE_REFCLK_EYE_VSCAN_CTRL0(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_DFE_REFCLK_EYE_VSCAN_CTRL0(a,b) "GSERCX_LNX_DFE_REFCLK_EYE_VSCAN_CTRL0"
#define device_bar_CAVM_GSERCX_LNX_DFE_REFCLK_EYE_VSCAN_CTRL0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_DFE_REFCLK_EYE_VSCAN_CTRL0(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_DFE_REFCLK_EYE_VSCAN_CTRL0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_eye_vscan_ctrl1
 *
 * GSERC Ln Dfe Refclk Eye Vscan Ctrl1 Register
 */
union cavm_gsercx_lnx_dfe_refclk_eye_vscan_ctrl1
{
    uint32_t u;
    struct cavm_gsercx_lnx_dfe_refclk_eye_vscan_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t pol                   : 1;  /**< [  0:  0](R/W/H) Eye monitor vertical scan polarity control 0 = negative, 1 = positive. */
#else /* Word 0 - Little Endian */
        uint32_t pol                   : 1;  /**< [  0:  0](R/W/H) Eye monitor vertical scan polarity control 0 = negative, 1 = positive. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_dfe_refclk_eye_vscan_ctrl1_s cn; */
};
typedef union cavm_gsercx_lnx_dfe_refclk_eye_vscan_ctrl1 cavm_gsercx_lnx_dfe_refclk_eye_vscan_ctrl1_t;

static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_EYE_VSCAN_CTRL1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_EYE_VSCAN_CTRL1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a80120c8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80120c8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_DFE_REFCLK_EYE_VSCAN_CTRL1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_DFE_REFCLK_EYE_VSCAN_CTRL1(a,b) cavm_gsercx_lnx_dfe_refclk_eye_vscan_ctrl1_t
#define bustype_CAVM_GSERCX_LNX_DFE_REFCLK_EYE_VSCAN_CTRL1(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_DFE_REFCLK_EYE_VSCAN_CTRL1(a,b) "GSERCX_LNX_DFE_REFCLK_EYE_VSCAN_CTRL1"
#define device_bar_CAVM_GSERCX_LNX_DFE_REFCLK_EYE_VSCAN_CTRL1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_DFE_REFCLK_EYE_VSCAN_CTRL1(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_DFE_REFCLK_EYE_VSCAN_CTRL1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_fsm_ctrl0
 *
 * GSERC Ln Dfe Refclk Fsm Ctrl0 Register
 */
union cavm_gsercx_lnx_dfe_refclk_fsm_ctrl0
{
    uint32_t u;
    struct cavm_gsercx_lnx_dfe_refclk_fsm_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t drive_before_eval     : 1;  /**< [  7:  7](R/W/H) Reserved. */
        uint32_t finish                : 1;  /**< [  6:  6](R/W/H) Reserved. */
        uint32_t cmd                   : 5;  /**< [  5:  1](R/W/H) FSM Command to run:
                                                                 0x00 = LOAD_ONLY
                                                                 0x02 = EYE_PHASE_ADAPTATION
                                                                 0x04 = LOAD_EVAL_ONLY
                                                                 0x08 = LOAD_EVAL_CONVRG_ONLY
                                                                 0x10 = LOAD_EVAL_CONVRG_ALL_COMP */
        uint32_t req                   : 1;  /**< [  0:  0](R/W/H) Firmware request for DFE. */
#else /* Word 0 - Little Endian */
        uint32_t req                   : 1;  /**< [  0:  0](R/W/H) Firmware request for DFE. */
        uint32_t cmd                   : 5;  /**< [  5:  1](R/W/H) FSM Command to run:
                                                                 0x00 = LOAD_ONLY
                                                                 0x02 = EYE_PHASE_ADAPTATION
                                                                 0x04 = LOAD_EVAL_ONLY
                                                                 0x08 = LOAD_EVAL_CONVRG_ONLY
                                                                 0x10 = LOAD_EVAL_CONVRG_ALL_COMP */
        uint32_t finish                : 1;  /**< [  6:  6](R/W/H) Reserved. */
        uint32_t drive_before_eval     : 1;  /**< [  7:  7](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_dfe_refclk_fsm_ctrl0_s cn; */
};
typedef union cavm_gsercx_lnx_dfe_refclk_fsm_ctrl0 cavm_gsercx_lnx_dfe_refclk_fsm_ctrl0_t;

static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_FSM_CTRL0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_FSM_CTRL0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8012100ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012100ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_DFE_REFCLK_FSM_CTRL0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_DFE_REFCLK_FSM_CTRL0(a,b) cavm_gsercx_lnx_dfe_refclk_fsm_ctrl0_t
#define bustype_CAVM_GSERCX_LNX_DFE_REFCLK_FSM_CTRL0(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_DFE_REFCLK_FSM_CTRL0(a,b) "GSERCX_LNX_DFE_REFCLK_FSM_CTRL0"
#define device_bar_CAVM_GSERCX_LNX_DFE_REFCLK_FSM_CTRL0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_DFE_REFCLK_FSM_CTRL0(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_DFE_REFCLK_FSM_CTRL0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_fsm_status0
 *
 * GSERC Ln Dfe Refclk Fsm Status0 Register
 */
union cavm_gsercx_lnx_dfe_refclk_fsm_status0
{
    uint32_t u;
    struct cavm_gsercx_lnx_dfe_refclk_fsm_status0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t afe_drv_ack           : 1;  /**< [  3:  3](RO/H) Reserved. */
        uint32_t err_func_ack          : 1;  /**< [  2:  2](RO/H) Reserved. */
        uint32_t slicer_ofst_ack       : 1;  /**< [  1:  1](RO/H) Reserved. */
        uint32_t ack                   : 1;  /**< [  0:  0](RO/H) Acknowledge from DFE. */
#else /* Word 0 - Little Endian */
        uint32_t ack                   : 1;  /**< [  0:  0](RO/H) Acknowledge from DFE. */
        uint32_t slicer_ofst_ack       : 1;  /**< [  1:  1](RO/H) Reserved. */
        uint32_t err_func_ack          : 1;  /**< [  2:  2](RO/H) Reserved. */
        uint32_t afe_drv_ack           : 1;  /**< [  3:  3](RO/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_dfe_refclk_fsm_status0_s cn; */
};
typedef union cavm_gsercx_lnx_dfe_refclk_fsm_status0 cavm_gsercx_lnx_dfe_refclk_fsm_status0_t;

static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_FSM_STATUS0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_FSM_STATUS0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8012140ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012140ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_DFE_REFCLK_FSM_STATUS0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_DFE_REFCLK_FSM_STATUS0(a,b) cavm_gsercx_lnx_dfe_refclk_fsm_status0_t
#define bustype_CAVM_GSERCX_LNX_DFE_REFCLK_FSM_STATUS0(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_DFE_REFCLK_FSM_STATUS0(a,b) "GSERCX_LNX_DFE_REFCLK_FSM_STATUS0"
#define device_bar_CAVM_GSERCX_LNX_DFE_REFCLK_FSM_STATUS0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_DFE_REFCLK_FSM_STATUS0(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_DFE_REFCLK_FSM_STATUS0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_tap_ctrl0
 *
 * GSERC Ln Dfe Refclk Tap Ctrl0 Register
 */
union cavm_gsercx_lnx_dfe_refclk_tap_ctrl0
{
    uint32_t u;
    struct cavm_gsercx_lnx_dfe_refclk_tap_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t tap1_odd_en           : 1;  /**< [  1:  1](R/W/H) Enables updating Tap 1 Odd Path during FSM LOAD_*** commands
                                                                 0 = Disabled
                                                                 1 = Enabled */
        uint32_t tap1_even_en          : 1;  /**< [  0:  0](R/W/H) Enables updating Tap 1 Even Path during FSM LOAD_*** commands
                                                                 0 = Disabled
                                                                 1 = Enabled */
#else /* Word 0 - Little Endian */
        uint32_t tap1_even_en          : 1;  /**< [  0:  0](R/W/H) Enables updating Tap 1 Even Path during FSM LOAD_*** commands
                                                                 0 = Disabled
                                                                 1 = Enabled */
        uint32_t tap1_odd_en           : 1;  /**< [  1:  1](R/W/H) Enables updating Tap 1 Odd Path during FSM LOAD_*** commands
                                                                 0 = Disabled
                                                                 1 = Enabled */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_dfe_refclk_tap_ctrl0_s cn; */
};
typedef union cavm_gsercx_lnx_dfe_refclk_tap_ctrl0 cavm_gsercx_lnx_dfe_refclk_tap_ctrl0_t;

static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_TAP_CTRL0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_TAP_CTRL0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8012148ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012148ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_DFE_REFCLK_TAP_CTRL0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_CTRL0(a,b) cavm_gsercx_lnx_dfe_refclk_tap_ctrl0_t
#define bustype_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_CTRL0(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_CTRL0(a,b) "GSERCX_LNX_DFE_REFCLK_TAP_CTRL0"
#define device_bar_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_CTRL0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_CTRL0(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_CTRL0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_tap_ctrl1
 *
 * GSERC Ln Dfe Refclk Tap Ctrl1 Register
 */
union cavm_gsercx_lnx_dfe_refclk_tap_ctrl1
{
    uint32_t u;
    struct cavm_gsercx_lnx_dfe_refclk_tap_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t tap8_en               : 1;  /**< [  6:  6](R/W/H) Enables updating Tap 8 during FSM LOAD_*** commands
                                                                 0 = Disabled
                                                                 1 = Enabled */
        uint32_t tap7_en               : 1;  /**< [  5:  5](R/W/H) Enables updating Tap 7 during FSM LOAD_*** commands
                                                                 0 = Disabled
                                                                 1 = Enabled */
        uint32_t tap6_en               : 1;  /**< [  4:  4](R/W/H) Enables updating Tap 6 during FSM LOAD_*** commands
                                                                 0 = Disabled
                                                                 1 = Enabled */
        uint32_t tap5_en               : 1;  /**< [  3:  3](R/W/H) Enables updating Tap 5 during FSM LOAD_*** commands
                                                                 0 = Disabled
                                                                 1 = Enabled */
        uint32_t tap4_en               : 1;  /**< [  2:  2](R/W/H) Enables updating Tap 4 during FSM LOAD_*** commands
                                                                 0 = Disabled
                                                                 1 = Enabled */
        uint32_t tap3_en               : 1;  /**< [  1:  1](R/W/H) Enables updating Tap 3 during FSM LOAD_*** commands
                                                                 0 = Disabled
                                                                 1 = Enabled */
        uint32_t tap2_en               : 1;  /**< [  0:  0](R/W/H) Enables updating Tap 2 during FSM LOAD_*** commands
                                                                 0 = Disabled
                                                                 1 = Enabled */
#else /* Word 0 - Little Endian */
        uint32_t tap2_en               : 1;  /**< [  0:  0](R/W/H) Enables updating Tap 2 during FSM LOAD_*** commands
                                                                 0 = Disabled
                                                                 1 = Enabled */
        uint32_t tap3_en               : 1;  /**< [  1:  1](R/W/H) Enables updating Tap 3 during FSM LOAD_*** commands
                                                                 0 = Disabled
                                                                 1 = Enabled */
        uint32_t tap4_en               : 1;  /**< [  2:  2](R/W/H) Enables updating Tap 4 during FSM LOAD_*** commands
                                                                 0 = Disabled
                                                                 1 = Enabled */
        uint32_t tap5_en               : 1;  /**< [  3:  3](R/W/H) Enables updating Tap 5 during FSM LOAD_*** commands
                                                                 0 = Disabled
                                                                 1 = Enabled */
        uint32_t tap6_en               : 1;  /**< [  4:  4](R/W/H) Enables updating Tap 6 during FSM LOAD_*** commands
                                                                 0 = Disabled
                                                                 1 = Enabled */
        uint32_t tap7_en               : 1;  /**< [  5:  5](R/W/H) Enables updating Tap 7 during FSM LOAD_*** commands
                                                                 0 = Disabled
                                                                 1 = Enabled */
        uint32_t tap8_en               : 1;  /**< [  6:  6](R/W/H) Enables updating Tap 8 during FSM LOAD_*** commands
                                                                 0 = Disabled
                                                                 1 = Enabled */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_dfe_refclk_tap_ctrl1_s cn; */
};
typedef union cavm_gsercx_lnx_dfe_refclk_tap_ctrl1 cavm_gsercx_lnx_dfe_refclk_tap_ctrl1_t;

static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_TAP_CTRL1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_TAP_CTRL1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8012150ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012150ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_DFE_REFCLK_TAP_CTRL1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_CTRL1(a,b) cavm_gsercx_lnx_dfe_refclk_tap_ctrl1_t
#define bustype_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_CTRL1(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_CTRL1(a,b) "GSERCX_LNX_DFE_REFCLK_TAP_CTRL1"
#define device_bar_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_CTRL1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_CTRL1(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_CTRL1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_tap_load_val_ctrl0
 *
 * GSERC Ln Dfe Refclk Tap Load Val Ctrl0 Register
 */
union cavm_gsercx_lnx_dfe_refclk_tap_load_val_ctrl0
{
    uint32_t u;
    struct cavm_gsercx_lnx_dfe_refclk_tap_load_val_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tap1_even_polarity    : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t tap1_even             : 7;  /**< [  6:  0](R/W/H) Loading value for Tap 1 Even Path for Tap Adaptations. */
#else /* Word 0 - Little Endian */
        uint32_t tap1_even             : 7;  /**< [  6:  0](R/W/H) Loading value for Tap 1 Even Path for Tap Adaptations. */
        uint32_t tap1_even_polarity    : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_dfe_refclk_tap_load_val_ctrl0_s cn; */
};
typedef union cavm_gsercx_lnx_dfe_refclk_tap_load_val_ctrl0 cavm_gsercx_lnx_dfe_refclk_tap_load_val_ctrl0_t;

static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a80121a0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80121a0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL0(a,b) cavm_gsercx_lnx_dfe_refclk_tap_load_val_ctrl0_t
#define bustype_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL0(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL0(a,b) "GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL0"
#define device_bar_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL0(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_tap_load_val_ctrl1
 *
 * GSERC Ln Dfe Refclk Tap Load Val Ctrl1 Register
 */
union cavm_gsercx_lnx_dfe_refclk_tap_load_val_ctrl1
{
    uint32_t u;
    struct cavm_gsercx_lnx_dfe_refclk_tap_load_val_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tap1_odd_polarity     : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t tap1_odd              : 7;  /**< [  6:  0](R/W/H) Loading value for Tap 1 Odd Path for Tap Adaptations. */
#else /* Word 0 - Little Endian */
        uint32_t tap1_odd              : 7;  /**< [  6:  0](R/W/H) Loading value for Tap 1 Odd Path for Tap Adaptations. */
        uint32_t tap1_odd_polarity     : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_dfe_refclk_tap_load_val_ctrl1_s cn; */
};
typedef union cavm_gsercx_lnx_dfe_refclk_tap_load_val_ctrl1 cavm_gsercx_lnx_dfe_refclk_tap_load_val_ctrl1_t;

static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a80121a8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80121a8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL1(a,b) cavm_gsercx_lnx_dfe_refclk_tap_load_val_ctrl1_t
#define bustype_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL1(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL1(a,b) "GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL1"
#define device_bar_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL1(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_tap_load_val_ctrl2
 *
 * GSERC Ln Dfe Refclk Tap Load Val Ctrl2 Register
 */
union cavm_gsercx_lnx_dfe_refclk_tap_load_val_ctrl2
{
    uint32_t u;
    struct cavm_gsercx_lnx_dfe_refclk_tap_load_val_ctrl2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tap2_polarity         : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_6            : 1;
        uint32_t tap2                  : 6;  /**< [  5:  0](R/W/H) Loading value for Tap 2 for Tap Adaptations. */
#else /* Word 0 - Little Endian */
        uint32_t tap2                  : 6;  /**< [  5:  0](R/W/H) Loading value for Tap 2 for Tap Adaptations. */
        uint32_t reserved_6            : 1;
        uint32_t tap2_polarity         : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_dfe_refclk_tap_load_val_ctrl2_s cn; */
};
typedef union cavm_gsercx_lnx_dfe_refclk_tap_load_val_ctrl2 cavm_gsercx_lnx_dfe_refclk_tap_load_val_ctrl2_t;

static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL2(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL2(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a80121b0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80121b0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL2(a,b) cavm_gsercx_lnx_dfe_refclk_tap_load_val_ctrl2_t
#define bustype_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL2(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL2(a,b) "GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL2"
#define device_bar_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL2(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL2(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL2(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_tap_load_val_ctrl3
 *
 * GSERC Ln Dfe Refclk Tap Load Val Ctrl3 Register
 */
union cavm_gsercx_lnx_dfe_refclk_tap_load_val_ctrl3
{
    uint32_t u;
    struct cavm_gsercx_lnx_dfe_refclk_tap_load_val_ctrl3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tap3_polarity         : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_5_6          : 2;
        uint32_t tap3                  : 5;  /**< [  4:  0](R/W/H) Loading value for Tap 3 for Tap Adaptations. */
#else /* Word 0 - Little Endian */
        uint32_t tap3                  : 5;  /**< [  4:  0](R/W/H) Loading value for Tap 3 for Tap Adaptations. */
        uint32_t reserved_5_6          : 2;
        uint32_t tap3_polarity         : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_dfe_refclk_tap_load_val_ctrl3_s cn; */
};
typedef union cavm_gsercx_lnx_dfe_refclk_tap_load_val_ctrl3 cavm_gsercx_lnx_dfe_refclk_tap_load_val_ctrl3_t;

static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL3(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL3(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a80121b8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80121b8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL3", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL3(a,b) cavm_gsercx_lnx_dfe_refclk_tap_load_val_ctrl3_t
#define bustype_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL3(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL3(a,b) "GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL3"
#define device_bar_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL3(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL3(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL3(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_tap_load_val_ctrl4
 *
 * GSERC Ln Dfe Refclk Tap Load Val Ctrl4 Register
 */
union cavm_gsercx_lnx_dfe_refclk_tap_load_val_ctrl4
{
    uint32_t u;
    struct cavm_gsercx_lnx_dfe_refclk_tap_load_val_ctrl4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tap4_polarity         : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_4_6          : 3;
        uint32_t tap4                  : 4;  /**< [  3:  0](R/W/H) Loading value for Tap 4 for Tap Adaptations. */
#else /* Word 0 - Little Endian */
        uint32_t tap4                  : 4;  /**< [  3:  0](R/W/H) Loading value for Tap 4 for Tap Adaptations. */
        uint32_t reserved_4_6          : 3;
        uint32_t tap4_polarity         : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_dfe_refclk_tap_load_val_ctrl4_s cn; */
};
typedef union cavm_gsercx_lnx_dfe_refclk_tap_load_val_ctrl4 cavm_gsercx_lnx_dfe_refclk_tap_load_val_ctrl4_t;

static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL4(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL4(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a80121c0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80121c0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL4", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL4(a,b) cavm_gsercx_lnx_dfe_refclk_tap_load_val_ctrl4_t
#define bustype_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL4(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL4(a,b) "GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL4"
#define device_bar_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL4(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL4(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL4(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_tap_load_val_ctrl5
 *
 * GSERC Ln Dfe Refclk Tap Load Val Ctrl5 Register
 */
union cavm_gsercx_lnx_dfe_refclk_tap_load_val_ctrl5
{
    uint32_t u;
    struct cavm_gsercx_lnx_dfe_refclk_tap_load_val_ctrl5_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tap5_polarity         : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_4_6          : 3;
        uint32_t tap5                  : 4;  /**< [  3:  0](R/W/H) Loading value for Tap 5 for Tap Adaptations. */
#else /* Word 0 - Little Endian */
        uint32_t tap5                  : 4;  /**< [  3:  0](R/W/H) Loading value for Tap 5 for Tap Adaptations. */
        uint32_t reserved_4_6          : 3;
        uint32_t tap5_polarity         : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_dfe_refclk_tap_load_val_ctrl5_s cn; */
};
typedef union cavm_gsercx_lnx_dfe_refclk_tap_load_val_ctrl5 cavm_gsercx_lnx_dfe_refclk_tap_load_val_ctrl5_t;

static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL5(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL5(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a80121c8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80121c8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL5", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL5(a,b) cavm_gsercx_lnx_dfe_refclk_tap_load_val_ctrl5_t
#define bustype_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL5(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL5(a,b) "GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL5"
#define device_bar_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL5(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL5(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL5(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_tap_load_val_ctrl6
 *
 * GSERC Ln Dfe Refclk Tap Load Val Ctrl6 Register
 */
union cavm_gsercx_lnx_dfe_refclk_tap_load_val_ctrl6
{
    uint32_t u;
    struct cavm_gsercx_lnx_dfe_refclk_tap_load_val_ctrl6_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tap6_polarity         : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_4_6          : 3;
        uint32_t tap6                  : 4;  /**< [  3:  0](R/W/H) Loading value for Tap 6 for Tap Adaptations. */
#else /* Word 0 - Little Endian */
        uint32_t tap6                  : 4;  /**< [  3:  0](R/W/H) Loading value for Tap 6 for Tap Adaptations. */
        uint32_t reserved_4_6          : 3;
        uint32_t tap6_polarity         : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_dfe_refclk_tap_load_val_ctrl6_s cn; */
};
typedef union cavm_gsercx_lnx_dfe_refclk_tap_load_val_ctrl6 cavm_gsercx_lnx_dfe_refclk_tap_load_val_ctrl6_t;

static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL6(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL6(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a80121d0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80121d0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL6", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL6(a,b) cavm_gsercx_lnx_dfe_refclk_tap_load_val_ctrl6_t
#define bustype_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL6(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL6(a,b) "GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL6"
#define device_bar_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL6(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL6(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL6(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_tap_load_val_ctrl7
 *
 * GSERC Ln Dfe Refclk Tap Load Val Ctrl7 Register
 */
union cavm_gsercx_lnx_dfe_refclk_tap_load_val_ctrl7
{
    uint32_t u;
    struct cavm_gsercx_lnx_dfe_refclk_tap_load_val_ctrl7_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tap7_polarity         : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_3_6          : 4;
        uint32_t tap7                  : 3;  /**< [  2:  0](R/W/H) Loading value for Tap 7 for Tap Adaptations. */
#else /* Word 0 - Little Endian */
        uint32_t tap7                  : 3;  /**< [  2:  0](R/W/H) Loading value for Tap 7 for Tap Adaptations. */
        uint32_t reserved_3_6          : 4;
        uint32_t tap7_polarity         : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_dfe_refclk_tap_load_val_ctrl7_s cn; */
};
typedef union cavm_gsercx_lnx_dfe_refclk_tap_load_val_ctrl7 cavm_gsercx_lnx_dfe_refclk_tap_load_val_ctrl7_t;

static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL7(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL7(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a80121d8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80121d8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL7", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL7(a,b) cavm_gsercx_lnx_dfe_refclk_tap_load_val_ctrl7_t
#define bustype_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL7(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL7(a,b) "GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL7"
#define device_bar_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL7(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL7(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL7(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_tap_load_val_ctrl8
 *
 * GSERC Ln Dfe Refclk Tap Load Val Ctrl8 Register
 */
union cavm_gsercx_lnx_dfe_refclk_tap_load_val_ctrl8
{
    uint32_t u;
    struct cavm_gsercx_lnx_dfe_refclk_tap_load_val_ctrl8_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tap8_polarity         : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_3_6          : 4;
        uint32_t tap8                  : 3;  /**< [  2:  0](R/W/H) Loading value for Tap 8 for Tap Adaptations. */
#else /* Word 0 - Little Endian */
        uint32_t tap8                  : 3;  /**< [  2:  0](R/W/H) Loading value for Tap 8 for Tap Adaptations. */
        uint32_t reserved_3_6          : 4;
        uint32_t tap8_polarity         : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_dfe_refclk_tap_load_val_ctrl8_s cn; */
};
typedef union cavm_gsercx_lnx_dfe_refclk_tap_load_val_ctrl8 cavm_gsercx_lnx_dfe_refclk_tap_load_val_ctrl8_t;

static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL8(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL8(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a80121e0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80121e0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL8", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL8(a,b) cavm_gsercx_lnx_dfe_refclk_tap_load_val_ctrl8_t
#define bustype_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL8(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL8(a,b) "GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL8"
#define device_bar_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL8(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL8(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL8(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_tap_start_val_ctrl0
 *
 * GSERC Ln Dfe Refclk Tap Start Val Ctrl0 Register
 */
union cavm_gsercx_lnx_dfe_refclk_tap_start_val_ctrl0
{
    uint32_t u;
    struct cavm_gsercx_lnx_dfe_refclk_tap_start_val_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tap1_even_polarity    : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t tap1_even             : 7;  /**< [  6:  0](R/W/H) Starting value for Tap 1 Even Path for Tap Adaptations. */
#else /* Word 0 - Little Endian */
        uint32_t tap1_even             : 7;  /**< [  6:  0](R/W/H) Starting value for Tap 1 Even Path for Tap Adaptations. */
        uint32_t tap1_even_polarity    : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_dfe_refclk_tap_start_val_ctrl0_s cn; */
};
typedef union cavm_gsercx_lnx_dfe_refclk_tap_start_val_ctrl0 cavm_gsercx_lnx_dfe_refclk_tap_start_val_ctrl0_t;

static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8012158ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012158ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL0(a,b) cavm_gsercx_lnx_dfe_refclk_tap_start_val_ctrl0_t
#define bustype_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL0(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL0(a,b) "GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL0"
#define device_bar_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL0(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_tap_start_val_ctrl1
 *
 * GSERC Ln Dfe Refclk Tap Start Val Ctrl1 Register
 */
union cavm_gsercx_lnx_dfe_refclk_tap_start_val_ctrl1
{
    uint32_t u;
    struct cavm_gsercx_lnx_dfe_refclk_tap_start_val_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tap1_odd_polarity     : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t tap1_odd              : 7;  /**< [  6:  0](R/W/H) Starting value for Tap 1 Odd Path for Tap Adaptations. */
#else /* Word 0 - Little Endian */
        uint32_t tap1_odd              : 7;  /**< [  6:  0](R/W/H) Starting value for Tap 1 Odd Path for Tap Adaptations. */
        uint32_t tap1_odd_polarity     : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_dfe_refclk_tap_start_val_ctrl1_s cn; */
};
typedef union cavm_gsercx_lnx_dfe_refclk_tap_start_val_ctrl1 cavm_gsercx_lnx_dfe_refclk_tap_start_val_ctrl1_t;

static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8012160ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012160ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL1(a,b) cavm_gsercx_lnx_dfe_refclk_tap_start_val_ctrl1_t
#define bustype_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL1(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL1(a,b) "GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL1"
#define device_bar_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL1(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_tap_start_val_ctrl2
 *
 * GSERC Ln Dfe Refclk Tap Start Val Ctrl2 Register
 */
union cavm_gsercx_lnx_dfe_refclk_tap_start_val_ctrl2
{
    uint32_t u;
    struct cavm_gsercx_lnx_dfe_refclk_tap_start_val_ctrl2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tap2_polarity         : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_6            : 1;
        uint32_t tap2                  : 6;  /**< [  5:  0](R/W/H) Starting value for Tap 2 for Tap Adaptations. */
#else /* Word 0 - Little Endian */
        uint32_t tap2                  : 6;  /**< [  5:  0](R/W/H) Starting value for Tap 2 for Tap Adaptations. */
        uint32_t reserved_6            : 1;
        uint32_t tap2_polarity         : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_dfe_refclk_tap_start_val_ctrl2_s cn; */
};
typedef union cavm_gsercx_lnx_dfe_refclk_tap_start_val_ctrl2 cavm_gsercx_lnx_dfe_refclk_tap_start_val_ctrl2_t;

static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL2(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL2(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8012168ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012168ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL2(a,b) cavm_gsercx_lnx_dfe_refclk_tap_start_val_ctrl2_t
#define bustype_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL2(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL2(a,b) "GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL2"
#define device_bar_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL2(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL2(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL2(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_tap_start_val_ctrl3
 *
 * GSERC Ln Dfe Refclk Tap Start Val Ctrl3 Register
 */
union cavm_gsercx_lnx_dfe_refclk_tap_start_val_ctrl3
{
    uint32_t u;
    struct cavm_gsercx_lnx_dfe_refclk_tap_start_val_ctrl3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tap3_polarity         : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_5_6          : 2;
        uint32_t tap3                  : 5;  /**< [  4:  0](R/W/H) Starting value for Tap 3 for Tap Adaptations. */
#else /* Word 0 - Little Endian */
        uint32_t tap3                  : 5;  /**< [  4:  0](R/W/H) Starting value for Tap 3 for Tap Adaptations. */
        uint32_t reserved_5_6          : 2;
        uint32_t tap3_polarity         : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_dfe_refclk_tap_start_val_ctrl3_s cn; */
};
typedef union cavm_gsercx_lnx_dfe_refclk_tap_start_val_ctrl3 cavm_gsercx_lnx_dfe_refclk_tap_start_val_ctrl3_t;

static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL3(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL3(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8012170ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012170ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL3", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL3(a,b) cavm_gsercx_lnx_dfe_refclk_tap_start_val_ctrl3_t
#define bustype_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL3(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL3(a,b) "GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL3"
#define device_bar_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL3(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL3(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL3(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_tap_start_val_ctrl4
 *
 * GSERC Ln Dfe Refclk Tap Start Val Ctrl4 Register
 */
union cavm_gsercx_lnx_dfe_refclk_tap_start_val_ctrl4
{
    uint32_t u;
    struct cavm_gsercx_lnx_dfe_refclk_tap_start_val_ctrl4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tap4_polarity         : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_4_6          : 3;
        uint32_t tap4                  : 4;  /**< [  3:  0](R/W/H) Starting value for Tap 4 for Tap Adaptations. */
#else /* Word 0 - Little Endian */
        uint32_t tap4                  : 4;  /**< [  3:  0](R/W/H) Starting value for Tap 4 for Tap Adaptations. */
        uint32_t reserved_4_6          : 3;
        uint32_t tap4_polarity         : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_dfe_refclk_tap_start_val_ctrl4_s cn; */
};
typedef union cavm_gsercx_lnx_dfe_refclk_tap_start_val_ctrl4 cavm_gsercx_lnx_dfe_refclk_tap_start_val_ctrl4_t;

static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL4(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL4(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8012178ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012178ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL4", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL4(a,b) cavm_gsercx_lnx_dfe_refclk_tap_start_val_ctrl4_t
#define bustype_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL4(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL4(a,b) "GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL4"
#define device_bar_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL4(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL4(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL4(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_tap_start_val_ctrl5
 *
 * GSERC Ln Dfe Refclk Tap Start Val Ctrl5 Register
 */
union cavm_gsercx_lnx_dfe_refclk_tap_start_val_ctrl5
{
    uint32_t u;
    struct cavm_gsercx_lnx_dfe_refclk_tap_start_val_ctrl5_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tap5_polarity         : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_4_6          : 3;
        uint32_t tap5                  : 4;  /**< [  3:  0](R/W/H) Starting value for Tap 5 for Tap Adaptations. */
#else /* Word 0 - Little Endian */
        uint32_t tap5                  : 4;  /**< [  3:  0](R/W/H) Starting value for Tap 5 for Tap Adaptations. */
        uint32_t reserved_4_6          : 3;
        uint32_t tap5_polarity         : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_dfe_refclk_tap_start_val_ctrl5_s cn; */
};
typedef union cavm_gsercx_lnx_dfe_refclk_tap_start_val_ctrl5 cavm_gsercx_lnx_dfe_refclk_tap_start_val_ctrl5_t;

static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL5(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL5(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8012180ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012180ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL5", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL5(a,b) cavm_gsercx_lnx_dfe_refclk_tap_start_val_ctrl5_t
#define bustype_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL5(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL5(a,b) "GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL5"
#define device_bar_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL5(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL5(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL5(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_tap_start_val_ctrl6
 *
 * GSERC Ln Dfe Refclk Tap Start Val Ctrl6 Register
 */
union cavm_gsercx_lnx_dfe_refclk_tap_start_val_ctrl6
{
    uint32_t u;
    struct cavm_gsercx_lnx_dfe_refclk_tap_start_val_ctrl6_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tap6_polarity         : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_4_6          : 3;
        uint32_t tap6                  : 4;  /**< [  3:  0](R/W/H) Starting value for Tap 6 for Tap Adaptations. */
#else /* Word 0 - Little Endian */
        uint32_t tap6                  : 4;  /**< [  3:  0](R/W/H) Starting value for Tap 6 for Tap Adaptations. */
        uint32_t reserved_4_6          : 3;
        uint32_t tap6_polarity         : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_dfe_refclk_tap_start_val_ctrl6_s cn; */
};
typedef union cavm_gsercx_lnx_dfe_refclk_tap_start_val_ctrl6 cavm_gsercx_lnx_dfe_refclk_tap_start_val_ctrl6_t;

static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL6(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL6(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8012188ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012188ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL6", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL6(a,b) cavm_gsercx_lnx_dfe_refclk_tap_start_val_ctrl6_t
#define bustype_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL6(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL6(a,b) "GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL6"
#define device_bar_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL6(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL6(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL6(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_tap_start_val_ctrl7
 *
 * GSERC Ln Dfe Refclk Tap Start Val Ctrl7 Register
 */
union cavm_gsercx_lnx_dfe_refclk_tap_start_val_ctrl7
{
    uint32_t u;
    struct cavm_gsercx_lnx_dfe_refclk_tap_start_val_ctrl7_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tap7_polarity         : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_3_6          : 4;
        uint32_t tap7                  : 3;  /**< [  2:  0](R/W/H) Starting value for Tap 7 for Tap Adaptations. */
#else /* Word 0 - Little Endian */
        uint32_t tap7                  : 3;  /**< [  2:  0](R/W/H) Starting value for Tap 7 for Tap Adaptations. */
        uint32_t reserved_3_6          : 4;
        uint32_t tap7_polarity         : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_dfe_refclk_tap_start_val_ctrl7_s cn; */
};
typedef union cavm_gsercx_lnx_dfe_refclk_tap_start_val_ctrl7 cavm_gsercx_lnx_dfe_refclk_tap_start_val_ctrl7_t;

static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL7(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL7(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8012190ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012190ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL7", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL7(a,b) cavm_gsercx_lnx_dfe_refclk_tap_start_val_ctrl7_t
#define bustype_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL7(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL7(a,b) "GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL7"
#define device_bar_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL7(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL7(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL7(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_tap_start_val_ctrl8
 *
 * GSERC Ln Dfe Refclk Tap Start Val Ctrl8 Register
 */
union cavm_gsercx_lnx_dfe_refclk_tap_start_val_ctrl8
{
    uint32_t u;
    struct cavm_gsercx_lnx_dfe_refclk_tap_start_val_ctrl8_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tap8_polarity         : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_3_6          : 4;
        uint32_t tap8                  : 3;  /**< [  2:  0](R/W/H) Starting value for Tap 8 for Tap Adaptations. */
#else /* Word 0 - Little Endian */
        uint32_t tap8                  : 3;  /**< [  2:  0](R/W/H) Starting value for Tap 8 for Tap Adaptations. */
        uint32_t reserved_3_6          : 4;
        uint32_t tap8_polarity         : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_dfe_refclk_tap_start_val_ctrl8_s cn; */
};
typedef union cavm_gsercx_lnx_dfe_refclk_tap_start_val_ctrl8 cavm_gsercx_lnx_dfe_refclk_tap_start_val_ctrl8_t;

static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL8(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL8(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8012198ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012198ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL8", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL8(a,b) cavm_gsercx_lnx_dfe_refclk_tap_start_val_ctrl8_t
#define bustype_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL8(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL8(a,b) "GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL8"
#define device_bar_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL8(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL8(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL8(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_tap_val_status0
 *
 * GSERC Ln Dfe Refclk Tap Val Status0 Register
 */
union cavm_gsercx_lnx_dfe_refclk_tap_val_status0
{
    uint32_t u;
    struct cavm_gsercx_lnx_dfe_refclk_tap_val_status0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tap1_even_polarity    : 1;  /**< [  7:  7](RO/H) Polarity 0 = negative, 1 = positive. */
        uint32_t tap1_even             : 7;  /**< [  6:  0](RO/H) Binary value for Tap 1 Even Path for Tap Adaptations. */
#else /* Word 0 - Little Endian */
        uint32_t tap1_even             : 7;  /**< [  6:  0](RO/H) Binary value for Tap 1 Even Path for Tap Adaptations. */
        uint32_t tap1_even_polarity    : 1;  /**< [  7:  7](RO/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_dfe_refclk_tap_val_status0_s cn; */
};
typedef union cavm_gsercx_lnx_dfe_refclk_tap_val_status0 cavm_gsercx_lnx_dfe_refclk_tap_val_status0_t;

static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a80121e8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80121e8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS0(a,b) cavm_gsercx_lnx_dfe_refclk_tap_val_status0_t
#define bustype_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS0(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS0(a,b) "GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS0"
#define device_bar_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS0(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_tap_val_status1
 *
 * GSERC Ln Dfe Refclk Tap Val Status1 Register
 */
union cavm_gsercx_lnx_dfe_refclk_tap_val_status1
{
    uint32_t u;
    struct cavm_gsercx_lnx_dfe_refclk_tap_val_status1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tap1_odd_polarity     : 1;  /**< [  7:  7](RO/H) Polarity 0 = negative, 1 = positive. */
        uint32_t tap1_odd              : 7;  /**< [  6:  0](RO/H) Binary  value for Tap 1 Odd Path for Tap Adaptations. */
#else /* Word 0 - Little Endian */
        uint32_t tap1_odd              : 7;  /**< [  6:  0](RO/H) Binary  value for Tap 1 Odd Path for Tap Adaptations. */
        uint32_t tap1_odd_polarity     : 1;  /**< [  7:  7](RO/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_dfe_refclk_tap_val_status1_s cn; */
};
typedef union cavm_gsercx_lnx_dfe_refclk_tap_val_status1 cavm_gsercx_lnx_dfe_refclk_tap_val_status1_t;

static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a80121f0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80121f0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS1(a,b) cavm_gsercx_lnx_dfe_refclk_tap_val_status1_t
#define bustype_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS1(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS1(a,b) "GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS1"
#define device_bar_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS1(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_tap_val_status2
 *
 * GSERC Ln Dfe Refclk Tap Val Status2 Register
 */
union cavm_gsercx_lnx_dfe_refclk_tap_val_status2
{
    uint32_t u;
    struct cavm_gsercx_lnx_dfe_refclk_tap_val_status2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tap2_polarity         : 1;  /**< [  7:  7](RO/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_6            : 1;
        uint32_t tap2                  : 6;  /**< [  5:  0](RO/H) Binary  value for Tap 2 for Tap Adaptations. */
#else /* Word 0 - Little Endian */
        uint32_t tap2                  : 6;  /**< [  5:  0](RO/H) Binary  value for Tap 2 for Tap Adaptations. */
        uint32_t reserved_6            : 1;
        uint32_t tap2_polarity         : 1;  /**< [  7:  7](RO/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_dfe_refclk_tap_val_status2_s cn; */
};
typedef union cavm_gsercx_lnx_dfe_refclk_tap_val_status2 cavm_gsercx_lnx_dfe_refclk_tap_val_status2_t;

static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS2(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS2(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a80121f8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80121f8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS2(a,b) cavm_gsercx_lnx_dfe_refclk_tap_val_status2_t
#define bustype_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS2(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS2(a,b) "GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS2"
#define device_bar_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS2(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS2(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS2(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_tap_val_status3
 *
 * GSERC Ln Dfe Refclk Tap Val Status3 Register
 */
union cavm_gsercx_lnx_dfe_refclk_tap_val_status3
{
    uint32_t u;
    struct cavm_gsercx_lnx_dfe_refclk_tap_val_status3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tap3_polarity         : 1;  /**< [  7:  7](RO/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_5_6          : 2;
        uint32_t tap3                  : 5;  /**< [  4:  0](RO/H) Binary  value for Tap 3 for Tap Adaptations. */
#else /* Word 0 - Little Endian */
        uint32_t tap3                  : 5;  /**< [  4:  0](RO/H) Binary  value for Tap 3 for Tap Adaptations. */
        uint32_t reserved_5_6          : 2;
        uint32_t tap3_polarity         : 1;  /**< [  7:  7](RO/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_dfe_refclk_tap_val_status3_s cn; */
};
typedef union cavm_gsercx_lnx_dfe_refclk_tap_val_status3 cavm_gsercx_lnx_dfe_refclk_tap_val_status3_t;

static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS3(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS3(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8012200ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012200ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS3", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS3(a,b) cavm_gsercx_lnx_dfe_refclk_tap_val_status3_t
#define bustype_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS3(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS3(a,b) "GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS3"
#define device_bar_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS3(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS3(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS3(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_tap_val_status4
 *
 * GSERC Ln Dfe Refclk Tap Val Status4 Register
 */
union cavm_gsercx_lnx_dfe_refclk_tap_val_status4
{
    uint32_t u;
    struct cavm_gsercx_lnx_dfe_refclk_tap_val_status4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tap4_polarity         : 1;  /**< [  7:  7](RO/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_4_6          : 3;
        uint32_t tap4                  : 4;  /**< [  3:  0](RO/H) Binary  value for Tap 4 for Tap Adaptations. */
#else /* Word 0 - Little Endian */
        uint32_t tap4                  : 4;  /**< [  3:  0](RO/H) Binary  value for Tap 4 for Tap Adaptations. */
        uint32_t reserved_4_6          : 3;
        uint32_t tap4_polarity         : 1;  /**< [  7:  7](RO/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_dfe_refclk_tap_val_status4_s cn; */
};
typedef union cavm_gsercx_lnx_dfe_refclk_tap_val_status4 cavm_gsercx_lnx_dfe_refclk_tap_val_status4_t;

static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS4(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS4(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8012208ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012208ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS4", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS4(a,b) cavm_gsercx_lnx_dfe_refclk_tap_val_status4_t
#define bustype_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS4(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS4(a,b) "GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS4"
#define device_bar_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS4(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS4(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS4(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_tap_val_status5
 *
 * GSERC Ln Dfe Refclk Tap Val Status5 Register
 */
union cavm_gsercx_lnx_dfe_refclk_tap_val_status5
{
    uint32_t u;
    struct cavm_gsercx_lnx_dfe_refclk_tap_val_status5_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tap5_polarity         : 1;  /**< [  7:  7](RO/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_4_6          : 3;
        uint32_t tap5                  : 4;  /**< [  3:  0](RO/H) Binary  value for Tap 5 for Tap Adaptations. */
#else /* Word 0 - Little Endian */
        uint32_t tap5                  : 4;  /**< [  3:  0](RO/H) Binary  value for Tap 5 for Tap Adaptations. */
        uint32_t reserved_4_6          : 3;
        uint32_t tap5_polarity         : 1;  /**< [  7:  7](RO/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_dfe_refclk_tap_val_status5_s cn; */
};
typedef union cavm_gsercx_lnx_dfe_refclk_tap_val_status5 cavm_gsercx_lnx_dfe_refclk_tap_val_status5_t;

static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS5(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS5(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8012210ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012210ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS5", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS5(a,b) cavm_gsercx_lnx_dfe_refclk_tap_val_status5_t
#define bustype_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS5(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS5(a,b) "GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS5"
#define device_bar_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS5(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS5(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS5(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_tap_val_status6
 *
 * GSERC Ln Dfe Refclk Tap Val Status6 Register
 */
union cavm_gsercx_lnx_dfe_refclk_tap_val_status6
{
    uint32_t u;
    struct cavm_gsercx_lnx_dfe_refclk_tap_val_status6_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tap6_polarity         : 1;  /**< [  7:  7](RO/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_4_6          : 3;
        uint32_t tap6                  : 4;  /**< [  3:  0](RO/H) Binary  value for Tap 6 for Tap Adaptations. */
#else /* Word 0 - Little Endian */
        uint32_t tap6                  : 4;  /**< [  3:  0](RO/H) Binary  value for Tap 6 for Tap Adaptations. */
        uint32_t reserved_4_6          : 3;
        uint32_t tap6_polarity         : 1;  /**< [  7:  7](RO/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_dfe_refclk_tap_val_status6_s cn; */
};
typedef union cavm_gsercx_lnx_dfe_refclk_tap_val_status6 cavm_gsercx_lnx_dfe_refclk_tap_val_status6_t;

static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS6(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS6(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8012218ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012218ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS6", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS6(a,b) cavm_gsercx_lnx_dfe_refclk_tap_val_status6_t
#define bustype_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS6(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS6(a,b) "GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS6"
#define device_bar_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS6(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS6(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS6(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_tap_val_status7
 *
 * GSERC Ln Dfe Refclk Tap Val Status7 Register
 */
union cavm_gsercx_lnx_dfe_refclk_tap_val_status7
{
    uint32_t u;
    struct cavm_gsercx_lnx_dfe_refclk_tap_val_status7_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tap7_polarity         : 1;  /**< [  7:  7](RO/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_3_6          : 4;
        uint32_t tap7                  : 3;  /**< [  2:  0](RO/H) Binary  value for Tap 7 for Tap Adaptations. */
#else /* Word 0 - Little Endian */
        uint32_t tap7                  : 3;  /**< [  2:  0](RO/H) Binary  value for Tap 7 for Tap Adaptations. */
        uint32_t reserved_3_6          : 4;
        uint32_t tap7_polarity         : 1;  /**< [  7:  7](RO/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_dfe_refclk_tap_val_status7_s cn; */
};
typedef union cavm_gsercx_lnx_dfe_refclk_tap_val_status7 cavm_gsercx_lnx_dfe_refclk_tap_val_status7_t;

static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS7(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS7(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8012220ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012220ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS7", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS7(a,b) cavm_gsercx_lnx_dfe_refclk_tap_val_status7_t
#define bustype_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS7(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS7(a,b) "GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS7"
#define device_bar_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS7(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS7(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS7(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_tap_val_status8
 *
 * GSERC Ln Dfe Refclk Tap Val Status8 Register
 */
union cavm_gsercx_lnx_dfe_refclk_tap_val_status8
{
    uint32_t u;
    struct cavm_gsercx_lnx_dfe_refclk_tap_val_status8_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tap8_polarity         : 1;  /**< [  7:  7](RO/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_3_6          : 4;
        uint32_t tap8                  : 3;  /**< [  2:  0](RO/H) Binary  value for Tap 8 for Tap Adaptations. */
#else /* Word 0 - Little Endian */
        uint32_t tap8                  : 3;  /**< [  2:  0](RO/H) Binary  value for Tap 8 for Tap Adaptations. */
        uint32_t reserved_3_6          : 4;
        uint32_t tap8_polarity         : 1;  /**< [  7:  7](RO/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_dfe_refclk_tap_val_status8_s cn; */
};
typedef union cavm_gsercx_lnx_dfe_refclk_tap_val_status8 cavm_gsercx_lnx_dfe_refclk_tap_val_status8_t;

static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS8(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS8(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8012228ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012228ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS8", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS8(a,b) cavm_gsercx_lnx_dfe_refclk_tap_val_status8_t
#define bustype_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS8(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS8(a,b) "GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS8"
#define device_bar_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS8(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS8(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS8(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_drv_refclk_afe_ctrl0
 *
 * GSERC Ln Drv Refclk Afe Ctrl0 Register
 */
union cavm_gsercx_lnx_drv_refclk_afe_ctrl0
{
    uint32_t u;
    struct cavm_gsercx_lnx_drv_refclk_afe_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t txdrv_lp_idle         : 1;  /**< [  0:  0](R/W/H) When HIGH, TX driver goes into a low power IDLE model.
                                                                 In this mode, the output termination is not guaranteed to be 50 Ohm closer to 200 Ohm */
#else /* Word 0 - Little Endian */
        uint32_t txdrv_lp_idle         : 1;  /**< [  0:  0](R/W/H) When HIGH, TX driver goes into a low power IDLE model.
                                                                 In this mode, the output termination is not guaranteed to be 50 Ohm closer to 200 Ohm */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_drv_refclk_afe_ctrl0_s cn; */
};
typedef union cavm_gsercx_lnx_drv_refclk_afe_ctrl0 cavm_gsercx_lnx_drv_refclk_afe_ctrl0_t;

static inline uint64_t CAVM_GSERCX_LNX_DRV_REFCLK_AFE_CTRL0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_DRV_REFCLK_AFE_CTRL0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8011c18ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011c18ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_DRV_REFCLK_AFE_CTRL0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_DRV_REFCLK_AFE_CTRL0(a,b) cavm_gsercx_lnx_drv_refclk_afe_ctrl0_t
#define bustype_CAVM_GSERCX_LNX_DRV_REFCLK_AFE_CTRL0(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_DRV_REFCLK_AFE_CTRL0(a,b) "GSERCX_LNX_DRV_REFCLK_AFE_CTRL0"
#define device_bar_CAVM_GSERCX_LNX_DRV_REFCLK_AFE_CTRL0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_DRV_REFCLK_AFE_CTRL0(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_DRV_REFCLK_AFE_CTRL0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_drv_refclk_afe_ctrl3
 *
 * GSERC Ln Drv Refclk Afe Ctrl3 Register
 */
union cavm_gsercx_lnx_drv_refclk_afe_ctrl3
{
    uint32_t u;
    struct cavm_gsercx_lnx_drv_refclk_afe_ctrl3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t txdrv_co_pol          : 3;  /**< [  2:  0](R/W/H) TXEQ coefficient polarity control 0 = no inversion, 1= inverted as follows:

                                                                 000 : no inversion
                                                                 001 : CM1 is inverted
                                                                 010 : C0 is inverted
                                                                 100 : C1 is inverted */
#else /* Word 0 - Little Endian */
        uint32_t txdrv_co_pol          : 3;  /**< [  2:  0](R/W/H) TXEQ coefficient polarity control 0 = no inversion, 1= inverted as follows:

                                                                 000 : no inversion
                                                                 001 : CM1 is inverted
                                                                 010 : C0 is inverted
                                                                 100 : C1 is inverted */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_drv_refclk_afe_ctrl3_s cn; */
};
typedef union cavm_gsercx_lnx_drv_refclk_afe_ctrl3 cavm_gsercx_lnx_drv_refclk_afe_ctrl3_t;

static inline uint64_t CAVM_GSERCX_LNX_DRV_REFCLK_AFE_CTRL3(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_DRV_REFCLK_AFE_CTRL3(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8011c30ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011c30ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_DRV_REFCLK_AFE_CTRL3", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_DRV_REFCLK_AFE_CTRL3(a,b) cavm_gsercx_lnx_drv_refclk_afe_ctrl3_t
#define bustype_CAVM_GSERCX_LNX_DRV_REFCLK_AFE_CTRL3(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_DRV_REFCLK_AFE_CTRL3(a,b) "GSERCX_LNX_DRV_REFCLK_AFE_CTRL3"
#define device_bar_CAVM_GSERCX_LNX_DRV_REFCLK_AFE_CTRL3(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_DRV_REFCLK_AFE_CTRL3(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_DRV_REFCLK_AFE_CTRL3(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_drv_refclk_txeq_ctrl0
 *
 * GSERC Ln Drv Refclk Txeq Ctrl0 Register
 */
union cavm_gsercx_lnx_drv_refclk_txeq_ctrl0
{
    uint32_t u;
    struct cavm_gsercx_lnx_drv_refclk_txeq_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t req                   : 1;  /**< [  0:  0](R/W/H) TXEQ coefficient request
                                                                 Set to 1 to have PHY firmware map the current register coefficient settings to the AFE TXDRV */
#else /* Word 0 - Little Endian */
        uint32_t req                   : 1;  /**< [  0:  0](R/W/H) TXEQ coefficient request
                                                                 Set to 1 to have PHY firmware map the current register coefficient settings to the AFE TXDRV */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_drv_refclk_txeq_ctrl0_s cn; */
};
typedef union cavm_gsercx_lnx_drv_refclk_txeq_ctrl0 cavm_gsercx_lnx_drv_refclk_txeq_ctrl0_t;

static inline uint64_t CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8011d00ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011d00ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL0(a,b) cavm_gsercx_lnx_drv_refclk_txeq_ctrl0_t
#define bustype_CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL0(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL0(a,b) "GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL0"
#define device_bar_CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL0(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_drv_refclk_txeq_ctrl1
 *
 * GSERC Ln Drv Refclk Txeq Ctrl1 Register
 */
union cavm_gsercx_lnx_drv_refclk_txeq_ctrl1
{
    uint32_t u;
    struct cavm_gsercx_lnx_drv_refclk_txeq_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t txeq_c1               : 5;  /**< [  4:  0](R/W/H) TXEQ post-cursor tap C1 coefficient control.
                                                                 0 = min equalization setting
                                                                 31 = max equalization setting

                                                                 Note that need to initiate a TXEQ request to firmware to have TXEQ register
                                                                 values transferred to AFE. */
#else /* Word 0 - Little Endian */
        uint32_t txeq_c1               : 5;  /**< [  4:  0](R/W/H) TXEQ post-cursor tap C1 coefficient control.
                                                                 0 = min equalization setting
                                                                 31 = max equalization setting

                                                                 Note that need to initiate a TXEQ request to firmware to have TXEQ register
                                                                 values transferred to AFE. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_drv_refclk_txeq_ctrl1_s cn; */
};
typedef union cavm_gsercx_lnx_drv_refclk_txeq_ctrl1 cavm_gsercx_lnx_drv_refclk_txeq_ctrl1_t;

static inline uint64_t CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8011d10ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011d10ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL1(a,b) cavm_gsercx_lnx_drv_refclk_txeq_ctrl1_t
#define bustype_CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL1(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL1(a,b) "GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL1"
#define device_bar_CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL1(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_drv_refclk_txeq_ctrl3
 *
 * GSERC Ln Drv Refclk Txeq Ctrl3 Register
 */
union cavm_gsercx_lnx_drv_refclk_txeq_ctrl3
{
    uint32_t u;
    struct cavm_gsercx_lnx_drv_refclk_txeq_ctrl3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t txeq_cm1              : 4;  /**< [  3:  0](R/W/H) TXEQ pre-cursor tap CM1 cofficient control.

                                                                 0 = min equalization setting
                                                                 15 = max equalization setting

                                                                 Note that need to initiate a TXEQ request to firmware to have TXEQ register
                                                                 values transferred to AFE. */
#else /* Word 0 - Little Endian */
        uint32_t txeq_cm1              : 4;  /**< [  3:  0](R/W/H) TXEQ pre-cursor tap CM1 cofficient control.

                                                                 0 = min equalization setting
                                                                 15 = max equalization setting

                                                                 Note that need to initiate a TXEQ request to firmware to have TXEQ register
                                                                 values transferred to AFE. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_drv_refclk_txeq_ctrl3_s cn; */
};
typedef union cavm_gsercx_lnx_drv_refclk_txeq_ctrl3 cavm_gsercx_lnx_drv_refclk_txeq_ctrl3_t;

static inline uint64_t CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL3(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL3(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8011d20ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011d20ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL3", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL3(a,b) cavm_gsercx_lnx_drv_refclk_txeq_ctrl3_t
#define bustype_CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL3(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL3(a,b) "GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL3"
#define device_bar_CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL3(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL3(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL3(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_drv_refclk_txeq_ctrl4
 *
 * GSERC Ln Drv Refclk Txeq Ctrl4 Register
 */
union cavm_gsercx_lnx_drv_refclk_txeq_ctrl4
{
    uint32_t u;
    struct cavm_gsercx_lnx_drv_refclk_txeq_ctrl4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t swing_1lsb_mode       : 1;  /**< [  1:  1](R/W/H) TXDRV swing 1-LSB mode enable. */
        uint32_t txeq_1lsb_mode        : 1;  /**< [  0:  0](R/W/H) TXEQ 1-LSB mode enable. */
#else /* Word 0 - Little Endian */
        uint32_t txeq_1lsb_mode        : 1;  /**< [  0:  0](R/W/H) TXEQ 1-LSB mode enable. */
        uint32_t swing_1lsb_mode       : 1;  /**< [  1:  1](R/W/H) TXDRV swing 1-LSB mode enable. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_drv_refclk_txeq_ctrl4_s cn9; */
    /* struct cavm_gsercx_lnx_drv_refclk_txeq_ctrl4_s f95o; */
    struct cavm_gsercx_lnx_drv_refclk_txeq_ctrl4_loki
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t swing_1lsb_mode       : 1;  /**< [  1:  1](R/W/H) TXDRV swing 1-LSB mode enable. Do not use. For device characterization test use only. */
        uint32_t txeq_1lsb_mode        : 1;  /**< [  0:  0](R/W/H) TXEQ 1-LSB mode enable. Do not use. For device characterization test use only. */
#else /* Word 0 - Little Endian */
        uint32_t txeq_1lsb_mode        : 1;  /**< [  0:  0](R/W/H) TXEQ 1-LSB mode enable. Do not use. For device characterization test use only. */
        uint32_t swing_1lsb_mode       : 1;  /**< [  1:  1](R/W/H) TXDRV swing 1-LSB mode enable. Do not use. For device characterization test use only. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } loki;
};
typedef union cavm_gsercx_lnx_drv_refclk_txeq_ctrl4 cavm_gsercx_lnx_drv_refclk_txeq_ctrl4_t;

static inline uint64_t CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL4(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL4(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8011d28ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011d28ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL4", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL4(a,b) cavm_gsercx_lnx_drv_refclk_txeq_ctrl4_t
#define bustype_CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL4(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL4(a,b) "GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL4"
#define device_bar_CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL4(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL4(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL4(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_drv_refclk_txeq_ctrl5
 *
 * GSERC Ln Drv Refclk Txeq Ctrl5 Register
 */
union cavm_gsercx_lnx_drv_refclk_txeq_ctrl5
{
    uint32_t u;
    struct cavm_gsercx_lnx_drv_refclk_txeq_ctrl5_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t drv_swing             : 3;  /**< [  2:  0](R/W/H) TXDRV swing control.
                                                                 0 = min swing
                                                                 7 = 100% swing */
#else /* Word 0 - Little Endian */
        uint32_t drv_swing             : 3;  /**< [  2:  0](R/W/H) TXDRV swing control.
                                                                 0 = min swing
                                                                 7 = 100% swing */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_drv_refclk_txeq_ctrl5_s cn; */
};
typedef union cavm_gsercx_lnx_drv_refclk_txeq_ctrl5 cavm_gsercx_lnx_drv_refclk_txeq_ctrl5_t;

static inline uint64_t CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL5(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL5(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8011d30ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011d30ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL5", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL5(a,b) cavm_gsercx_lnx_drv_refclk_txeq_ctrl5_t
#define bustype_CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL5(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL5(a,b) "GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL5"
#define device_bar_CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL5(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL5(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL5(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_drv_refclk_txeq_status0
 *
 * GSERC Ln Drv Refclk Txeq Status0 Register
 */
union cavm_gsercx_lnx_drv_refclk_txeq_status0
{
    uint32_t u;
    struct cavm_gsercx_lnx_drv_refclk_txeq_status0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t ack                   : 1;  /**< [  0:  0](R/W/H) TXEQ coefficient acknowledge
                                                                 This register is set to 1 by PHY firmware once AFE updates are complete. Cleared when req = 0 */
#else /* Word 0 - Little Endian */
        uint32_t ack                   : 1;  /**< [  0:  0](R/W/H) TXEQ coefficient acknowledge
                                                                 This register is set to 1 by PHY firmware once AFE updates are complete. Cleared when req = 0 */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_drv_refclk_txeq_status0_s cn; */
};
typedef union cavm_gsercx_lnx_drv_refclk_txeq_status0 cavm_gsercx_lnx_drv_refclk_txeq_status0_t;

static inline uint64_t CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8011d08ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011d08ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS0(a,b) cavm_gsercx_lnx_drv_refclk_txeq_status0_t
#define bustype_CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS0(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS0(a,b) "GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS0"
#define device_bar_CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS0(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_drv_refclk_txeq_status1
 *
 * GSERC Ln Drv Refclk Txeq Status1 Register
 */
union cavm_gsercx_lnx_drv_refclk_txeq_status1
{
    uint32_t u;
    struct cavm_gsercx_lnx_drv_refclk_txeq_status1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t txeq_c1               : 5;  /**< [  4:  0](R/W/H) TXEQ post-cursor tap C1 coefficient status. */
#else /* Word 0 - Little Endian */
        uint32_t txeq_c1               : 5;  /**< [  4:  0](R/W/H) TXEQ post-cursor tap C1 coefficient status. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_drv_refclk_txeq_status1_s cn; */
};
typedef union cavm_gsercx_lnx_drv_refclk_txeq_status1 cavm_gsercx_lnx_drv_refclk_txeq_status1_t;

static inline uint64_t CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8011d40ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011d40ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS1(a,b) cavm_gsercx_lnx_drv_refclk_txeq_status1_t
#define bustype_CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS1(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS1(a,b) "GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS1"
#define device_bar_CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS1(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_drv_refclk_txeq_status2
 *
 * GSERC Ln Drv Refclk Txeq Status2 Register
 */
union cavm_gsercx_lnx_drv_refclk_txeq_status2
{
    uint32_t u;
    struct cavm_gsercx_lnx_drv_refclk_txeq_status2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t txeq_cm1              : 4;  /**< [  3:  0](R/W/H) TXEQ post-cursor tap CM1 coefficient status. */
#else /* Word 0 - Little Endian */
        uint32_t txeq_cm1              : 4;  /**< [  3:  0](R/W/H) TXEQ post-cursor tap CM1 coefficient status. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_drv_refclk_txeq_status2_s cn; */
};
typedef union cavm_gsercx_lnx_drv_refclk_txeq_status2 cavm_gsercx_lnx_drv_refclk_txeq_status2_t;

static inline uint64_t CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS2(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS2(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8011d48ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011d48ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS2(a,b) cavm_gsercx_lnx_drv_refclk_txeq_status2_t
#define bustype_CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS2(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS2(a,b) "GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS2"
#define device_bar_CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS2(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS2(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS2(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_drv_refclk_txeq_status3
 *
 * GSERC Ln Drv Refclk Txeq Status3 Register
 */
union cavm_gsercx_lnx_drv_refclk_txeq_status3
{
    uint32_t u;
    struct cavm_gsercx_lnx_drv_refclk_txeq_status3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t txeq_c0               : 3;  /**< [  2:  0](R/W/H) TXEQ main-cursor tap C0 coefficient status. */
#else /* Word 0 - Little Endian */
        uint32_t txeq_c0               : 3;  /**< [  2:  0](R/W/H) TXEQ main-cursor tap C0 coefficient status. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_drv_refclk_txeq_status3_s cn; */
};
typedef union cavm_gsercx_lnx_drv_refclk_txeq_status3 cavm_gsercx_lnx_drv_refclk_txeq_status3_t;

static inline uint64_t CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS3(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS3(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8011d50ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011d50ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS3", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS3(a,b) cavm_gsercx_lnx_drv_refclk_txeq_status3_t
#define bustype_CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS3(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS3(a,b) "GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS3"
#define device_bar_CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS3(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS3(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS3(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_adapt_cfg0
 *
 * GSERC Ln Feature Adapt Cfg0 Register
 */
union cavm_gsercx_lnx_feature_adapt_cfg0
{
    uint32_t u;
    struct cavm_gsercx_lnx_feature_adapt_cfg0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t ena_8b10b             : 1;  /**< [  0:  0](R/W/H) Enables modifications for 8b10b encoded signals in RX adaptations. */
#else /* Word 0 - Little Endian */
        uint32_t ena_8b10b             : 1;  /**< [  0:  0](R/W/H) Enables modifications for 8b10b encoded signals in RX adaptations. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_feature_adapt_cfg0_s cn; */
};
typedef union cavm_gsercx_lnx_feature_adapt_cfg0 cavm_gsercx_lnx_feature_adapt_cfg0_t;

static inline uint64_t CAVM_GSERCX_LNX_FEATURE_ADAPT_CFG0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_FEATURE_ADAPT_CFG0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013478ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013478ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_FEATURE_ADAPT_CFG0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_FEATURE_ADAPT_CFG0(a,b) cavm_gsercx_lnx_feature_adapt_cfg0_t
#define bustype_CAVM_GSERCX_LNX_FEATURE_ADAPT_CFG0(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_FEATURE_ADAPT_CFG0(a,b) "GSERCX_LNX_FEATURE_ADAPT_CFG0"
#define device_bar_CAVM_GSERCX_LNX_FEATURE_ADAPT_CFG0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_FEATURE_ADAPT_CFG0(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_FEATURE_ADAPT_CFG0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_adapt_cont_cfg0
 *
 * GSERC Ln Feature Adapt Cont Cfg0 Register
 */
union cavm_gsercx_lnx_feature_adapt_cont_cfg0
{
    uint32_t u;
    struct cavm_gsercx_lnx_feature_adapt_cont_cfg0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t stagger_taps          : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t en                    : 1;  /**< [  0:  0](R/W/H) Enables continuous background adaptation. */
#else /* Word 0 - Little Endian */
        uint32_t en                    : 1;  /**< [  0:  0](R/W/H) Enables continuous background adaptation. */
        uint32_t stagger_taps          : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_feature_adapt_cont_cfg0_s cn; */
};
typedef union cavm_gsercx_lnx_feature_adapt_cont_cfg0 cavm_gsercx_lnx_feature_adapt_cont_cfg0_t;

static inline uint64_t CAVM_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013580ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013580ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_FEATURE_ADAPT_CONT_CFG0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG0(a,b) cavm_gsercx_lnx_feature_adapt_cont_cfg0_t
#define bustype_CAVM_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG0(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG0(a,b) "GSERCX_LNX_FEATURE_ADAPT_CONT_CFG0"
#define device_bar_CAVM_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG0(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_adapt_cont_cfg1
 *
 * GSERC Ln Feature Adapt Cont Cfg1 Register
 */
union cavm_gsercx_lnx_feature_adapt_cont_cfg1
{
    uint32_t u;
    struct cavm_gsercx_lnx_feature_adapt_cont_cfg1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t interval_7_0          : 8;  /**< [  7:  0](R/W/H) How often in ms to run continuous adaptations 1ms to ~279 mins. */
#else /* Word 0 - Little Endian */
        uint32_t interval_7_0          : 8;  /**< [  7:  0](R/W/H) How often in ms to run continuous adaptations 1ms to ~279 mins. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_feature_adapt_cont_cfg1_s cn; */
};
typedef union cavm_gsercx_lnx_feature_adapt_cont_cfg1 cavm_gsercx_lnx_feature_adapt_cont_cfg1_t;

static inline uint64_t CAVM_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013588ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013588ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_FEATURE_ADAPT_CONT_CFG1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG1(a,b) cavm_gsercx_lnx_feature_adapt_cont_cfg1_t
#define bustype_CAVM_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG1(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG1(a,b) "GSERCX_LNX_FEATURE_ADAPT_CONT_CFG1"
#define device_bar_CAVM_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG1(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_adapt_cont_cfg2
 *
 * GSERC Ln Feature Adapt Cont Cfg2 Register
 */
union cavm_gsercx_lnx_feature_adapt_cont_cfg2
{
    uint32_t u;
    struct cavm_gsercx_lnx_feature_adapt_cont_cfg2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t interval_15_8         : 8;  /**< [  7:  0](R/W/H) How often in ms to run continuous adaptations 1ms to ~279 mins. */
#else /* Word 0 - Little Endian */
        uint32_t interval_15_8         : 8;  /**< [  7:  0](R/W/H) How often in ms to run continuous adaptations 1ms to ~279 mins. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_feature_adapt_cont_cfg2_s cn; */
};
typedef union cavm_gsercx_lnx_feature_adapt_cont_cfg2 cavm_gsercx_lnx_feature_adapt_cont_cfg2_t;

static inline uint64_t CAVM_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG2(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG2(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013590ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013590ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_FEATURE_ADAPT_CONT_CFG2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG2(a,b) cavm_gsercx_lnx_feature_adapt_cont_cfg2_t
#define bustype_CAVM_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG2(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG2(a,b) "GSERCX_LNX_FEATURE_ADAPT_CONT_CFG2"
#define device_bar_CAVM_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG2(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG2(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG2(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_adapt_cont_cfg3
 *
 * GSERC Ln Feature Adapt Cont Cfg3 Register
 */
union cavm_gsercx_lnx_feature_adapt_cont_cfg3
{
    uint32_t u;
    struct cavm_gsercx_lnx_feature_adapt_cont_cfg3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t interval_23_16        : 8;  /**< [  7:  0](R/W/H) How often in ms to run continuous adaptations 1ms to ~279 mins. */
#else /* Word 0 - Little Endian */
        uint32_t interval_23_16        : 8;  /**< [  7:  0](R/W/H) How often in ms to run continuous adaptations 1ms to ~279 mins. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_feature_adapt_cont_cfg3_s cn; */
};
typedef union cavm_gsercx_lnx_feature_adapt_cont_cfg3 cavm_gsercx_lnx_feature_adapt_cont_cfg3_t;

static inline uint64_t CAVM_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG3(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG3(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013598ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013598ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_FEATURE_ADAPT_CONT_CFG3", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG3(a,b) cavm_gsercx_lnx_feature_adapt_cont_cfg3_t
#define bustype_CAVM_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG3(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG3(a,b) "GSERCX_LNX_FEATURE_ADAPT_CONT_CFG3"
#define device_bar_CAVM_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG3(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG3(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG3(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_cdr_adapt_smpl_cfg
 *
 * GSERC Ln Feature Cdr Adapt Smpl Cfg Register
 */
union cavm_gsercx_lnx_feature_cdr_adapt_smpl_cfg
{
    uint32_t u;
    struct cavm_gsercx_lnx_feature_cdr_adapt_smpl_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t cdr_smpl_start_val_sel : 1; /**< [  3:  3](R/W/H) Reserved. */
        uint32_t cdr_smpl_cont_en      : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t cdr_smpl_eie_en       : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t cdr_smpl_init_en      : 1;  /**< [  0:  0](R/W/H) Enables CDR sampling point initial adaptation. */
#else /* Word 0 - Little Endian */
        uint32_t cdr_smpl_init_en      : 1;  /**< [  0:  0](R/W/H) Enables CDR sampling point initial adaptation. */
        uint32_t cdr_smpl_eie_en       : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t cdr_smpl_cont_en      : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t cdr_smpl_start_val_sel : 1; /**< [  3:  3](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_feature_cdr_adapt_smpl_cfg_s cn; */
};
typedef union cavm_gsercx_lnx_feature_cdr_adapt_smpl_cfg cavm_gsercx_lnx_feature_cdr_adapt_smpl_cfg_t;

static inline uint64_t CAVM_GSERCX_LNX_FEATURE_CDR_ADAPT_SMPL_CFG(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_FEATURE_CDR_ADAPT_SMPL_CFG(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013550ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013550ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_FEATURE_CDR_ADAPT_SMPL_CFG", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_FEATURE_CDR_ADAPT_SMPL_CFG(a,b) cavm_gsercx_lnx_feature_cdr_adapt_smpl_cfg_t
#define bustype_CAVM_GSERCX_LNX_FEATURE_CDR_ADAPT_SMPL_CFG(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_FEATURE_CDR_ADAPT_SMPL_CFG(a,b) "GSERCX_LNX_FEATURE_CDR_ADAPT_SMPL_CFG"
#define device_bar_CAVM_GSERCX_LNX_FEATURE_CDR_ADAPT_SMPL_CFG(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_FEATURE_CDR_ADAPT_SMPL_CFG(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_FEATURE_CDR_ADAPT_SMPL_CFG(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_cdr_cal_cfg0
 *
 * GSERC Ln Feature Cdr Cal Cfg0 Register
 */
union cavm_gsercx_lnx_feature_cdr_cal_cfg0
{
    uint32_t u;
    struct cavm_gsercx_lnx_feature_cdr_cal_cfg0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t cdr_iq_cal_result_sel : 2;  /**< [  6:  5](R/W/H) Selects which CDR I/Q Mismatch Calibration result to use:
                                                                 0x0 = Method 1
                                                                 0x1 = Method 2
                                                                 0x2 = Method 3
                                                                 0x3 = Reserved */
        uint32_t cdr_iq_cal3_en        : 1;  /**< [  4:  4](R/W/H) Enables CDR I/Q Mismatch Calibration Method 3. */
        uint32_t cdr_iq_cal2_en        : 1;  /**< [  3:  3](R/W/H) Enables CDR I/Q Mismatch Calibration Method 2. */
        uint32_t cdr_iq_cal1_en        : 1;  /**< [  2:  2](R/W/H) Enables CDR I/Q Mismatch Calibration Method 1. */
        uint32_t vco_freq_dosc_en      : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t vco_freq_en           : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t vco_freq_en           : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t vco_freq_dosc_en      : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t cdr_iq_cal1_en        : 1;  /**< [  2:  2](R/W/H) Enables CDR I/Q Mismatch Calibration Method 1. */
        uint32_t cdr_iq_cal2_en        : 1;  /**< [  3:  3](R/W/H) Enables CDR I/Q Mismatch Calibration Method 2. */
        uint32_t cdr_iq_cal3_en        : 1;  /**< [  4:  4](R/W/H) Enables CDR I/Q Mismatch Calibration Method 3. */
        uint32_t cdr_iq_cal_result_sel : 2;  /**< [  6:  5](R/W/H) Selects which CDR I/Q Mismatch Calibration result to use:
                                                                 0x0 = Method 1
                                                                 0x1 = Method 2
                                                                 0x2 = Method 3
                                                                 0x3 = Reserved */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_feature_cdr_cal_cfg0_s cn; */
};
typedef union cavm_gsercx_lnx_feature_cdr_cal_cfg0 cavm_gsercx_lnx_feature_cdr_cal_cfg0_t;

static inline uint64_t CAVM_GSERCX_LNX_FEATURE_CDR_CAL_CFG0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_FEATURE_CDR_CAL_CFG0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013430ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013430ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_FEATURE_CDR_CAL_CFG0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_FEATURE_CDR_CAL_CFG0(a,b) cavm_gsercx_lnx_feature_cdr_cal_cfg0_t
#define bustype_CAVM_GSERCX_LNX_FEATURE_CDR_CAL_CFG0(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_FEATURE_CDR_CAL_CFG0(a,b) "GSERCX_LNX_FEATURE_CDR_CAL_CFG0"
#define device_bar_CAVM_GSERCX_LNX_FEATURE_CDR_CAL_CFG0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_FEATURE_CDR_CAL_CFG0(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_FEATURE_CDR_CAL_CFG0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_cdr_lock_check_cfg0
 *
 * GSERC Ln Feature Cdr Lock Check Cfg0 Register
 */
union cavm_gsercx_lnx_feature_cdr_lock_check_cfg0
{
    uint32_t u;
    struct cavm_gsercx_lnx_feature_cdr_lock_check_cfg0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t los_en                : 1;  /**< [  1:  1](R/W/H) Enables Eye Monitor LOS detection during restart check after CDR lock is detected. */
        uint32_t freq_measure_en       : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t freq_measure_en       : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t los_en                : 1;  /**< [  1:  1](R/W/H) Enables Eye Monitor LOS detection during restart check after CDR lock is detected. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_feature_cdr_lock_check_cfg0_s cn; */
};
typedef union cavm_gsercx_lnx_feature_cdr_lock_check_cfg0 cavm_gsercx_lnx_feature_cdr_lock_check_cfg0_t;

static inline uint64_t CAVM_GSERCX_LNX_FEATURE_CDR_LOCK_CHECK_CFG0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_FEATURE_CDR_LOCK_CHECK_CFG0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013458ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013458ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_FEATURE_CDR_LOCK_CHECK_CFG0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_FEATURE_CDR_LOCK_CHECK_CFG0(a,b) cavm_gsercx_lnx_feature_cdr_lock_check_cfg0_t
#define bustype_CAVM_GSERCX_LNX_FEATURE_CDR_LOCK_CHECK_CFG0(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_FEATURE_CDR_LOCK_CHECK_CFG0(a,b) "GSERCX_LNX_FEATURE_CDR_LOCK_CHECK_CFG0"
#define device_bar_CAVM_GSERCX_LNX_FEATURE_CDR_LOCK_CHECK_CFG0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_FEATURE_CDR_LOCK_CHECK_CFG0(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_FEATURE_CDR_LOCK_CHECK_CFG0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_ctle_adapt_apg_cfg
 *
 * GSERC Ln Feature Ctle Adapt Apg Cfg Register
 */
union cavm_gsercx_lnx_feature_ctle_adapt_apg_cfg
{
    uint32_t u;
    struct cavm_gsercx_lnx_feature_ctle_adapt_apg_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t eie1_en               : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t eie0_en               : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t init1_en              : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t init0_en              : 1;  /**< [  0:  0](R/W/H) LEQ APG adaptation enable. */
#else /* Word 0 - Little Endian */
        uint32_t init0_en              : 1;  /**< [  0:  0](R/W/H) LEQ APG adaptation enable. */
        uint32_t init1_en              : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t eie0_en               : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t eie1_en               : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_feature_ctle_adapt_apg_cfg_s cn; */
};
typedef union cavm_gsercx_lnx_feature_ctle_adapt_apg_cfg cavm_gsercx_lnx_feature_ctle_adapt_apg_cfg_t;

static inline uint64_t CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_APG_CFG(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_APG_CFG(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013498ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013498ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_FEATURE_CTLE_ADAPT_APG_CFG", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_APG_CFG(a,b) cavm_gsercx_lnx_feature_ctle_adapt_apg_cfg_t
#define bustype_CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_APG_CFG(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_APG_CFG(a,b) "GSERCX_LNX_FEATURE_CTLE_ADAPT_APG_CFG"
#define device_bar_CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_APG_CFG(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_APG_CFG(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_APG_CFG(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_ctle_adapt_hfg_cfg0
 *
 * GSERC Ln Feature Ctle Adapt Hfg Cfg0 Register
 */
union cavm_gsercx_lnx_feature_ctle_adapt_hfg_cfg0
{
    uint32_t u;
    struct cavm_gsercx_lnx_feature_ctle_adapt_hfg_cfg0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t cont_en               : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t eie1_en               : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t eie0_en               : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t init1_en              : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t init0_en              : 1;  /**< [  0:  0](R/W/H) LEQ HFG adaptation enable edge-based algorithm. */
#else /* Word 0 - Little Endian */
        uint32_t init0_en              : 1;  /**< [  0:  0](R/W/H) LEQ HFG adaptation enable edge-based algorithm. */
        uint32_t init1_en              : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t eie0_en               : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t eie1_en               : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t cont_en               : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_feature_ctle_adapt_hfg_cfg0_s cn; */
};
typedef union cavm_gsercx_lnx_feature_ctle_adapt_hfg_cfg0 cavm_gsercx_lnx_feature_ctle_adapt_hfg_cfg0_t;

static inline uint64_t CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_HFG_CFG0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_HFG_CFG0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a80134a0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80134a0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_FEATURE_CTLE_ADAPT_HFG_CFG0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_HFG_CFG0(a,b) cavm_gsercx_lnx_feature_ctle_adapt_hfg_cfg0_t
#define bustype_CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_HFG_CFG0(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_HFG_CFG0(a,b) "GSERCX_LNX_FEATURE_CTLE_ADAPT_HFG_CFG0"
#define device_bar_CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_HFG_CFG0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_HFG_CFG0(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_HFG_CFG0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_ctle_adapt_hfg_cfg1
 *
 * GSERC Ln Feature Ctle Adapt Hfg Cfg1 Register
 */
union cavm_gsercx_lnx_feature_ctle_adapt_hfg_cfg1
{
    uint32_t u;
    struct cavm_gsercx_lnx_feature_ctle_adapt_hfg_cfg1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t eie1_en               : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t eie0_en               : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t init1_en              : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t init0_en              : 1;  /**< [  0:  0](R/W/H) LEQ HFG adaptation enable data-based algorithm. */
#else /* Word 0 - Little Endian */
        uint32_t init0_en              : 1;  /**< [  0:  0](R/W/H) LEQ HFG adaptation enable data-based algorithm. */
        uint32_t init1_en              : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t eie0_en               : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t eie1_en               : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_feature_ctle_adapt_hfg_cfg1_s cn; */
};
typedef union cavm_gsercx_lnx_feature_ctle_adapt_hfg_cfg1 cavm_gsercx_lnx_feature_ctle_adapt_hfg_cfg1_t;

static inline uint64_t CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_HFG_CFG1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_HFG_CFG1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a80134a8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80134a8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_FEATURE_CTLE_ADAPT_HFG_CFG1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_HFG_CFG1(a,b) cavm_gsercx_lnx_feature_ctle_adapt_hfg_cfg1_t
#define bustype_CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_HFG_CFG1(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_HFG_CFG1(a,b) "GSERCX_LNX_FEATURE_CTLE_ADAPT_HFG_CFG1"
#define device_bar_CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_HFG_CFG1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_HFG_CFG1(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_HFG_CFG1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_ctle_adapt_hfg_cfg2
 *
 * GSERC Ln Feature Ctle Adapt Hfg Cfg2 Register
 */
union cavm_gsercx_lnx_feature_ctle_adapt_hfg_cfg2
{
    uint32_t u;
    struct cavm_gsercx_lnx_feature_ctle_adapt_hfg_cfg2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t eie1_result_sel       : 2;  /**< [  7:  6](R/W/H) Reserved. */
        uint32_t eie0_result_sel       : 2;  /**< [  5:  4](R/W/H) Reserved. */
        uint32_t init1_result_sel      : 2;  /**< [  3:  2](R/W/H) Reserved. */
        uint32_t init0_result_sel      : 2;  /**< [  1:  0](R/W/H) LEQ HFG adaptation algorithm selection
                                                                 0x0 = Maximize eye width edge based adaptation
                                                                 0x1 = Maximize eye height data based adaptation
                                                                 0x2 = Average of Edge & Data result
                                                                 0x3 = Reserved */
#else /* Word 0 - Little Endian */
        uint32_t init0_result_sel      : 2;  /**< [  1:  0](R/W/H) LEQ HFG adaptation algorithm selection
                                                                 0x0 = Maximize eye width edge based adaptation
                                                                 0x1 = Maximize eye height data based adaptation
                                                                 0x2 = Average of Edge & Data result
                                                                 0x3 = Reserved */
        uint32_t init1_result_sel      : 2;  /**< [  3:  2](R/W/H) Reserved. */
        uint32_t eie0_result_sel       : 2;  /**< [  5:  4](R/W/H) Reserved. */
        uint32_t eie1_result_sel       : 2;  /**< [  7:  6](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_feature_ctle_adapt_hfg_cfg2_s cn; */
};
typedef union cavm_gsercx_lnx_feature_ctle_adapt_hfg_cfg2 cavm_gsercx_lnx_feature_ctle_adapt_hfg_cfg2_t;

static inline uint64_t CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_HFG_CFG2(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_HFG_CFG2(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a80134b0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80134b0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_FEATURE_CTLE_ADAPT_HFG_CFG2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_HFG_CFG2(a,b) cavm_gsercx_lnx_feature_ctle_adapt_hfg_cfg2_t
#define bustype_CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_HFG_CFG2(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_HFG_CFG2(a,b) "GSERCX_LNX_FEATURE_CTLE_ADAPT_HFG_CFG2"
#define device_bar_CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_HFG_CFG2(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_HFG_CFG2(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_HFG_CFG2(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_ctle_adapt_lfg_cfg
 *
 * GSERC Ln Feature Ctle Adapt Lfg Cfg Register
 */
union cavm_gsercx_lnx_feature_ctle_adapt_lfg_cfg
{
    uint32_t u;
    struct cavm_gsercx_lnx_feature_ctle_adapt_lfg_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t eie1_en               : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t eie0_en               : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t init1_en              : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t init0_en              : 1;  /**< [  0:  0](R/W/H) LEQ LFG equalization adaptation enable. */
#else /* Word 0 - Little Endian */
        uint32_t init0_en              : 1;  /**< [  0:  0](R/W/H) LEQ LFG equalization adaptation enable. */
        uint32_t init1_en              : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t eie0_en               : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t eie1_en               : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_feature_ctle_adapt_lfg_cfg_s cn; */
};
typedef union cavm_gsercx_lnx_feature_ctle_adapt_lfg_cfg cavm_gsercx_lnx_feature_ctle_adapt_lfg_cfg_t;

static inline uint64_t CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_LFG_CFG(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_LFG_CFG(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013490ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013490ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_FEATURE_CTLE_ADAPT_LFG_CFG", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_LFG_CFG(a,b) cavm_gsercx_lnx_feature_ctle_adapt_lfg_cfg_t
#define bustype_CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_LFG_CFG(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_LFG_CFG(a,b) "GSERCX_LNX_FEATURE_CTLE_ADAPT_LFG_CFG"
#define device_bar_CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_LFG_CFG(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_LFG_CFG(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_LFG_CFG(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_ctle_adapt_mbs_cfg0
 *
 * GSERC Ln Feature Ctle Adapt Mbs Cfg0 Register
 */
union cavm_gsercx_lnx_feature_ctle_adapt_mbs_cfg0
{
    uint32_t u;
    struct cavm_gsercx_lnx_feature_ctle_adapt_mbs_cfg0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t eie1_en               : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t eie0_en               : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t init1_en              : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t init0_en              : 1;  /**< [  0:  0](R/W/H) Mid-Band Shaping MBS adaptation enable edge-based. */
#else /* Word 0 - Little Endian */
        uint32_t init0_en              : 1;  /**< [  0:  0](R/W/H) Mid-Band Shaping MBS adaptation enable edge-based. */
        uint32_t init1_en              : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t eie0_en               : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t eie1_en               : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_feature_ctle_adapt_mbs_cfg0_s cn; */
};
typedef union cavm_gsercx_lnx_feature_ctle_adapt_mbs_cfg0 cavm_gsercx_lnx_feature_ctle_adapt_mbs_cfg0_t;

static inline uint64_t CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_MBS_CFG0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_MBS_CFG0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a80134b8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80134b8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_FEATURE_CTLE_ADAPT_MBS_CFG0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_MBS_CFG0(a,b) cavm_gsercx_lnx_feature_ctle_adapt_mbs_cfg0_t
#define bustype_CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_MBS_CFG0(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_MBS_CFG0(a,b) "GSERCX_LNX_FEATURE_CTLE_ADAPT_MBS_CFG0"
#define device_bar_CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_MBS_CFG0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_MBS_CFG0(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_MBS_CFG0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_ctle_adapt_mbs_cfg1
 *
 * GSERC Ln Feature Ctle Adapt Mbs Cfg1 Register
 */
union cavm_gsercx_lnx_feature_ctle_adapt_mbs_cfg1
{
    uint32_t u;
    struct cavm_gsercx_lnx_feature_ctle_adapt_mbs_cfg1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t eie1_en               : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t eie0_en               : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t init1_en              : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t init0_en              : 1;  /**< [  0:  0](R/W/H) Mid-Band Shaping MBS adaptation enable data-based. */
#else /* Word 0 - Little Endian */
        uint32_t init0_en              : 1;  /**< [  0:  0](R/W/H) Mid-Band Shaping MBS adaptation enable data-based. */
        uint32_t init1_en              : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t eie0_en               : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t eie1_en               : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_feature_ctle_adapt_mbs_cfg1_s cn; */
};
typedef union cavm_gsercx_lnx_feature_ctle_adapt_mbs_cfg1 cavm_gsercx_lnx_feature_ctle_adapt_mbs_cfg1_t;

static inline uint64_t CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_MBS_CFG1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_MBS_CFG1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a80134c0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80134c0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_FEATURE_CTLE_ADAPT_MBS_CFG1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_MBS_CFG1(a,b) cavm_gsercx_lnx_feature_ctle_adapt_mbs_cfg1_t
#define bustype_CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_MBS_CFG1(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_MBS_CFG1(a,b) "GSERCX_LNX_FEATURE_CTLE_ADAPT_MBS_CFG1"
#define device_bar_CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_MBS_CFG1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_MBS_CFG1(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_MBS_CFG1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_ctle_adapt_mbs_cfg2
 *
 * GSERC Ln Feature Ctle Adapt Mbs Cfg2 Register
 */
union cavm_gsercx_lnx_feature_ctle_adapt_mbs_cfg2
{
    uint32_t u;
    struct cavm_gsercx_lnx_feature_ctle_adapt_mbs_cfg2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t eie1_result_sel       : 2;  /**< [  7:  6](R/W/H) Reserved. */
        uint32_t eie0_result_sel       : 2;  /**< [  5:  4](R/W/H) Reserved. */
        uint32_t init1_result_sel      : 2;  /**< [  3:  2](R/W/H) Reserved. */
        uint32_t init0_result_sel      : 2;  /**< [  1:  0](R/W/H) Mid-Band Shaping MBS adaptation algorithm selection
                                                                 0x0 = Maximize eye width edge based adaptation
                                                                 0x1 = Maximize eye height data based adaptation
                                                                 0x2 = Average of Edge & Data result
                                                                 0x3 = Reserved */
#else /* Word 0 - Little Endian */
        uint32_t init0_result_sel      : 2;  /**< [  1:  0](R/W/H) Mid-Band Shaping MBS adaptation algorithm selection
                                                                 0x0 = Maximize eye width edge based adaptation
                                                                 0x1 = Maximize eye height data based adaptation
                                                                 0x2 = Average of Edge & Data result
                                                                 0x3 = Reserved */
        uint32_t init1_result_sel      : 2;  /**< [  3:  2](R/W/H) Reserved. */
        uint32_t eie0_result_sel       : 2;  /**< [  5:  4](R/W/H) Reserved. */
        uint32_t eie1_result_sel       : 2;  /**< [  7:  6](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_feature_ctle_adapt_mbs_cfg2_s cn; */
};
typedef union cavm_gsercx_lnx_feature_ctle_adapt_mbs_cfg2 cavm_gsercx_lnx_feature_ctle_adapt_mbs_cfg2_t;

static inline uint64_t CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_MBS_CFG2(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_MBS_CFG2(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a80134c8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80134c8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_FEATURE_CTLE_ADAPT_MBS_CFG2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_MBS_CFG2(a,b) cavm_gsercx_lnx_feature_ctle_adapt_mbs_cfg2_t
#define bustype_CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_MBS_CFG2(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_MBS_CFG2(a,b) "GSERCX_LNX_FEATURE_CTLE_ADAPT_MBS_CFG2"
#define device_bar_CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_MBS_CFG2(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_MBS_CFG2(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_MBS_CFG2(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_ctle_adapt_ple_cfg
 *
 * GSERC Ln Feature Ctle Adapt Ple Cfg Register
 */
union cavm_gsercx_lnx_feature_ctle_adapt_ple_cfg
{
    uint32_t u;
    struct cavm_gsercx_lnx_feature_ctle_adapt_ple_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t eie_en                : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t init_en               : 1;  /**< [  0:  0](R/W/H) Enables PLE_ATT adaptation for initial adaptation. */
#else /* Word 0 - Little Endian */
        uint32_t init_en               : 1;  /**< [  0:  0](R/W/H) Enables PLE_ATT adaptation for initial adaptation. */
        uint32_t eie_en                : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_feature_ctle_adapt_ple_cfg_s cn; */
};
typedef union cavm_gsercx_lnx_feature_ctle_adapt_ple_cfg cavm_gsercx_lnx_feature_ctle_adapt_ple_cfg_t;

static inline uint64_t CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_PLE_CFG(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_PLE_CFG(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013488ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013488ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_FEATURE_CTLE_ADAPT_PLE_CFG", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_PLE_CFG(a,b) cavm_gsercx_lnx_feature_ctle_adapt_ple_cfg_t
#define bustype_CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_PLE_CFG(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_PLE_CFG(a,b) "GSERCX_LNX_FEATURE_CTLE_ADAPT_PLE_CFG"
#define device_bar_CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_PLE_CFG(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_PLE_CFG(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_FEATURE_CTLE_ADAPT_PLE_CFG(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_dfe_adapt_cfg
 *
 * GSERC Ln Feature Dfe Adapt Cfg Register
 */
union cavm_gsercx_lnx_feature_dfe_adapt_cfg
{
    uint32_t u;
    struct cavm_gsercx_lnx_feature_dfe_adapt_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t method_sel            : 1;  /**< [  0:  0](R/W/H) DFE tap adaptation algorithm selection:
                                                                 0x0 = SS-LMS
                                                                 0x1 = Pattern Based Zero Forcing */
#else /* Word 0 - Little Endian */
        uint32_t method_sel            : 1;  /**< [  0:  0](R/W/H) DFE tap adaptation algorithm selection:
                                                                 0x0 = SS-LMS
                                                                 0x1 = Pattern Based Zero Forcing */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_feature_dfe_adapt_cfg_s cn; */
};
typedef union cavm_gsercx_lnx_feature_dfe_adapt_cfg cavm_gsercx_lnx_feature_dfe_adapt_cfg_t;

static inline uint64_t CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_CFG(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_CFG(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013508ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013508ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_FEATURE_DFE_ADAPT_CFG", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_CFG(a,b) cavm_gsercx_lnx_feature_dfe_adapt_cfg_t
#define bustype_CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_CFG(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_CFG(a,b) "GSERCX_LNX_FEATURE_DFE_ADAPT_CFG"
#define device_bar_CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_CFG(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_CFG(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_CFG(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_dfe_adapt_tap1_cfg
 *
 * GSERC Ln Feature Dfe Adapt Tap1 Cfg Register
 */
union cavm_gsercx_lnx_feature_dfe_adapt_tap1_cfg
{
    uint32_t u;
    struct cavm_gsercx_lnx_feature_dfe_adapt_tap1_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t tap1_start_val_sel    : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t tap1_cont_en          : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t tap1_eie_en           : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t tap1_init_en          : 1;  /**< [  0:  0](R/W/H) DFE tap1 adaptation enable. */
#else /* Word 0 - Little Endian */
        uint32_t tap1_init_en          : 1;  /**< [  0:  0](R/W/H) DFE tap1 adaptation enable. */
        uint32_t tap1_eie_en           : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t tap1_cont_en          : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t tap1_start_val_sel    : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_feature_dfe_adapt_tap1_cfg_s cn; */
};
typedef union cavm_gsercx_lnx_feature_dfe_adapt_tap1_cfg cavm_gsercx_lnx_feature_dfe_adapt_tap1_cfg_t;

static inline uint64_t CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP1_CFG(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP1_CFG(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013510ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013510ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_FEATURE_DFE_ADAPT_TAP1_CFG", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP1_CFG(a,b) cavm_gsercx_lnx_feature_dfe_adapt_tap1_cfg_t
#define bustype_CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP1_CFG(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP1_CFG(a,b) "GSERCX_LNX_FEATURE_DFE_ADAPT_TAP1_CFG"
#define device_bar_CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP1_CFG(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP1_CFG(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP1_CFG(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_dfe_adapt_tap2_cfg
 *
 * GSERC Ln Feature Dfe Adapt Tap2 Cfg Register
 */
union cavm_gsercx_lnx_feature_dfe_adapt_tap2_cfg
{
    uint32_t u;
    struct cavm_gsercx_lnx_feature_dfe_adapt_tap2_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t tap2_start_val_sel    : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t tap2_cont_en          : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t tap2_eie_en           : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t tap2_init_en          : 1;  /**< [  0:  0](R/W/H) DFE tap2 adaptation enable. */
#else /* Word 0 - Little Endian */
        uint32_t tap2_init_en          : 1;  /**< [  0:  0](R/W/H) DFE tap2 adaptation enable. */
        uint32_t tap2_eie_en           : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t tap2_cont_en          : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t tap2_start_val_sel    : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_feature_dfe_adapt_tap2_cfg_s cn; */
};
typedef union cavm_gsercx_lnx_feature_dfe_adapt_tap2_cfg cavm_gsercx_lnx_feature_dfe_adapt_tap2_cfg_t;

static inline uint64_t CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP2_CFG(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP2_CFG(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013518ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013518ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_FEATURE_DFE_ADAPT_TAP2_CFG", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP2_CFG(a,b) cavm_gsercx_lnx_feature_dfe_adapt_tap2_cfg_t
#define bustype_CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP2_CFG(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP2_CFG(a,b) "GSERCX_LNX_FEATURE_DFE_ADAPT_TAP2_CFG"
#define device_bar_CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP2_CFG(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP2_CFG(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP2_CFG(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_dfe_adapt_tap3_cfg
 *
 * GSERC Ln Feature Dfe Adapt Tap3 Cfg Register
 */
union cavm_gsercx_lnx_feature_dfe_adapt_tap3_cfg
{
    uint32_t u;
    struct cavm_gsercx_lnx_feature_dfe_adapt_tap3_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t tap3_start_val_sel    : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t tap3_cont_en          : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t tap3_eie_en           : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t tap3_init_en          : 1;  /**< [  0:  0](R/W/H) DFE tap3 adaptation enable. */
#else /* Word 0 - Little Endian */
        uint32_t tap3_init_en          : 1;  /**< [  0:  0](R/W/H) DFE tap3 adaptation enable. */
        uint32_t tap3_eie_en           : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t tap3_cont_en          : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t tap3_start_val_sel    : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_feature_dfe_adapt_tap3_cfg_s cn; */
};
typedef union cavm_gsercx_lnx_feature_dfe_adapt_tap3_cfg cavm_gsercx_lnx_feature_dfe_adapt_tap3_cfg_t;

static inline uint64_t CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP3_CFG(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP3_CFG(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013520ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013520ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_FEATURE_DFE_ADAPT_TAP3_CFG", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP3_CFG(a,b) cavm_gsercx_lnx_feature_dfe_adapt_tap3_cfg_t
#define bustype_CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP3_CFG(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP3_CFG(a,b) "GSERCX_LNX_FEATURE_DFE_ADAPT_TAP3_CFG"
#define device_bar_CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP3_CFG(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP3_CFG(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP3_CFG(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_dfe_adapt_tap4_cfg
 *
 * GSERC Ln Feature Dfe Adapt Tap4 Cfg Register
 */
union cavm_gsercx_lnx_feature_dfe_adapt_tap4_cfg
{
    uint32_t u;
    struct cavm_gsercx_lnx_feature_dfe_adapt_tap4_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t tap4_start_val_sel    : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t tap4_cont_en          : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t tap4_eie_en           : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t tap4_init_en          : 1;  /**< [  0:  0](R/W/H) DFE tap4 adaptation enable. */
#else /* Word 0 - Little Endian */
        uint32_t tap4_init_en          : 1;  /**< [  0:  0](R/W/H) DFE tap4 adaptation enable. */
        uint32_t tap4_eie_en           : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t tap4_cont_en          : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t tap4_start_val_sel    : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_feature_dfe_adapt_tap4_cfg_s cn; */
};
typedef union cavm_gsercx_lnx_feature_dfe_adapt_tap4_cfg cavm_gsercx_lnx_feature_dfe_adapt_tap4_cfg_t;

static inline uint64_t CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP4_CFG(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP4_CFG(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013528ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013528ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_FEATURE_DFE_ADAPT_TAP4_CFG", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP4_CFG(a,b) cavm_gsercx_lnx_feature_dfe_adapt_tap4_cfg_t
#define bustype_CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP4_CFG(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP4_CFG(a,b) "GSERCX_LNX_FEATURE_DFE_ADAPT_TAP4_CFG"
#define device_bar_CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP4_CFG(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP4_CFG(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP4_CFG(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_dfe_adapt_tap5_cfg
 *
 * GSERC Ln Feature Dfe Adapt Tap5 Cfg Register
 */
union cavm_gsercx_lnx_feature_dfe_adapt_tap5_cfg
{
    uint32_t u;
    struct cavm_gsercx_lnx_feature_dfe_adapt_tap5_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t tap5_start_val_sel    : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t tap5_cont_en          : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t tap5_eie_en           : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t tap5_init_en          : 1;  /**< [  0:  0](R/W/H) DFE tap5 adaptation enable. */
#else /* Word 0 - Little Endian */
        uint32_t tap5_init_en          : 1;  /**< [  0:  0](R/W/H) DFE tap5 adaptation enable. */
        uint32_t tap5_eie_en           : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t tap5_cont_en          : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t tap5_start_val_sel    : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_feature_dfe_adapt_tap5_cfg_s cn; */
};
typedef union cavm_gsercx_lnx_feature_dfe_adapt_tap5_cfg cavm_gsercx_lnx_feature_dfe_adapt_tap5_cfg_t;

static inline uint64_t CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP5_CFG(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP5_CFG(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013530ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013530ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_FEATURE_DFE_ADAPT_TAP5_CFG", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP5_CFG(a,b) cavm_gsercx_lnx_feature_dfe_adapt_tap5_cfg_t
#define bustype_CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP5_CFG(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP5_CFG(a,b) "GSERCX_LNX_FEATURE_DFE_ADAPT_TAP5_CFG"
#define device_bar_CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP5_CFG(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP5_CFG(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP5_CFG(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_dfe_adapt_tap6_cfg
 *
 * GSERC Ln Feature Dfe Adapt Tap6 Cfg Register
 */
union cavm_gsercx_lnx_feature_dfe_adapt_tap6_cfg
{
    uint32_t u;
    struct cavm_gsercx_lnx_feature_dfe_adapt_tap6_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t tap6_start_val_sel    : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t tap6_cont_en          : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t tap6_eie_en           : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t tap6_init_en          : 1;  /**< [  0:  0](R/W/H) DFE tap6 adaptation enable. */
#else /* Word 0 - Little Endian */
        uint32_t tap6_init_en          : 1;  /**< [  0:  0](R/W/H) DFE tap6 adaptation enable. */
        uint32_t tap6_eie_en           : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t tap6_cont_en          : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t tap6_start_val_sel    : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_feature_dfe_adapt_tap6_cfg_s cn; */
};
typedef union cavm_gsercx_lnx_feature_dfe_adapt_tap6_cfg cavm_gsercx_lnx_feature_dfe_adapt_tap6_cfg_t;

static inline uint64_t CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP6_CFG(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP6_CFG(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013538ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013538ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_FEATURE_DFE_ADAPT_TAP6_CFG", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP6_CFG(a,b) cavm_gsercx_lnx_feature_dfe_adapt_tap6_cfg_t
#define bustype_CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP6_CFG(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP6_CFG(a,b) "GSERCX_LNX_FEATURE_DFE_ADAPT_TAP6_CFG"
#define device_bar_CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP6_CFG(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP6_CFG(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP6_CFG(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_dfe_adapt_tap7_cfg
 *
 * GSERC Ln Feature Dfe Adapt Tap7 Cfg Register
 */
union cavm_gsercx_lnx_feature_dfe_adapt_tap7_cfg
{
    uint32_t u;
    struct cavm_gsercx_lnx_feature_dfe_adapt_tap7_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t tap7_start_val_sel    : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t tap7_cont_en          : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t tap7_eie_en           : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t tap7_init_en          : 1;  /**< [  0:  0](R/W/H) DFE tap7 adaptation enable. */
#else /* Word 0 - Little Endian */
        uint32_t tap7_init_en          : 1;  /**< [  0:  0](R/W/H) DFE tap7 adaptation enable. */
        uint32_t tap7_eie_en           : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t tap7_cont_en          : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t tap7_start_val_sel    : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_feature_dfe_adapt_tap7_cfg_s cn; */
};
typedef union cavm_gsercx_lnx_feature_dfe_adapt_tap7_cfg cavm_gsercx_lnx_feature_dfe_adapt_tap7_cfg_t;

static inline uint64_t CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP7_CFG(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP7_CFG(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013540ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013540ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_FEATURE_DFE_ADAPT_TAP7_CFG", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP7_CFG(a,b) cavm_gsercx_lnx_feature_dfe_adapt_tap7_cfg_t
#define bustype_CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP7_CFG(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP7_CFG(a,b) "GSERCX_LNX_FEATURE_DFE_ADAPT_TAP7_CFG"
#define device_bar_CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP7_CFG(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP7_CFG(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP7_CFG(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_dfe_adapt_tap8_cfg
 *
 * GSERC Ln Feature Dfe Adapt Tap8 Cfg Register
 */
union cavm_gsercx_lnx_feature_dfe_adapt_tap8_cfg
{
    uint32_t u;
    struct cavm_gsercx_lnx_feature_dfe_adapt_tap8_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t tap8_start_val_sel    : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t tap8_cont_en          : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t tap8_eie_en           : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t tap8_init_en          : 1;  /**< [  0:  0](R/W/H) DFE tap8 adaptation enable. */
#else /* Word 0 - Little Endian */
        uint32_t tap8_init_en          : 1;  /**< [  0:  0](R/W/H) DFE tap8 adaptation enable. */
        uint32_t tap8_eie_en           : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t tap8_cont_en          : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t tap8_start_val_sel    : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_feature_dfe_adapt_tap8_cfg_s cn; */
};
typedef union cavm_gsercx_lnx_feature_dfe_adapt_tap8_cfg cavm_gsercx_lnx_feature_dfe_adapt_tap8_cfg_t;

static inline uint64_t CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP8_CFG(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP8_CFG(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013548ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013548ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_FEATURE_DFE_ADAPT_TAP8_CFG", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP8_CFG(a,b) cavm_gsercx_lnx_feature_dfe_adapt_tap8_cfg_t
#define bustype_CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP8_CFG(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP8_CFG(a,b) "GSERCX_LNX_FEATURE_DFE_ADAPT_TAP8_CFG"
#define device_bar_CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP8_CFG(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP8_CFG(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP8_CFG(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_dfe_cfg
 *
 * GSERC Ln Feature Dfe Cfg Register
 */
union cavm_gsercx_lnx_feature_dfe_cfg
{
    uint32_t u;
    struct cavm_gsercx_lnx_feature_dfe_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tap8_en               : 1;  /**< [  7:  7](R/W/H) DFE Tap 8 enable. */
        uint32_t tap7_en               : 1;  /**< [  6:  6](R/W/H) DFE Tap 7 enable. */
        uint32_t tap6_en               : 1;  /**< [  5:  5](R/W/H) DFE Tap 6 enable. */
        uint32_t tap5_en               : 1;  /**< [  4:  4](R/W/H) DFE Tap 5 enable. */
        uint32_t tap4_en               : 1;  /**< [  3:  3](R/W/H) DFE Tap 4 enable. */
        uint32_t tap3_en               : 1;  /**< [  2:  2](R/W/H) DFE Tap 3 enable. */
        uint32_t tap2_en               : 1;  /**< [  1:  1](R/W/H) DFE Tap 2 enable. */
        uint32_t tap1_en               : 1;  /**< [  0:  0](R/W/H) DFE Tap 1 enable. */
#else /* Word 0 - Little Endian */
        uint32_t tap1_en               : 1;  /**< [  0:  0](R/W/H) DFE Tap 1 enable. */
        uint32_t tap2_en               : 1;  /**< [  1:  1](R/W/H) DFE Tap 2 enable. */
        uint32_t tap3_en               : 1;  /**< [  2:  2](R/W/H) DFE Tap 3 enable. */
        uint32_t tap4_en               : 1;  /**< [  3:  3](R/W/H) DFE Tap 4 enable. */
        uint32_t tap5_en               : 1;  /**< [  4:  4](R/W/H) DFE Tap 5 enable. */
        uint32_t tap6_en               : 1;  /**< [  5:  5](R/W/H) DFE Tap 6 enable. */
        uint32_t tap7_en               : 1;  /**< [  6:  6](R/W/H) DFE Tap 7 enable. */
        uint32_t tap8_en               : 1;  /**< [  7:  7](R/W/H) DFE Tap 8 enable. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_feature_dfe_cfg_s cn; */
};
typedef union cavm_gsercx_lnx_feature_dfe_cfg cavm_gsercx_lnx_feature_dfe_cfg_t;

static inline uint64_t CAVM_GSERCX_LNX_FEATURE_DFE_CFG(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_FEATURE_DFE_CFG(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013500ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013500ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_FEATURE_DFE_CFG", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_FEATURE_DFE_CFG(a,b) cavm_gsercx_lnx_feature_dfe_cfg_t
#define bustype_CAVM_GSERCX_LNX_FEATURE_DFE_CFG(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_FEATURE_DFE_CFG(a,b) "GSERCX_LNX_FEATURE_DFE_CFG"
#define device_bar_CAVM_GSERCX_LNX_FEATURE_DFE_CFG(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_FEATURE_DFE_CFG(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_FEATURE_DFE_CFG(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_dfe_offset_cal_cfg0_rsvd
 *
 * INTERNAL: GSERC Ln Feature Dfe Offset Cal Cfg0 Register
 */
union cavm_gsercx_lnx_feature_dfe_offset_cal_cfg0_rsvd
{
    uint32_t u;
    struct cavm_gsercx_lnx_feature_dfe_offset_cal_cfg0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t vscan_en              : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t summeven_en           : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t summodd_en            : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t summodd_en            : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t summeven_en           : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t vscan_en              : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_feature_dfe_offset_cal_cfg0_rsvd_s cn; */
};
typedef union cavm_gsercx_lnx_feature_dfe_offset_cal_cfg0_rsvd cavm_gsercx_lnx_feature_dfe_offset_cal_cfg0_rsvd_t;

static inline uint64_t CAVM_GSERCX_LNX_FEATURE_DFE_OFFSET_CAL_CFG0_RSVD(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_FEATURE_DFE_OFFSET_CAL_CFG0_RSVD(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013418ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013418ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_FEATURE_DFE_OFFSET_CAL_CFG0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_FEATURE_DFE_OFFSET_CAL_CFG0_RSVD(a,b) cavm_gsercx_lnx_feature_dfe_offset_cal_cfg0_rsvd_t
#define bustype_CAVM_GSERCX_LNX_FEATURE_DFE_OFFSET_CAL_CFG0_RSVD(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_FEATURE_DFE_OFFSET_CAL_CFG0_RSVD(a,b) "GSERCX_LNX_FEATURE_DFE_OFFSET_CAL_CFG0_RSVD"
#define device_bar_CAVM_GSERCX_LNX_FEATURE_DFE_OFFSET_CAL_CFG0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_FEATURE_DFE_OFFSET_CAL_CFG0_RSVD(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_FEATURE_DFE_OFFSET_CAL_CFG0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_dfe_offset_cal_cfg1_rsvd
 *
 * INTERNAL: GSERC Ln Feature Dfe Offset Cal Cfg1 Register
 */
union cavm_gsercx_lnx_feature_dfe_offset_cal_cfg1_rsvd
{
    uint32_t u;
    struct cavm_gsercx_lnx_feature_dfe_offset_cal_cfg1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t eyeslicer_en          : 1;  /**< [  6:  6](R/W/H) Reserved. */
        uint32_t edgeslicerodd_en      : 1;  /**< [  5:  5](R/W/H) Reserved. */
        uint32_t edgeslicereven_en     : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t dataslicerodd0_en     : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t dataslicerodd1_en     : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t dataslicereven0_en    : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t dataslicereven1_en    : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t dataslicereven1_en    : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t dataslicereven0_en    : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t dataslicerodd1_en     : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t dataslicerodd0_en     : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t edgeslicereven_en     : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t edgeslicerodd_en      : 1;  /**< [  5:  5](R/W/H) Reserved. */
        uint32_t eyeslicer_en          : 1;  /**< [  6:  6](R/W/H) Reserved. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_feature_dfe_offset_cal_cfg1_rsvd_s cn; */
};
typedef union cavm_gsercx_lnx_feature_dfe_offset_cal_cfg1_rsvd cavm_gsercx_lnx_feature_dfe_offset_cal_cfg1_rsvd_t;

static inline uint64_t CAVM_GSERCX_LNX_FEATURE_DFE_OFFSET_CAL_CFG1_RSVD(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_FEATURE_DFE_OFFSET_CAL_CFG1_RSVD(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013428ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013428ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_FEATURE_DFE_OFFSET_CAL_CFG1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_FEATURE_DFE_OFFSET_CAL_CFG1_RSVD(a,b) cavm_gsercx_lnx_feature_dfe_offset_cal_cfg1_rsvd_t
#define bustype_CAVM_GSERCX_LNX_FEATURE_DFE_OFFSET_CAL_CFG1_RSVD(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_FEATURE_DFE_OFFSET_CAL_CFG1_RSVD(a,b) "GSERCX_LNX_FEATURE_DFE_OFFSET_CAL_CFG1_RSVD"
#define device_bar_CAVM_GSERCX_LNX_FEATURE_DFE_OFFSET_CAL_CFG1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_FEATURE_DFE_OFFSET_CAL_CFG1_RSVD(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_FEATURE_DFE_OFFSET_CAL_CFG1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_leq_offset_cal_cfg0_rsvd
 *
 * INTERNAL: GSERC Ln Feature Leq Offset Cal Cfg0 Register
 */
union cavm_gsercx_lnx_feature_leq_offset_cal_cfg0_rsvd
{
    uint32_t u;
    struct cavm_gsercx_lnx_feature_leq_offset_cal_cfg0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t gn_en                 : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t eq4_en                : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t eq3_en                : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t eq2_en                : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t eq1_en                : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t eq1_en                : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t eq2_en                : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t eq3_en                : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t eq4_en                : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t gn_en                 : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_feature_leq_offset_cal_cfg0_rsvd_s cn; */
};
typedef union cavm_gsercx_lnx_feature_leq_offset_cal_cfg0_rsvd cavm_gsercx_lnx_feature_leq_offset_cal_cfg0_rsvd_t;

static inline uint64_t CAVM_GSERCX_LNX_FEATURE_LEQ_OFFSET_CAL_CFG0_RSVD(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_FEATURE_LEQ_OFFSET_CAL_CFG0_RSVD(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013410ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013410ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_FEATURE_LEQ_OFFSET_CAL_CFG0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_FEATURE_LEQ_OFFSET_CAL_CFG0_RSVD(a,b) cavm_gsercx_lnx_feature_leq_offset_cal_cfg0_rsvd_t
#define bustype_CAVM_GSERCX_LNX_FEATURE_LEQ_OFFSET_CAL_CFG0_RSVD(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_FEATURE_LEQ_OFFSET_CAL_CFG0_RSVD(a,b) "GSERCX_LNX_FEATURE_LEQ_OFFSET_CAL_CFG0_RSVD"
#define device_bar_CAVM_GSERCX_LNX_FEATURE_LEQ_OFFSET_CAL_CFG0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_FEATURE_LEQ_OFFSET_CAL_CFG0_RSVD(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_FEATURE_LEQ_OFFSET_CAL_CFG0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_periodic_check_cfg0
 *
 * GSERC Ln Feature Periodic Check Cfg0 Register
 */
union cavm_gsercx_lnx_feature_periodic_check_cfg0
{
    uint32_t u;
    struct cavm_gsercx_lnx_feature_periodic_check_cfg0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t los_en                : 1;  /**< [  1:  1](R/W/H) Enables Eye Monitor LOS detection during periodic restart check while in LOCKED state. */
        uint32_t freq_measure_en       : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t freq_measure_en       : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t los_en                : 1;  /**< [  1:  1](R/W/H) Enables Eye Monitor LOS detection during periodic restart check while in LOCKED state. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_feature_periodic_check_cfg0_s cn; */
};
typedef union cavm_gsercx_lnx_feature_periodic_check_cfg0 cavm_gsercx_lnx_feature_periodic_check_cfg0_t;

static inline uint64_t CAVM_GSERCX_LNX_FEATURE_PERIODIC_CHECK_CFG0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_FEATURE_PERIODIC_CHECK_CFG0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013468ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013468ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_FEATURE_PERIODIC_CHECK_CFG0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_FEATURE_PERIODIC_CHECK_CFG0(a,b) cavm_gsercx_lnx_feature_periodic_check_cfg0_t
#define bustype_CAVM_GSERCX_LNX_FEATURE_PERIODIC_CHECK_CFG0(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_FEATURE_PERIODIC_CHECK_CFG0(a,b) "GSERCX_LNX_FEATURE_PERIODIC_CHECK_CFG0"
#define device_bar_CAVM_GSERCX_LNX_FEATURE_PERIODIC_CHECK_CFG0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_FEATURE_PERIODIC_CHECK_CFG0(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_FEATURE_PERIODIC_CHECK_CFG0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_pre_locked_check_cfg0
 *
 * GSERC Ln Feature Pre Locked Check Cfg0 Register
 */
union cavm_gsercx_lnx_feature_pre_locked_check_cfg0
{
    uint32_t u;
    struct cavm_gsercx_lnx_feature_pre_locked_check_cfg0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t los_en                : 1;  /**< [  1:  1](R/W/H) Enables Eye Monitor LOS detection during restart check before entering LOCKED state. */
        uint32_t freq_measure_en       : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t freq_measure_en       : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t los_en                : 1;  /**< [  1:  1](R/W/H) Enables Eye Monitor LOS detection during restart check before entering LOCKED state. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_feature_pre_locked_check_cfg0_s cn; */
};
typedef union cavm_gsercx_lnx_feature_pre_locked_check_cfg0 cavm_gsercx_lnx_feature_pre_locked_check_cfg0_t;

static inline uint64_t CAVM_GSERCX_LNX_FEATURE_PRE_LOCKED_CHECK_CFG0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_FEATURE_PRE_LOCKED_CHECK_CFG0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013460ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013460ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_FEATURE_PRE_LOCKED_CHECK_CFG0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_FEATURE_PRE_LOCKED_CHECK_CFG0(a,b) cavm_gsercx_lnx_feature_pre_locked_check_cfg0_t
#define bustype_CAVM_GSERCX_LNX_FEATURE_PRE_LOCKED_CHECK_CFG0(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_FEATURE_PRE_LOCKED_CHECK_CFG0(a,b) "GSERCX_LNX_FEATURE_PRE_LOCKED_CHECK_CFG0"
#define device_bar_CAVM_GSERCX_LNX_FEATURE_PRE_LOCKED_CHECK_CFG0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_FEATURE_PRE_LOCKED_CHECK_CFG0(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_FEATURE_PRE_LOCKED_CHECK_CFG0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_rext_cal_result_cfg0_rsvd
 *
 * INTERNAL: GSERC Ln Feature Rext Cal Result Cfg0 Register
 */
union cavm_gsercx_lnx_feature_rext_cal_result_cfg0_rsvd
{
    uint32_t u;
    struct cavm_gsercx_lnx_feature_rext_cal_result_cfg0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t rxdfe_cmlr_en         : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t rxdfe_cmli_en         : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t rxleq_biasi_trim_en   : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t rxterm_val_en         : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t rxterm_val_en         : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t rxleq_biasi_trim_en   : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t rxdfe_cmli_en         : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t rxdfe_cmlr_en         : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_feature_rext_cal_result_cfg0_rsvd_s cn; */
};
typedef union cavm_gsercx_lnx_feature_rext_cal_result_cfg0_rsvd cavm_gsercx_lnx_feature_rext_cal_result_cfg0_rsvd_t;

static inline uint64_t CAVM_GSERCX_LNX_FEATURE_REXT_CAL_RESULT_CFG0_RSVD(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_FEATURE_REXT_CAL_RESULT_CFG0_RSVD(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013408ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013408ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_FEATURE_REXT_CAL_RESULT_CFG0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_FEATURE_REXT_CAL_RESULT_CFG0_RSVD(a,b) cavm_gsercx_lnx_feature_rext_cal_result_cfg0_rsvd_t
#define bustype_CAVM_GSERCX_LNX_FEATURE_REXT_CAL_RESULT_CFG0_RSVD(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_FEATURE_REXT_CAL_RESULT_CFG0_RSVD(a,b) "GSERCX_LNX_FEATURE_REXT_CAL_RESULT_CFG0_RSVD"
#define device_bar_CAVM_GSERCX_LNX_FEATURE_REXT_CAL_RESULT_CFG0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_FEATURE_REXT_CAL_RESULT_CFG0_RSVD(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_FEATURE_REXT_CAL_RESULT_CFG0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_rxterm_cfg0
 *
 * GSERC Ln Feature Rxterm Cfg0 Register
 */
union cavm_gsercx_lnx_feature_rxterm_cfg0
{
    uint32_t u;
    struct cavm_gsercx_lnx_feature_rxterm_cfg0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t ac_coupled            : 1;  /**< [  0:  0](R/W/H) Configures AC/DC coupling of the lane
                                                                 0 = DC coupled internal RX termination common-mode voltage floating
                                                                 1 = AC coupled internal RX termination common-mode voltage shorted to vssa */
#else /* Word 0 - Little Endian */
        uint32_t ac_coupled            : 1;  /**< [  0:  0](R/W/H) Configures AC/DC coupling of the lane
                                                                 0 = DC coupled internal RX termination common-mode voltage floating
                                                                 1 = AC coupled internal RX termination common-mode voltage shorted to vssa */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_feature_rxterm_cfg0_s cn; */
};
typedef union cavm_gsercx_lnx_feature_rxterm_cfg0 cavm_gsercx_lnx_feature_rxterm_cfg0_t;

static inline uint64_t CAVM_GSERCX_LNX_FEATURE_RXTERM_CFG0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_FEATURE_RXTERM_CFG0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013400ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013400ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_FEATURE_RXTERM_CFG0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_FEATURE_RXTERM_CFG0(a,b) cavm_gsercx_lnx_feature_rxterm_cfg0_t
#define bustype_CAVM_GSERCX_LNX_FEATURE_RXTERM_CFG0(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_FEATURE_RXTERM_CFG0(a,b) "GSERCX_LNX_FEATURE_RXTERM_CFG0"
#define device_bar_CAVM_GSERCX_LNX_FEATURE_RXTERM_CFG0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_FEATURE_RXTERM_CFG0(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_FEATURE_RXTERM_CFG0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_spare_cfg0_rsvd
 *
 * GSERC Ln Feature Spare Cfg0 Register
 */
union cavm_gsercx_lnx_feature_spare_cfg0_rsvd
{
    uint32_t u;
    struct cavm_gsercx_lnx_feature_spare_cfg0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Set bit 7 to enable continuous data-based HFG adaptation.
                                                                 Do not change any other bits in this register. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Set bit 7 to enable continuous data-based HFG adaptation.
                                                                 Do not change any other bits in this register. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_feature_spare_cfg0_rsvd_s cn; */
};
typedef union cavm_gsercx_lnx_feature_spare_cfg0_rsvd cavm_gsercx_lnx_feature_spare_cfg0_rsvd_t;

static inline uint64_t CAVM_GSERCX_LNX_FEATURE_SPARE_CFG0_RSVD(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_FEATURE_SPARE_CFG0_RSVD(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013680ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_FEATURE_SPARE_CFG0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_FEATURE_SPARE_CFG0_RSVD(a,b) cavm_gsercx_lnx_feature_spare_cfg0_rsvd_t
#define bustype_CAVM_GSERCX_LNX_FEATURE_SPARE_CFG0_RSVD(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_FEATURE_SPARE_CFG0_RSVD(a,b) "GSERCX_LNX_FEATURE_SPARE_CFG0_RSVD"
#define device_bar_CAVM_GSERCX_LNX_FEATURE_SPARE_CFG0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_FEATURE_SPARE_CFG0_RSVD(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_FEATURE_SPARE_CFG0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_spare_cfg6_rsvd
 *
 * GSERC Ln Feature Spare Cfg6 Register
 */
union cavm_gsercx_lnx_feature_spare_cfg6_rsvd
{
    uint32_t u;
    struct cavm_gsercx_lnx_feature_spare_cfg6_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Use only bit 5 for PHY Lane Rx CDR lock state machine reset. See GSERC Software Initialization. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Use only bit 5 for PHY Lane Rx CDR lock state machine reset. See GSERC Software Initialization. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_feature_spare_cfg6_rsvd_s cn; */
};
typedef union cavm_gsercx_lnx_feature_spare_cfg6_rsvd cavm_gsercx_lnx_feature_spare_cfg6_rsvd_t;

static inline uint64_t CAVM_GSERCX_LNX_FEATURE_SPARE_CFG6_RSVD(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_FEATURE_SPARE_CFG6_RSVD(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80136b0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_FEATURE_SPARE_CFG6_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_FEATURE_SPARE_CFG6_RSVD(a,b) cavm_gsercx_lnx_feature_spare_cfg6_rsvd_t
#define bustype_CAVM_GSERCX_LNX_FEATURE_SPARE_CFG6_RSVD(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_FEATURE_SPARE_CFG6_RSVD(a,b) "GSERCX_LNX_FEATURE_SPARE_CFG6_RSVD"
#define device_bar_CAVM_GSERCX_LNX_FEATURE_SPARE_CFG6_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_FEATURE_SPARE_CFG6_RSVD(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_FEATURE_SPARE_CFG6_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_test_cfg0
 *
 * GSERC Ln Feature Test Cfg0 Register
 */
union cavm_gsercx_lnx_feature_test_cfg0
{
    uint32_t u;
    struct cavm_gsercx_lnx_feature_test_cfg0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t lt_txdrv_dis          : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t tx_coeff_sweep_en     : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t cdr_decimation_dis    : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t rx_ctrl_dis           : 1;  /**< [  1:  1](R/W/H) Disables the firmware rx_ctrl MSM. */
        uint32_t lane_msm_dis          : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t lane_msm_dis          : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t rx_ctrl_dis           : 1;  /**< [  1:  1](R/W/H) Disables the firmware rx_ctrl MSM. */
        uint32_t cdr_decimation_dis    : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t tx_coeff_sweep_en     : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t lt_txdrv_dis          : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_feature_test_cfg0_s cn; */
};
typedef union cavm_gsercx_lnx_feature_test_cfg0 cavm_gsercx_lnx_feature_test_cfg0_t;

static inline uint64_t CAVM_GSERCX_LNX_FEATURE_TEST_CFG0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_FEATURE_TEST_CFG0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013648ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013648ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_FEATURE_TEST_CFG0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_FEATURE_TEST_CFG0(a,b) cavm_gsercx_lnx_feature_test_cfg0_t
#define bustype_CAVM_GSERCX_LNX_FEATURE_TEST_CFG0(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_FEATURE_TEST_CFG0(a,b) "GSERCX_LNX_FEATURE_TEST_CFG0"
#define device_bar_CAVM_GSERCX_LNX_FEATURE_TEST_CFG0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_FEATURE_TEST_CFG0(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_FEATURE_TEST_CFG0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_tx_cal_cfg0_rsvd
 *
 * INTERNAL: GSERC Ln Feature Tx Cal Cfg0 Register
 */
union cavm_gsercx_lnx_feature_tx_cal_cfg0_rsvd
{
    uint32_t u;
    struct cavm_gsercx_lnx_feature_tx_cal_cfg0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t txdp_clock_phase_en   : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t tx_dcd2_en            : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t tx_dcd1_en            : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t reserved_0            : 1;
#else /* Word 0 - Little Endian */
        uint32_t reserved_0            : 1;
        uint32_t tx_dcd1_en            : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t tx_dcd2_en            : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t txdp_clock_phase_en   : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_feature_tx_cal_cfg0_rsvd_s cn; */
};
typedef union cavm_gsercx_lnx_feature_tx_cal_cfg0_rsvd cavm_gsercx_lnx_feature_tx_cal_cfg0_rsvd_t;

static inline uint64_t CAVM_GSERCX_LNX_FEATURE_TX_CAL_CFG0_RSVD(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_FEATURE_TX_CAL_CFG0_RSVD(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013438ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013438ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_FEATURE_TX_CAL_CFG0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_FEATURE_TX_CAL_CFG0_RSVD(a,b) cavm_gsercx_lnx_feature_tx_cal_cfg0_rsvd_t
#define bustype_CAVM_GSERCX_LNX_FEATURE_TX_CAL_CFG0_RSVD(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_FEATURE_TX_CAL_CFG0_RSVD(a,b) "GSERCX_LNX_FEATURE_TX_CAL_CFG0_RSVD"
#define device_bar_CAVM_GSERCX_LNX_FEATURE_TX_CAL_CFG0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_FEATURE_TX_CAL_CFG0_RSVD(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_FEATURE_TX_CAL_CFG0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_eq_hfg_sql_ctrl0
 *
 * GSERC Ln Leq Refclk Eq Hfg Sql Ctrl0 Register
 */
union cavm_gsercx_lnx_leq_refclk_eq_hfg_sql_ctrl0
{
    uint32_t u;
    struct cavm_gsercx_lnx_leq_refclk_eq_hfg_sql_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t eq_hfg_sql_start      : 5;  /**< [  4:  0](R/W/H) LEQ High-Frequency Gain HFG Start Value.
                                                                 If HFG adaptation is not enabled then this register can be used to manually adjust HFG value. */
#else /* Word 0 - Little Endian */
        uint32_t eq_hfg_sql_start      : 5;  /**< [  4:  0](R/W/H) LEQ High-Frequency Gain HFG Start Value.
                                                                 If HFG adaptation is not enabled then this register can be used to manually adjust HFG value. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_leq_refclk_eq_hfg_sql_ctrl0_s cn; */
};
typedef union cavm_gsercx_lnx_leq_refclk_eq_hfg_sql_ctrl0 cavm_gsercx_lnx_leq_refclk_eq_hfg_sql_ctrl0_t;

static inline uint64_t CAVM_GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8011200ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011200ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL0(a,b) cavm_gsercx_lnx_leq_refclk_eq_hfg_sql_ctrl0_t
#define bustype_CAVM_GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL0(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL0(a,b) "GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL0"
#define device_bar_CAVM_GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL0(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_eq_lfg_ctrl0
 *
 * GSERC Ln Leq Refclk Eq Lfg Ctrl0 Register
 */
union cavm_gsercx_lnx_leq_refclk_eq_lfg_ctrl0
{
    uint32_t u;
    struct cavm_gsercx_lnx_leq_refclk_eq_lfg_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t eq_lfg_start          : 5;  /**< [  4:  0](R/W/H) LEQ Low-Frequency Gain LFG Start Value.
                                                                 If LFG adaptation is not enabled then this register can be used to manually adjust LFG value. */
#else /* Word 0 - Little Endian */
        uint32_t eq_lfg_start          : 5;  /**< [  4:  0](R/W/H) LEQ Low-Frequency Gain LFG Start Value.
                                                                 If LFG adaptation is not enabled then this register can be used to manually adjust LFG value. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_leq_refclk_eq_lfg_ctrl0_s cn; */
};
typedef union cavm_gsercx_lnx_leq_refclk_eq_lfg_ctrl0 cavm_gsercx_lnx_leq_refclk_eq_lfg_ctrl0_t;

static inline uint64_t CAVM_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8011400ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011400ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL0(a,b) cavm_gsercx_lnx_leq_refclk_eq_lfg_ctrl0_t
#define bustype_CAVM_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL0(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL0(a,b) "GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL0"
#define device_bar_CAVM_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL0(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_eq_lfg_ctrl1
 *
 * GSERC Ln Leq Refclk Eq Lfg Ctrl1 Register
 */
union cavm_gsercx_lnx_leq_refclk_eq_lfg_ctrl1
{
    uint32_t u;
    struct cavm_gsercx_lnx_leq_refclk_eq_lfg_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t eq_lfg_value_max      : 5;  /**< [  4:  0](R/W/H) LEQ LFG Maximum Value, inclusive. */
#else /* Word 0 - Little Endian */
        uint32_t eq_lfg_value_max      : 5;  /**< [  4:  0](R/W/H) LEQ LFG Maximum Value, inclusive. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_leq_refclk_eq_lfg_ctrl1_s cn; */
};
typedef union cavm_gsercx_lnx_leq_refclk_eq_lfg_ctrl1 cavm_gsercx_lnx_leq_refclk_eq_lfg_ctrl1_t;

static inline uint64_t CAVM_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8011408ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011408ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL1(a,b) cavm_gsercx_lnx_leq_refclk_eq_lfg_ctrl1_t
#define bustype_CAVM_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL1(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL1(a,b) "GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL1"
#define device_bar_CAVM_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL1(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_eq_lfg_ctrl2
 *
 * GSERC Ln Leq Refclk Eq Lfg Ctrl2 Register
 */
union cavm_gsercx_lnx_leq_refclk_eq_lfg_ctrl2
{
    uint32_t u;
    struct cavm_gsercx_lnx_leq_refclk_eq_lfg_ctrl2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t eq_lfg_value_min      : 5;  /**< [  4:  0](R/W/H) LEQ LFG Minimum Value, inclusive. */
#else /* Word 0 - Little Endian */
        uint32_t eq_lfg_value_min      : 5;  /**< [  4:  0](R/W/H) LEQ LFG Minimum Value, inclusive. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_leq_refclk_eq_lfg_ctrl2_s cn; */
};
typedef union cavm_gsercx_lnx_leq_refclk_eq_lfg_ctrl2 cavm_gsercx_lnx_leq_refclk_eq_lfg_ctrl2_t;

static inline uint64_t CAVM_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL2(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL2(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8011410ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011410ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL2(a,b) cavm_gsercx_lnx_leq_refclk_eq_lfg_ctrl2_t
#define bustype_CAVM_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL2(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL2(a,b) "GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL2"
#define device_bar_CAVM_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL2(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL2(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL2(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_eq_mb_ctrl1
 *
 * GSERC Ln Leq Refclk Eq Mb Ctrl1 Register
 */
union cavm_gsercx_lnx_leq_refclk_eq_mb_ctrl1
{
    uint32_t u;
    struct cavm_gsercx_lnx_leq_refclk_eq_mb_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t eq_mbg_start          : 4;  /**< [  7:  4](R/W/H) LEQ Mid-Band Gain MBG Start Value.
                                                                 If mid-band shaping adaptation is not enabled then this register can be used to
                                                                 manually adjust MBG value. */
        uint32_t eq_mbf_start          : 4;  /**< [  3:  0](R/W/H) EQ MBF Start Value
                                                                 LEQ Mid-Band Frequency MBF Start Value.
                                                                 If mid-band shaping adaptation is not enabled then this register can be used to
                                                                 manually adjust MBF value. */
#else /* Word 0 - Little Endian */
        uint32_t eq_mbf_start          : 4;  /**< [  3:  0](R/W/H) EQ MBF Start Value
                                                                 LEQ Mid-Band Frequency MBF Start Value.
                                                                 If mid-band shaping adaptation is not enabled then this register can be used to
                                                                 manually adjust MBF value. */
        uint32_t eq_mbg_start          : 4;  /**< [  7:  4](R/W/H) LEQ Mid-Band Gain MBG Start Value.
                                                                 If mid-band shaping adaptation is not enabled then this register can be used to
                                                                 manually adjust MBG value. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_leq_refclk_eq_mb_ctrl1_s cn; */
};
typedef union cavm_gsercx_lnx_leq_refclk_eq_mb_ctrl1 cavm_gsercx_lnx_leq_refclk_eq_mb_ctrl1_t;

static inline uint64_t CAVM_GSERCX_LNX_LEQ_REFCLK_EQ_MB_CTRL1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_LEQ_REFCLK_EQ_MB_CTRL1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a80114d8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80114d8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_LEQ_REFCLK_EQ_MB_CTRL1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_LEQ_REFCLK_EQ_MB_CTRL1(a,b) cavm_gsercx_lnx_leq_refclk_eq_mb_ctrl1_t
#define bustype_CAVM_GSERCX_LNX_LEQ_REFCLK_EQ_MB_CTRL1(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_LEQ_REFCLK_EQ_MB_CTRL1(a,b) "GSERCX_LNX_LEQ_REFCLK_EQ_MB_CTRL1"
#define device_bar_CAVM_GSERCX_LNX_LEQ_REFCLK_EQ_MB_CTRL1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_LEQ_REFCLK_EQ_MB_CTRL1(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_LEQ_REFCLK_EQ_MB_CTRL1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_gn_apg_ctrl0
 *
 * GSERC Ln Leq Refclk Gn Apg Ctrl0 Register
 */
union cavm_gsercx_lnx_leq_refclk_gn_apg_ctrl0
{
    uint32_t u;
    struct cavm_gsercx_lnx_leq_refclk_gn_apg_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t gn_apg_start          : 3;  /**< [  2:  0](R/W/H) LEQ All-Pass Gain APG Start Value.
                                                                 If APG adaptation is not enabled then this register can be used to manually adjust APG value. */
#else /* Word 0 - Little Endian */
        uint32_t gn_apg_start          : 3;  /**< [  2:  0](R/W/H) LEQ All-Pass Gain APG Start Value.
                                                                 If APG adaptation is not enabled then this register can be used to manually adjust APG value. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_leq_refclk_gn_apg_ctrl0_s cn; */
};
typedef union cavm_gsercx_lnx_leq_refclk_gn_apg_ctrl0 cavm_gsercx_lnx_leq_refclk_gn_apg_ctrl0_t;

static inline uint64_t CAVM_GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8011380ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011380ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL0(a,b) cavm_gsercx_lnx_leq_refclk_gn_apg_ctrl0_t
#define bustype_CAVM_GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL0(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL0(a,b) "GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL0"
#define device_bar_CAVM_GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL0(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_leq_fsm_cmd0
 *
 * GSERC Ln Leq Refclk Leq Fsm Cmd0 Register
 */
union cavm_gsercx_lnx_leq_refclk_leq_fsm_cmd0
{
    uint32_t u;
    struct cavm_gsercx_lnx_leq_refclk_leq_fsm_cmd0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t leq_fsm_cmd_target    : 4;  /**< [  7:  4](R/W/H) FSM Command Target
                                                                 This field has to be set before asserting leq_fsm_cmd_req. */
        uint32_t leq_fsm_cmd_opcode    : 4;  /**< [  3:  0](R/W/H) FSM Command Opcode and Operand
                                                                 This field has to be set before asserting leq_fsm_cmd_req. */
#else /* Word 0 - Little Endian */
        uint32_t leq_fsm_cmd_opcode    : 4;  /**< [  3:  0](R/W/H) FSM Command Opcode and Operand
                                                                 This field has to be set before asserting leq_fsm_cmd_req. */
        uint32_t leq_fsm_cmd_target    : 4;  /**< [  7:  4](R/W/H) FSM Command Target
                                                                 This field has to be set before asserting leq_fsm_cmd_req. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_leq_refclk_leq_fsm_cmd0_s cn; */
};
typedef union cavm_gsercx_lnx_leq_refclk_leq_fsm_cmd0 cavm_gsercx_lnx_leq_refclk_leq_fsm_cmd0_t;

static inline uint64_t CAVM_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CMD0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CMD0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8011108ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011108ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CMD0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CMD0(a,b) cavm_gsercx_lnx_leq_refclk_leq_fsm_cmd0_t
#define bustype_CAVM_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CMD0(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CMD0(a,b) "GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CMD0"
#define device_bar_CAVM_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CMD0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CMD0(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CMD0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_leq_fsm_cmd1
 *
 * GSERC Ln Leq Refclk Leq Fsm Cmd1 Register
 */
union cavm_gsercx_lnx_leq_refclk_leq_fsm_cmd1
{
    uint32_t u;
    struct cavm_gsercx_lnx_leq_refclk_leq_fsm_cmd1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t leq_fsm_cmd_scratchpad : 8; /**< [  7:  0](R/W/H) FSM Scratchpad Write Value
                                                                 This field has to be set before asserting leq_fsm_cmd_req. */
#else /* Word 0 - Little Endian */
        uint32_t leq_fsm_cmd_scratchpad : 8; /**< [  7:  0](R/W/H) FSM Scratchpad Write Value
                                                                 This field has to be set before asserting leq_fsm_cmd_req. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_leq_refclk_leq_fsm_cmd1_s cn; */
};
typedef union cavm_gsercx_lnx_leq_refclk_leq_fsm_cmd1 cavm_gsercx_lnx_leq_refclk_leq_fsm_cmd1_t;

static inline uint64_t CAVM_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CMD1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CMD1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8011110ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011110ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CMD1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CMD1(a,b) cavm_gsercx_lnx_leq_refclk_leq_fsm_cmd1_t
#define bustype_CAVM_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CMD1(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CMD1(a,b) "GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CMD1"
#define device_bar_CAVM_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CMD1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CMD1(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CMD1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_leq_fsm_ctrl0
 *
 * GSERC Ln Leq Refclk Leq Fsm Ctrl0 Register
 */
union cavm_gsercx_lnx_leq_refclk_leq_fsm_ctrl0
{
    uint32_t u;
    struct cavm_gsercx_lnx_leq_refclk_leq_fsm_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t leq_fsm_state_reset   : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t reserved_1            : 1;
        uint32_t leq_fsm_cmd_req       : 1;  /**< [  0:  0](R/W/H) FSM command request
                                                                 Write '1' to this field to set a new FSM command.
                                                                 Write '0' to this field when leq_fsm_cmd_ack is asserted. */
#else /* Word 0 - Little Endian */
        uint32_t leq_fsm_cmd_req       : 1;  /**< [  0:  0](R/W/H) FSM command request
                                                                 Write '1' to this field to set a new FSM command.
                                                                 Write '0' to this field when leq_fsm_cmd_ack is asserted. */
        uint32_t reserved_1            : 1;
        uint32_t leq_fsm_state_reset   : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_leq_refclk_leq_fsm_ctrl0_s cn; */
};
typedef union cavm_gsercx_lnx_leq_refclk_leq_fsm_ctrl0 cavm_gsercx_lnx_leq_refclk_leq_fsm_ctrl0_t;

static inline uint64_t CAVM_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CTRL0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CTRL0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8011100ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011100ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CTRL0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CTRL0(a,b) cavm_gsercx_lnx_leq_refclk_leq_fsm_ctrl0_t
#define bustype_CAVM_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CTRL0(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CTRL0(a,b) "GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CTRL0"
#define device_bar_CAVM_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CTRL0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CTRL0(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CTRL0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_leq_fsm_status0
 *
 * GSERC Ln Leq Refclk Leq Fsm Status0 Register
 */
union cavm_gsercx_lnx_leq_refclk_leq_fsm_status0
{
    uint32_t u;
    struct cavm_gsercx_lnx_leq_refclk_leq_fsm_status0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t leq_fsm_min_clamp     : 1;  /**< [  7:  7](RO/H) Reserved. */
        uint32_t leq_fsm_max_clamp     : 1;  /**< [  6:  6](RO/H) Reserved. */
        uint32_t leq_fsm_status_error2 : 3;  /**< [  5:  3](RO/H) Reserved. */
        uint32_t leq_fsm_status_error1 : 3;  /**< [  2:  0](RO/H) FSM Error Status.
                                                                 0 indicates that there is no error. If an error exists then the following decoding is used:.

                                                                 0 = No error
                                                                 1 = Write request timeout
                                                                 2 = No measurement block
                                                                 3 = Measurement timeout
                                                                 4 = undefined
                                                                 5 = Start value is larger max or smaller than min
                                                                 others = undefined */
#else /* Word 0 - Little Endian */
        uint32_t leq_fsm_status_error1 : 3;  /**< [  2:  0](RO/H) FSM Error Status.
                                                                 0 indicates that there is no error. If an error exists then the following decoding is used:.

                                                                 0 = No error
                                                                 1 = Write request timeout
                                                                 2 = No measurement block
                                                                 3 = Measurement timeout
                                                                 4 = undefined
                                                                 5 = Start value is larger max or smaller than min
                                                                 others = undefined */
        uint32_t leq_fsm_status_error2 : 3;  /**< [  5:  3](RO/H) Reserved. */
        uint32_t leq_fsm_max_clamp     : 1;  /**< [  6:  6](RO/H) Reserved. */
        uint32_t leq_fsm_min_clamp     : 1;  /**< [  7:  7](RO/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_leq_refclk_leq_fsm_status0_s cn; */
};
typedef union cavm_gsercx_lnx_leq_refclk_leq_fsm_status0 cavm_gsercx_lnx_leq_refclk_leq_fsm_status0_t;

static inline uint64_t CAVM_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8011120ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011120ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS0(a,b) cavm_gsercx_lnx_leq_refclk_leq_fsm_status0_t
#define bustype_CAVM_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS0(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS0(a,b) "GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS0"
#define device_bar_CAVM_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS0(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_leq_fsm_status3
 *
 * GSERC Ln Leq Refclk Leq Fsm Status3 Register
 */
union cavm_gsercx_lnx_leq_refclk_leq_fsm_status3
{
    uint32_t u;
    struct cavm_gsercx_lnx_leq_refclk_leq_fsm_status3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t leq_fsm_last_value    : 8;  /**< [  7:  0](RO/H) Last Write Value written in Write or Write-and-Measure command; or Read Value of a Read Command. */
#else /* Word 0 - Little Endian */
        uint32_t leq_fsm_last_value    : 8;  /**< [  7:  0](RO/H) Last Write Value written in Write or Write-and-Measure command; or Read Value of a Read Command. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_leq_refclk_leq_fsm_status3_s cn; */
};
typedef union cavm_gsercx_lnx_leq_refclk_leq_fsm_status3 cavm_gsercx_lnx_leq_refclk_leq_fsm_status3_t;

static inline uint64_t CAVM_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS3(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS3(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8011138ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011138ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS3", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS3(a,b) cavm_gsercx_lnx_leq_refclk_leq_fsm_status3_t
#define bustype_CAVM_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS3(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS3(a,b) "GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS3"
#define device_bar_CAVM_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS3(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS3(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS3(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_leq_fsm_status5
 *
 * GSERC Ln Leq Refclk Leq Fsm Status5 Register
 */
union cavm_gsercx_lnx_leq_refclk_leq_fsm_status5
{
    uint32_t u;
    struct cavm_gsercx_lnx_leq_refclk_leq_fsm_status5_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t leq_fsm_cmd_ack       : 1;  /**< [  1:  1](RO/H) FSM command acknowledgement
                                                                 This bit is set to 1 by HW when a command is completed.  It will stay at 1 until
                                                                 leq_fsm_cmd_req is set to 0.

                                                                 All leq_fsm_status* registers are valid only when this bit is asserted. */
        uint32_t reserved_0            : 1;
#else /* Word 0 - Little Endian */
        uint32_t reserved_0            : 1;
        uint32_t leq_fsm_cmd_ack       : 1;  /**< [  1:  1](RO/H) FSM command acknowledgement
                                                                 This bit is set to 1 by HW when a command is completed.  It will stay at 1 until
                                                                 leq_fsm_cmd_req is set to 0.

                                                                 All leq_fsm_status* registers are valid only when this bit is asserted. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_leq_refclk_leq_fsm_status5_s cn; */
};
typedef union cavm_gsercx_lnx_leq_refclk_leq_fsm_status5 cavm_gsercx_lnx_leq_refclk_leq_fsm_status5_t;

static inline uint64_t CAVM_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS5(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS5(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8011158ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011158ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS5", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS5(a,b) cavm_gsercx_lnx_leq_refclk_leq_fsm_status5_t
#define bustype_CAVM_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS5(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS5(a,b) "GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS5"
#define device_bar_CAVM_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS5(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS5(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS5(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_rx_coefficient_update_status
 *
 * GSERC Ln Lt Rx Coefficient Update Status Register
 */
union cavm_gsercx_lnx_lt_rx_coefficient_update_status
{
    uint32_t u;
    struct cavm_gsercx_lnx_lt_rx_coefficient_update_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t preset                : 1;  /**< [  7:  7](RO/H) Received coefficient update preset field. */
        uint32_t initialize            : 1;  /**< [  6:  6](RO/H) Received coefficient update initialize field. */
        uint32_t c_m1                  : 2;  /**< [  5:  4](RO/H) Received coefficient update request field for pre-cursor tap. */
        uint32_t c_0                   : 2;  /**< [  3:  2](RO/H) Received coefficient update request field for cursor tap. */
        uint32_t c_p1                  : 2;  /**< [  1:  0](RO/H) Received coefficient update field for post-cursor tap.
                                                                 2'b00 = hold
                                                                 2'b01 = increment
                                                                 2'b10 = decrement
                                                                 2'b11 = reserved */
#else /* Word 0 - Little Endian */
        uint32_t c_p1                  : 2;  /**< [  1:  0](RO/H) Received coefficient update field for post-cursor tap.
                                                                 2'b00 = hold
                                                                 2'b01 = increment
                                                                 2'b10 = decrement
                                                                 2'b11 = reserved */
        uint32_t c_0                   : 2;  /**< [  3:  2](RO/H) Received coefficient update request field for cursor tap. */
        uint32_t c_m1                  : 2;  /**< [  5:  4](RO/H) Received coefficient update request field for pre-cursor tap. */
        uint32_t initialize            : 1;  /**< [  6:  6](RO/H) Received coefficient update initialize field. */
        uint32_t preset                : 1;  /**< [  7:  7](RO/H) Received coefficient update preset field. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_lt_rx_coefficient_update_status_s cn; */
};
typedef union cavm_gsercx_lnx_lt_rx_coefficient_update_status cavm_gsercx_lnx_lt_rx_coefficient_update_status_t;

static inline uint64_t CAVM_GSERCX_LNX_LT_RX_COEFFICIENT_UPDATE_STATUS(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_LT_RX_COEFFICIENT_UPDATE_STATUS(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013f00ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013f00ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_LT_RX_COEFFICIENT_UPDATE_STATUS", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_LT_RX_COEFFICIENT_UPDATE_STATUS(a,b) cavm_gsercx_lnx_lt_rx_coefficient_update_status_t
#define bustype_CAVM_GSERCX_LNX_LT_RX_COEFFICIENT_UPDATE_STATUS(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_LT_RX_COEFFICIENT_UPDATE_STATUS(a,b) "GSERCX_LNX_LT_RX_COEFFICIENT_UPDATE_STATUS"
#define device_bar_CAVM_GSERCX_LNX_LT_RX_COEFFICIENT_UPDATE_STATUS(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_LT_RX_COEFFICIENT_UPDATE_STATUS(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_LT_RX_COEFFICIENT_UPDATE_STATUS(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_rx_ctrl0
 *
 * GSERC Ln Lt Rx Ctrl0 Register
 */
union cavm_gsercx_lnx_lt_rx_ctrl0
{
    uint32_t u;
    struct cavm_gsercx_lnx_lt_rx_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t training              : 1;  /**< [  1:  1](R/W/H) This is the 802.3 defined training variable.  It should be set according to
                                                                 corresponding LTSM output. */
        uint32_t clear                 : 1;  /**< [  0:  0](R/W/H) Synchronous reset for LT Rx block. */
#else /* Word 0 - Little Endian */
        uint32_t clear                 : 1;  /**< [  0:  0](R/W/H) Synchronous reset for LT Rx block. */
        uint32_t training              : 1;  /**< [  1:  1](R/W/H) This is the 802.3 defined training variable.  It should be set according to
                                                                 corresponding LTSM output. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_lt_rx_ctrl0_s cn; */
};
typedef union cavm_gsercx_lnx_lt_rx_ctrl0 cavm_gsercx_lnx_lt_rx_ctrl0_t;

static inline uint64_t CAVM_GSERCX_LNX_LT_RX_CTRL0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_LT_RX_CTRL0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013e00ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013e00ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_LT_RX_CTRL0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_LT_RX_CTRL0(a,b) cavm_gsercx_lnx_lt_rx_ctrl0_t
#define bustype_CAVM_GSERCX_LNX_LT_RX_CTRL0(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_LT_RX_CTRL0(a,b) "GSERCX_LNX_LT_RX_CTRL0"
#define device_bar_CAVM_GSERCX_LNX_LT_RX_CTRL0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_LT_RX_CTRL0(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_LT_RX_CTRL0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_rx_ctrl_channel_status0
 *
 * GSERC Ln Lt Rx Ctrl Channel Status0 Register
 */
union cavm_gsercx_lnx_lt_rx_ctrl_channel_status0
{
    uint32_t u;
    struct cavm_gsercx_lnx_lt_rx_ctrl_channel_status0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t coefficient_update_7_0 : 8; /**< [  7:  0](RO/H) Received coefficient update field of last LT frame. Invalid when LT is not running. */
#else /* Word 0 - Little Endian */
        uint32_t coefficient_update_7_0 : 8; /**< [  7:  0](RO/H) Received coefficient update field of last LT frame. Invalid when LT is not running. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_lt_rx_ctrl_channel_status0_s cn; */
};
typedef union cavm_gsercx_lnx_lt_rx_ctrl_channel_status0 cavm_gsercx_lnx_lt_rx_ctrl_channel_status0_t;

static inline uint64_t CAVM_GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013f80ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013f80ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS0(a,b) cavm_gsercx_lnx_lt_rx_ctrl_channel_status0_t
#define bustype_CAVM_GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS0(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS0(a,b) "GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS0"
#define device_bar_CAVM_GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS0(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_rx_ctrl_channel_status1
 *
 * GSERC Ln Lt Rx Ctrl Channel Status1 Register
 */
union cavm_gsercx_lnx_lt_rx_ctrl_channel_status1
{
    uint32_t u;
    struct cavm_gsercx_lnx_lt_rx_ctrl_channel_status1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t coefficient_update_15_8 : 8;/**< [  7:  0](RO/H) Received coefficient update field of last LT frame. Invalid when LT is not running. */
#else /* Word 0 - Little Endian */
        uint32_t coefficient_update_15_8 : 8;/**< [  7:  0](RO/H) Received coefficient update field of last LT frame. Invalid when LT is not running. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_lt_rx_ctrl_channel_status1_s cn; */
};
typedef union cavm_gsercx_lnx_lt_rx_ctrl_channel_status1 cavm_gsercx_lnx_lt_rx_ctrl_channel_status1_t;

static inline uint64_t CAVM_GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013f88ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013f88ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS1(a,b) cavm_gsercx_lnx_lt_rx_ctrl_channel_status1_t
#define bustype_CAVM_GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS1(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS1(a,b) "GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS1"
#define device_bar_CAVM_GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS1(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_rx_ctrl_channel_status2
 *
 * GSERC Ln Lt Rx Ctrl Channel Status2 Register
 */
union cavm_gsercx_lnx_lt_rx_ctrl_channel_status2
{
    uint32_t u;
    struct cavm_gsercx_lnx_lt_rx_ctrl_channel_status2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t status_report_7_0     : 8;  /**< [  7:  0](RO/H) Received status report field. Invalid when LT is not running. */
#else /* Word 0 - Little Endian */
        uint32_t status_report_7_0     : 8;  /**< [  7:  0](RO/H) Received status report field. Invalid when LT is not running. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_lt_rx_ctrl_channel_status2_s cn; */
};
typedef union cavm_gsercx_lnx_lt_rx_ctrl_channel_status2 cavm_gsercx_lnx_lt_rx_ctrl_channel_status2_t;

static inline uint64_t CAVM_GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS2(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS2(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013f90ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013f90ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS2(a,b) cavm_gsercx_lnx_lt_rx_ctrl_channel_status2_t
#define bustype_CAVM_GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS2(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS2(a,b) "GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS2"
#define device_bar_CAVM_GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS2(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS2(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS2(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_rx_ctrl_channel_status3
 *
 * GSERC Ln Lt Rx Ctrl Channel Status3 Register
 */
union cavm_gsercx_lnx_lt_rx_ctrl_channel_status3
{
    uint32_t u;
    struct cavm_gsercx_lnx_lt_rx_ctrl_channel_status3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t status_report_15_8    : 8;  /**< [  7:  0](RO/H) Received status report field. Invalid when LT is not running. */
#else /* Word 0 - Little Endian */
        uint32_t status_report_15_8    : 8;  /**< [  7:  0](RO/H) Received status report field. Invalid when LT is not running. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_lt_rx_ctrl_channel_status3_s cn; */
};
typedef union cavm_gsercx_lnx_lt_rx_ctrl_channel_status3 cavm_gsercx_lnx_lt_rx_ctrl_channel_status3_t;

static inline uint64_t CAVM_GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS3(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS3(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013f98ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013f98ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS3", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS3(a,b) cavm_gsercx_lnx_lt_rx_ctrl_channel_status3_t
#define bustype_CAVM_GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS3(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS3(a,b) "GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS3"
#define device_bar_CAVM_GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS3(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS3(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS3(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_rx_fc_status0
 *
 * GSERC Ln Lt Rx Fc Status0 Register
 */
union cavm_gsercx_lnx_lt_rx_fc_status0
{
    uint32_t u;
    struct cavm_gsercx_lnx_lt_rx_fc_status0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t tf                    : 1;  /**< [  3:  3](R/W/H) Received Fibre Channel specific LT frame fields. Contents are valid only after LT has completed. */
        uint32_t feccap                : 1;  /**< [  2:  2](R/W/H) Received Fibre Channel specific LT frame fields. Contents are valid only after LT has completed. */
        uint32_t sn                    : 1;  /**< [  1:  1](R/W/H) Received Fibre Channel specific LT frame fields. Contents are valid only after LT has completed. */
        uint32_t fecreq                : 1;  /**< [  0:  0](R/W/H) Received Fibre Channel specific LT frame fields. Contents are valid only after LT has completed. */
#else /* Word 0 - Little Endian */
        uint32_t fecreq                : 1;  /**< [  0:  0](R/W/H) Received Fibre Channel specific LT frame fields. Contents are valid only after LT has completed. */
        uint32_t sn                    : 1;  /**< [  1:  1](R/W/H) Received Fibre Channel specific LT frame fields. Contents are valid only after LT has completed. */
        uint32_t feccap                : 1;  /**< [  2:  2](R/W/H) Received Fibre Channel specific LT frame fields. Contents are valid only after LT has completed. */
        uint32_t tf                    : 1;  /**< [  3:  3](R/W/H) Received Fibre Channel specific LT frame fields. Contents are valid only after LT has completed. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_lt_rx_fc_status0_s cn; */
};
typedef union cavm_gsercx_lnx_lt_rx_fc_status0 cavm_gsercx_lnx_lt_rx_fc_status0_t;

static inline uint64_t CAVM_GSERCX_LNX_LT_RX_FC_STATUS0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_LT_RX_FC_STATUS0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013fa8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013fa8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_LT_RX_FC_STATUS0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_LT_RX_FC_STATUS0(a,b) cavm_gsercx_lnx_lt_rx_fc_status0_t
#define bustype_CAVM_GSERCX_LNX_LT_RX_FC_STATUS0(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_LT_RX_FC_STATUS0(a,b) "GSERCX_LNX_LT_RX_FC_STATUS0"
#define device_bar_CAVM_GSERCX_LNX_LT_RX_FC_STATUS0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_LT_RX_FC_STATUS0(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_LT_RX_FC_STATUS0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_rx_frame_ctrl
 *
 * GSERC Ln Lt Rx Frame Ctrl Register
 */
union cavm_gsercx_lnx_lt_rx_frame_ctrl
{
    uint32_t u;
    struct cavm_gsercx_lnx_lt_rx_frame_ctrl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t clear_count           : 1;  /**< [  0:  0](R/W/H) Clears both the absolute and erroneous frame counters. */
#else /* Word 0 - Little Endian */
        uint32_t clear_count           : 1;  /**< [  0:  0](R/W/H) Clears both the absolute and erroneous frame counters. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_lt_rx_frame_ctrl_s cn; */
};
typedef union cavm_gsercx_lnx_lt_rx_frame_ctrl cavm_gsercx_lnx_lt_rx_frame_ctrl_t;

static inline uint64_t CAVM_GSERCX_LNX_LT_RX_FRAME_CTRL(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_LT_RX_FRAME_CTRL(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013e80ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013e80ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_LT_RX_FRAME_CTRL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_LT_RX_FRAME_CTRL(a,b) cavm_gsercx_lnx_lt_rx_frame_ctrl_t
#define bustype_CAVM_GSERCX_LNX_LT_RX_FRAME_CTRL(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_LT_RX_FRAME_CTRL(a,b) "GSERCX_LNX_LT_RX_FRAME_CTRL"
#define device_bar_CAVM_GSERCX_LNX_LT_RX_FRAME_CTRL(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_LT_RX_FRAME_CTRL(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_LT_RX_FRAME_CTRL(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_rx_frame_status0
 *
 * GSERC Ln Lt Rx Frame Status0 Register
 */
union cavm_gsercx_lnx_lt_rx_frame_status0
{
    uint32_t u;
    struct cavm_gsercx_lnx_lt_rx_frame_status0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t frame_lock            : 1;  /**< [  0:  0](RO/H) Indicates that the receiver has locked to incoming LT frames. */
#else /* Word 0 - Little Endian */
        uint32_t frame_lock            : 1;  /**< [  0:  0](RO/H) Indicates that the receiver has locked to incoming LT frames. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_lt_rx_frame_status0_s cn; */
};
typedef union cavm_gsercx_lnx_lt_rx_frame_status0 cavm_gsercx_lnx_lt_rx_frame_status0_t;

static inline uint64_t CAVM_GSERCX_LNX_LT_RX_FRAME_STATUS0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_LT_RX_FRAME_STATUS0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013e98ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013e98ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_LT_RX_FRAME_STATUS0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_LT_RX_FRAME_STATUS0(a,b) cavm_gsercx_lnx_lt_rx_frame_status0_t
#define bustype_CAVM_GSERCX_LNX_LT_RX_FRAME_STATUS0(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_LT_RX_FRAME_STATUS0(a,b) "GSERCX_LNX_LT_RX_FRAME_STATUS0"
#define device_bar_CAVM_GSERCX_LNX_LT_RX_FRAME_STATUS0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_LT_RX_FRAME_STATUS0(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_LT_RX_FRAME_STATUS0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_rx_frame_status1
 *
 * GSERC Ln Lt Rx Frame Status1 Register
 */
union cavm_gsercx_lnx_lt_rx_frame_status1
{
    uint32_t u;
    struct cavm_gsercx_lnx_lt_rx_frame_status1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t total_frame_count_7_0 : 8;  /**< [  7:  0](RO/H) Total number of received frames since frame lock. */
#else /* Word 0 - Little Endian */
        uint32_t total_frame_count_7_0 : 8;  /**< [  7:  0](RO/H) Total number of received frames since frame lock. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_lt_rx_frame_status1_s cn; */
};
typedef union cavm_gsercx_lnx_lt_rx_frame_status1 cavm_gsercx_lnx_lt_rx_frame_status1_t;

static inline uint64_t CAVM_GSERCX_LNX_LT_RX_FRAME_STATUS1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_LT_RX_FRAME_STATUS1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013ea0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013ea0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_LT_RX_FRAME_STATUS1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_LT_RX_FRAME_STATUS1(a,b) cavm_gsercx_lnx_lt_rx_frame_status1_t
#define bustype_CAVM_GSERCX_LNX_LT_RX_FRAME_STATUS1(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_LT_RX_FRAME_STATUS1(a,b) "GSERCX_LNX_LT_RX_FRAME_STATUS1"
#define device_bar_CAVM_GSERCX_LNX_LT_RX_FRAME_STATUS1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_LT_RX_FRAME_STATUS1(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_LT_RX_FRAME_STATUS1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_rx_frame_status2
 *
 * GSERC Ln Lt Rx Frame Status2 Register
 */
union cavm_gsercx_lnx_lt_rx_frame_status2
{
    uint32_t u;
    struct cavm_gsercx_lnx_lt_rx_frame_status2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t total_frame_count_15_8 : 8; /**< [  7:  0](RO/H) Same as above. */
#else /* Word 0 - Little Endian */
        uint32_t total_frame_count_15_8 : 8; /**< [  7:  0](RO/H) Same as above. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_lt_rx_frame_status2_s cn; */
};
typedef union cavm_gsercx_lnx_lt_rx_frame_status2 cavm_gsercx_lnx_lt_rx_frame_status2_t;

static inline uint64_t CAVM_GSERCX_LNX_LT_RX_FRAME_STATUS2(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_LT_RX_FRAME_STATUS2(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013ea8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013ea8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_LT_RX_FRAME_STATUS2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_LT_RX_FRAME_STATUS2(a,b) cavm_gsercx_lnx_lt_rx_frame_status2_t
#define bustype_CAVM_GSERCX_LNX_LT_RX_FRAME_STATUS2(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_LT_RX_FRAME_STATUS2(a,b) "GSERCX_LNX_LT_RX_FRAME_STATUS2"
#define device_bar_CAVM_GSERCX_LNX_LT_RX_FRAME_STATUS2(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_LT_RX_FRAME_STATUS2(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_LT_RX_FRAME_STATUS2(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_rx_frame_status3
 *
 * GSERC Ln Lt Rx Frame Status3 Register
 */
union cavm_gsercx_lnx_lt_rx_frame_status3
{
    uint32_t u;
    struct cavm_gsercx_lnx_lt_rx_frame_status3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t bad_frame_count_7_0   : 8;  /**< [  7:  0](RO/H) Total number of received frames  with a PRBS, DME, or framing error since frame lock. */
#else /* Word 0 - Little Endian */
        uint32_t bad_frame_count_7_0   : 8;  /**< [  7:  0](RO/H) Total number of received frames  with a PRBS, DME, or framing error since frame lock. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_lt_rx_frame_status3_s cn; */
};
typedef union cavm_gsercx_lnx_lt_rx_frame_status3 cavm_gsercx_lnx_lt_rx_frame_status3_t;

static inline uint64_t CAVM_GSERCX_LNX_LT_RX_FRAME_STATUS3(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_LT_RX_FRAME_STATUS3(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013eb0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013eb0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_LT_RX_FRAME_STATUS3", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_LT_RX_FRAME_STATUS3(a,b) cavm_gsercx_lnx_lt_rx_frame_status3_t
#define bustype_CAVM_GSERCX_LNX_LT_RX_FRAME_STATUS3(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_LT_RX_FRAME_STATUS3(a,b) "GSERCX_LNX_LT_RX_FRAME_STATUS3"
#define device_bar_CAVM_GSERCX_LNX_LT_RX_FRAME_STATUS3(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_LT_RX_FRAME_STATUS3(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_LT_RX_FRAME_STATUS3(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_rx_frame_status4
 *
 * GSERC Ln Lt Rx Frame Status4 Register
 */
union cavm_gsercx_lnx_lt_rx_frame_status4
{
    uint32_t u;
    struct cavm_gsercx_lnx_lt_rx_frame_status4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t bad_frame_count_15_8  : 8;  /**< [  7:  0](RO/H) Same as above. */
#else /* Word 0 - Little Endian */
        uint32_t bad_frame_count_15_8  : 8;  /**< [  7:  0](RO/H) Same as above. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_lt_rx_frame_status4_s cn; */
};
typedef union cavm_gsercx_lnx_lt_rx_frame_status4 cavm_gsercx_lnx_lt_rx_frame_status4_t;

static inline uint64_t CAVM_GSERCX_LNX_LT_RX_FRAME_STATUS4(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_LT_RX_FRAME_STATUS4(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013eb8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013eb8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_LT_RX_FRAME_STATUS4", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_LT_RX_FRAME_STATUS4(a,b) cavm_gsercx_lnx_lt_rx_frame_status4_t
#define bustype_CAVM_GSERCX_LNX_LT_RX_FRAME_STATUS4(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_LT_RX_FRAME_STATUS4(a,b) "GSERCX_LNX_LT_RX_FRAME_STATUS4"
#define device_bar_CAVM_GSERCX_LNX_LT_RX_FRAME_STATUS4(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_LT_RX_FRAME_STATUS4(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_LT_RX_FRAME_STATUS4(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_rx_prbs_ctrl0
 *
 * GSERC Ln Lt Rx Prbs Ctrl0 Register
 */
union cavm_gsercx_lnx_lt_rx_prbs_ctrl0
{
    uint32_t u;
    struct cavm_gsercx_lnx_lt_rx_prbs_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t polynomial            : 3;  /**< [  2:  0](R/W/H) Selects between CL72 and CL93 PRBS patterns.
                                                                 0 = CL72 1 + x^9 + x^11
                                                                 1 = CL93 1 + x^5 + x^6 + x^10 + x^11
                                                                 2 = CL93 1 + x^5 + x^6 + x^9 + x^11
                                                                 3 = CL93 1 + x^4 + x^6 + x^8 + x^11
                                                                 4 = CL93 1 + x^4 + x^6 + x^7 + x^11 */
#else /* Word 0 - Little Endian */
        uint32_t polynomial            : 3;  /**< [  2:  0](R/W/H) Selects between CL72 and CL93 PRBS patterns.
                                                                 0 = CL72 1 + x^9 + x^11
                                                                 1 = CL93 1 + x^5 + x^6 + x^10 + x^11
                                                                 2 = CL93 1 + x^5 + x^6 + x^9 + x^11
                                                                 3 = CL93 1 + x^4 + x^6 + x^8 + x^11
                                                                 4 = CL93 1 + x^4 + x^6 + x^7 + x^11 */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_lt_rx_prbs_ctrl0_s cn; */
};
typedef union cavm_gsercx_lnx_lt_rx_prbs_ctrl0 cavm_gsercx_lnx_lt_rx_prbs_ctrl0_t;

static inline uint64_t CAVM_GSERCX_LNX_LT_RX_PRBS_CTRL0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_LT_RX_PRBS_CTRL0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013e10ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013e10ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_LT_RX_PRBS_CTRL0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_LT_RX_PRBS_CTRL0(a,b) cavm_gsercx_lnx_lt_rx_prbs_ctrl0_t
#define bustype_CAVM_GSERCX_LNX_LT_RX_PRBS_CTRL0(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_LT_RX_PRBS_CTRL0(a,b) "GSERCX_LNX_LT_RX_PRBS_CTRL0"
#define device_bar_CAVM_GSERCX_LNX_LT_RX_PRBS_CTRL0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_LT_RX_PRBS_CTRL0(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_LT_RX_PRBS_CTRL0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_rx_prbs_ctrl1
 *
 * GSERC Ln Lt Rx Prbs Ctrl1 Register
 */
union cavm_gsercx_lnx_lt_rx_prbs_ctrl1
{
    uint32_t u;
    struct cavm_gsercx_lnx_lt_rx_prbs_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t lock_threshold        : 8;  /**< [  7:  0](R/W/H) Maximum number  of PRBS bit errors allowed in single LT frame for PRBS lock to be achieved. */
#else /* Word 0 - Little Endian */
        uint32_t lock_threshold        : 8;  /**< [  7:  0](R/W/H) Maximum number  of PRBS bit errors allowed in single LT frame for PRBS lock to be achieved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_lt_rx_prbs_ctrl1_s cn; */
};
typedef union cavm_gsercx_lnx_lt_rx_prbs_ctrl1 cavm_gsercx_lnx_lt_rx_prbs_ctrl1_t;

static inline uint64_t CAVM_GSERCX_LNX_LT_RX_PRBS_CTRL1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_LT_RX_PRBS_CTRL1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013e18ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013e18ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_LT_RX_PRBS_CTRL1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_LT_RX_PRBS_CTRL1(a,b) cavm_gsercx_lnx_lt_rx_prbs_ctrl1_t
#define bustype_CAVM_GSERCX_LNX_LT_RX_PRBS_CTRL1(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_LT_RX_PRBS_CTRL1(a,b) "GSERCX_LNX_LT_RX_PRBS_CTRL1"
#define device_bar_CAVM_GSERCX_LNX_LT_RX_PRBS_CTRL1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_LT_RX_PRBS_CTRL1(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_LT_RX_PRBS_CTRL1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_rx_prbs_status0
 *
 * GSERC Ln Lt Rx Prbs Status0 Register
 */
union cavm_gsercx_lnx_lt_rx_prbs_status0
{
    uint32_t u;
    struct cavm_gsercx_lnx_lt_rx_prbs_status0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t lock                  : 1;  /**< [  1:  1](RO/H) Indicates that a valid PRBS pattern has been detected in receiver LT frame. */
        uint32_t update                : 1;  /**< [  0:  0](RO/H) Assertion indicates that PRBS status information has been updated. */
#else /* Word 0 - Little Endian */
        uint32_t update                : 1;  /**< [  0:  0](RO/H) Assertion indicates that PRBS status information has been updated. */
        uint32_t lock                  : 1;  /**< [  1:  1](RO/H) Indicates that a valid PRBS pattern has been detected in receiver LT frame. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_lt_rx_prbs_status0_s cn; */
};
typedef union cavm_gsercx_lnx_lt_rx_prbs_status0 cavm_gsercx_lnx_lt_rx_prbs_status0_t;

static inline uint64_t CAVM_GSERCX_LNX_LT_RX_PRBS_STATUS0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_LT_RX_PRBS_STATUS0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013e28ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013e28ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_LT_RX_PRBS_STATUS0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_LT_RX_PRBS_STATUS0(a,b) cavm_gsercx_lnx_lt_rx_prbs_status0_t
#define bustype_CAVM_GSERCX_LNX_LT_RX_PRBS_STATUS0(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_LT_RX_PRBS_STATUS0(a,b) "GSERCX_LNX_LT_RX_PRBS_STATUS0"
#define device_bar_CAVM_GSERCX_LNX_LT_RX_PRBS_STATUS0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_LT_RX_PRBS_STATUS0(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_LT_RX_PRBS_STATUS0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_rx_prbs_status1
 *
 * GSERC Ln Lt Rx Prbs Status1 Register
 */
union cavm_gsercx_lnx_lt_rx_prbs_status1
{
    uint32_t u;
    struct cavm_gsercx_lnx_lt_rx_prbs_status1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t error_count_7_0       : 8;  /**< [  7:  0](RO/H) Number of bit errors in PRBS pattern since last lock assertion event. */
#else /* Word 0 - Little Endian */
        uint32_t error_count_7_0       : 8;  /**< [  7:  0](RO/H) Number of bit errors in PRBS pattern since last lock assertion event. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_lt_rx_prbs_status1_s cn; */
};
typedef union cavm_gsercx_lnx_lt_rx_prbs_status1 cavm_gsercx_lnx_lt_rx_prbs_status1_t;

static inline uint64_t CAVM_GSERCX_LNX_LT_RX_PRBS_STATUS1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_LT_RX_PRBS_STATUS1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013e30ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013e30ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_LT_RX_PRBS_STATUS1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_LT_RX_PRBS_STATUS1(a,b) cavm_gsercx_lnx_lt_rx_prbs_status1_t
#define bustype_CAVM_GSERCX_LNX_LT_RX_PRBS_STATUS1(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_LT_RX_PRBS_STATUS1(a,b) "GSERCX_LNX_LT_RX_PRBS_STATUS1"
#define device_bar_CAVM_GSERCX_LNX_LT_RX_PRBS_STATUS1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_LT_RX_PRBS_STATUS1(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_LT_RX_PRBS_STATUS1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_rx_prbs_status2
 *
 * GSERC Ln Lt Rx Prbs Status2 Register
 */
union cavm_gsercx_lnx_lt_rx_prbs_status2
{
    uint32_t u;
    struct cavm_gsercx_lnx_lt_rx_prbs_status2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t error_count_11_8      : 4;  /**< [  3:  0](RO/H) Same as above. */
#else /* Word 0 - Little Endian */
        uint32_t error_count_11_8      : 4;  /**< [  3:  0](RO/H) Same as above. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_lt_rx_prbs_status2_s cn; */
};
typedef union cavm_gsercx_lnx_lt_rx_prbs_status2 cavm_gsercx_lnx_lt_rx_prbs_status2_t;

static inline uint64_t CAVM_GSERCX_LNX_LT_RX_PRBS_STATUS2(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_LT_RX_PRBS_STATUS2(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013e38ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013e38ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_LT_RX_PRBS_STATUS2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_LT_RX_PRBS_STATUS2(a,b) cavm_gsercx_lnx_lt_rx_prbs_status2_t
#define bustype_CAVM_GSERCX_LNX_LT_RX_PRBS_STATUS2(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_LT_RX_PRBS_STATUS2(a,b) "GSERCX_LNX_LT_RX_PRBS_STATUS2"
#define device_bar_CAVM_GSERCX_LNX_LT_RX_PRBS_STATUS2(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_LT_RX_PRBS_STATUS2(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_LT_RX_PRBS_STATUS2(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_rx_report_status
 *
 * GSERC Ln Lt Rx Report Status Register
 */
union cavm_gsercx_lnx_lt_rx_report_status
{
    uint32_t u;
    struct cavm_gsercx_lnx_lt_rx_report_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t dme_error             : 1;  /**< [  7:  7](RO/H) Indicates differential manchester decoding error.  Not sticky. */
        uint32_t local_rx_ready        : 1;  /**< [  6:  6](RO/H) Received status report field to indicate local receiver is ready. */
        uint32_t c_m1                  : 2;  /**< [  5:  4](RO/H) Received status report field for pre-cursor tap. */
        uint32_t c_0                   : 2;  /**< [  3:  2](RO/H) Received status report field for cursor tap. */
        uint32_t c_p1                  : 2;  /**< [  1:  0](RO/H) Received status report field for post-cursor tap.
                                                                 2'b00 = not updated
                                                                 2'b01 = minimum
                                                                 2'b10 = updated
                                                                 2'b11 = maximum */
#else /* Word 0 - Little Endian */
        uint32_t c_p1                  : 2;  /**< [  1:  0](RO/H) Received status report field for post-cursor tap.
                                                                 2'b00 = not updated
                                                                 2'b01 = minimum
                                                                 2'b10 = updated
                                                                 2'b11 = maximum */
        uint32_t c_0                   : 2;  /**< [  3:  2](RO/H) Received status report field for cursor tap. */
        uint32_t c_m1                  : 2;  /**< [  5:  4](RO/H) Received status report field for pre-cursor tap. */
        uint32_t local_rx_ready        : 1;  /**< [  6:  6](RO/H) Received status report field to indicate local receiver is ready. */
        uint32_t dme_error             : 1;  /**< [  7:  7](RO/H) Indicates differential manchester decoding error.  Not sticky. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_lt_rx_report_status_s cn; */
};
typedef union cavm_gsercx_lnx_lt_rx_report_status cavm_gsercx_lnx_lt_rx_report_status_t;

static inline uint64_t CAVM_GSERCX_LNX_LT_RX_REPORT_STATUS(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_LT_RX_REPORT_STATUS(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013f10ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013f10ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_LT_RX_REPORT_STATUS", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_LT_RX_REPORT_STATUS(a,b) cavm_gsercx_lnx_lt_rx_report_status_t
#define bustype_CAVM_GSERCX_LNX_LT_RX_REPORT_STATUS(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_LT_RX_REPORT_STATUS(a,b) "GSERCX_LNX_LT_RX_REPORT_STATUS"
#define device_bar_CAVM_GSERCX_LNX_LT_RX_REPORT_STATUS(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_LT_RX_REPORT_STATUS(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_LT_RX_REPORT_STATUS(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_tx_coefficient_update_ctrl0
 *
 * GSERC Ln Lt Tx Coefficient Update Ctrl0 Register
 */
union cavm_gsercx_lnx_lt_tx_coefficient_update_ctrl0
{
    uint32_t u;
    struct cavm_gsercx_lnx_lt_tx_coefficient_update_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t preset                : 1;  /**< [  7:  7](R/W/H) Coefficient update preset field. */
        uint32_t initialize            : 1;  /**< [  6:  6](R/W/H) Coefficient update initialize field. */
        uint32_t c_m1                  : 2;  /**< [  5:  4](R/W/H) Coefficient update request field for pre-cursor tap. */
        uint32_t c_0                   : 2;  /**< [  3:  2](R/W/H) Coefficient update request field for cursor tap. */
        uint32_t c_p1                  : 2;  /**< [  1:  0](R/W/H) Coefficient update request field for post-cursor tap.
                                                                 2'b00 = hold
                                                                 2'b01 = increment
                                                                 2'b10 = decrement
                                                                 2'b11 = reserved */
#else /* Word 0 - Little Endian */
        uint32_t c_p1                  : 2;  /**< [  1:  0](R/W/H) Coefficient update request field for post-cursor tap.
                                                                 2'b00 = hold
                                                                 2'b01 = increment
                                                                 2'b10 = decrement
                                                                 2'b11 = reserved */
        uint32_t c_0                   : 2;  /**< [  3:  2](R/W/H) Coefficient update request field for cursor tap. */
        uint32_t c_m1                  : 2;  /**< [  5:  4](R/W/H) Coefficient update request field for pre-cursor tap. */
        uint32_t initialize            : 1;  /**< [  6:  6](R/W/H) Coefficient update initialize field. */
        uint32_t preset                : 1;  /**< [  7:  7](R/W/H) Coefficient update preset field. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_lt_tx_coefficient_update_ctrl0_s cn; */
};
typedef union cavm_gsercx_lnx_lt_tx_coefficient_update_ctrl0 cavm_gsercx_lnx_lt_tx_coefficient_update_ctrl0_t;

static inline uint64_t CAVM_GSERCX_LNX_LT_TX_COEFFICIENT_UPDATE_CTRL0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_LT_TX_COEFFICIENT_UPDATE_CTRL0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013d00ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013d00ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_LT_TX_COEFFICIENT_UPDATE_CTRL0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_LT_TX_COEFFICIENT_UPDATE_CTRL0(a,b) cavm_gsercx_lnx_lt_tx_coefficient_update_ctrl0_t
#define bustype_CAVM_GSERCX_LNX_LT_TX_COEFFICIENT_UPDATE_CTRL0(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_LT_TX_COEFFICIENT_UPDATE_CTRL0(a,b) "GSERCX_LNX_LT_TX_COEFFICIENT_UPDATE_CTRL0"
#define device_bar_CAVM_GSERCX_LNX_LT_TX_COEFFICIENT_UPDATE_CTRL0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_LT_TX_COEFFICIENT_UPDATE_CTRL0(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_LT_TX_COEFFICIENT_UPDATE_CTRL0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_tx_coefficient_update_ctrl1
 *
 * GSERC Ln Lt Tx Coefficient Update Ctrl1 Register
 */
union cavm_gsercx_lnx_lt_tx_coefficient_update_ctrl1
{
    uint32_t u;
    struct cavm_gsercx_lnx_lt_tx_coefficient_update_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t field_11_6            : 6;  /**< [  7:  2](R/W/H) Controls bits 11:6 of the coefficient update control channel field. */
        uint32_t field_15_14           : 2;  /**< [  1:  0](R/W/H) Controls bits 15:14 of the coefficient update control channel field. */
#else /* Word 0 - Little Endian */
        uint32_t field_15_14           : 2;  /**< [  1:  0](R/W/H) Controls bits 15:14 of the coefficient update control channel field. */
        uint32_t field_11_6            : 6;  /**< [  7:  2](R/W/H) Controls bits 11:6 of the coefficient update control channel field. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_lt_tx_coefficient_update_ctrl1_s cn; */
};
typedef union cavm_gsercx_lnx_lt_tx_coefficient_update_ctrl1 cavm_gsercx_lnx_lt_tx_coefficient_update_ctrl1_t;

static inline uint64_t CAVM_GSERCX_LNX_LT_TX_COEFFICIENT_UPDATE_CTRL1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_LT_TX_COEFFICIENT_UPDATE_CTRL1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013d08ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013d08ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_LT_TX_COEFFICIENT_UPDATE_CTRL1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_LT_TX_COEFFICIENT_UPDATE_CTRL1(a,b) cavm_gsercx_lnx_lt_tx_coefficient_update_ctrl1_t
#define bustype_CAVM_GSERCX_LNX_LT_TX_COEFFICIENT_UPDATE_CTRL1(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_LT_TX_COEFFICIENT_UPDATE_CTRL1(a,b) "GSERCX_LNX_LT_TX_COEFFICIENT_UPDATE_CTRL1"
#define device_bar_CAVM_GSERCX_LNX_LT_TX_COEFFICIENT_UPDATE_CTRL1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_LT_TX_COEFFICIENT_UPDATE_CTRL1(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_LT_TX_COEFFICIENT_UPDATE_CTRL1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_tx_fsm_ctrl0
 *
 * GSERC Ln Lt Tx Fsm Ctrl0 Register
 */
union cavm_gsercx_lnx_lt_tx_fsm_ctrl0
{
    uint32_t u;
    struct cavm_gsercx_lnx_lt_tx_fsm_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t clear                 : 1;  /**< [  3:  3](R/W/H) Synchronous reset for LT Tx block. */
        uint32_t signal_detect         : 1;  /**< [  2:  2](R/W/H) Output corresponding to link training signal detect variable.  Should be set
                                                                 when link training has completed successfully. */
        uint32_t mr_training_enable    : 1;  /**< [  1:  1](R/W/H) Indicates to LTSM that link training procedure should be run; otherwise
                                                                 procedures skip directly to signal_det assertion.  This is an 802.3 defined
                                                                 variable. */
        uint32_t mr_restart_training   : 1;  /**< [  0:  0](R/W/H) Starts link training procedure when asserted.  This is an 802.3 defined variable. */
#else /* Word 0 - Little Endian */
        uint32_t mr_restart_training   : 1;  /**< [  0:  0](R/W/H) Starts link training procedure when asserted.  This is an 802.3 defined variable. */
        uint32_t mr_training_enable    : 1;  /**< [  1:  1](R/W/H) Indicates to LTSM that link training procedure should be run; otherwise
                                                                 procedures skip directly to signal_det assertion.  This is an 802.3 defined
                                                                 variable. */
        uint32_t signal_detect         : 1;  /**< [  2:  2](R/W/H) Output corresponding to link training signal detect variable.  Should be set
                                                                 when link training has completed successfully. */
        uint32_t clear                 : 1;  /**< [  3:  3](R/W/H) Synchronous reset for LT Tx block. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_lt_tx_fsm_ctrl0_s cn; */
};
typedef union cavm_gsercx_lnx_lt_tx_fsm_ctrl0 cavm_gsercx_lnx_lt_tx_fsm_ctrl0_t;

static inline uint64_t CAVM_GSERCX_LNX_LT_TX_FSM_CTRL0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_LT_TX_FSM_CTRL0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013c00ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013c00ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_LT_TX_FSM_CTRL0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_LT_TX_FSM_CTRL0(a,b) cavm_gsercx_lnx_lt_tx_fsm_ctrl0_t
#define bustype_CAVM_GSERCX_LNX_LT_TX_FSM_CTRL0(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_LT_TX_FSM_CTRL0(a,b) "GSERCX_LNX_LT_TX_FSM_CTRL0"
#define device_bar_CAVM_GSERCX_LNX_LT_TX_FSM_CTRL0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_LT_TX_FSM_CTRL0(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_LT_TX_FSM_CTRL0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_tx_fsm_ctrl1
 *
 * GSERC Ln Lt Tx Fsm Ctrl1 Register
 */
union cavm_gsercx_lnx_lt_tx_fsm_ctrl1
{
    uint32_t u;
    struct cavm_gsercx_lnx_lt_tx_fsm_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t max_wait_time_7_0     : 8;  /**< [  7:  0](R/W/H) Maximum time allowed for LT procedure.  If this is exceeded then the
                                                                 training_fail status will assert.  This is an 802.defined variable.  Value is
                                                                 encoded as:
                                                                 39338 * DESIRED_DELAY * 2 ^logdata_width / data_width

                                                                 Should be set to 500ms for 802.3 compliant timeout. */
#else /* Word 0 - Little Endian */
        uint32_t max_wait_time_7_0     : 8;  /**< [  7:  0](R/W/H) Maximum time allowed for LT procedure.  If this is exceeded then the
                                                                 training_fail status will assert.  This is an 802.defined variable.  Value is
                                                                 encoded as:
                                                                 39338 * DESIRED_DELAY * 2 ^logdata_width / data_width

                                                                 Should be set to 500ms for 802.3 compliant timeout. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_lt_tx_fsm_ctrl1_s cn; */
};
typedef union cavm_gsercx_lnx_lt_tx_fsm_ctrl1 cavm_gsercx_lnx_lt_tx_fsm_ctrl1_t;

static inline uint64_t CAVM_GSERCX_LNX_LT_TX_FSM_CTRL1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_LT_TX_FSM_CTRL1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013c08ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013c08ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_LT_TX_FSM_CTRL1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_LT_TX_FSM_CTRL1(a,b) cavm_gsercx_lnx_lt_tx_fsm_ctrl1_t
#define bustype_CAVM_GSERCX_LNX_LT_TX_FSM_CTRL1(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_LT_TX_FSM_CTRL1(a,b) "GSERCX_LNX_LT_TX_FSM_CTRL1"
#define device_bar_CAVM_GSERCX_LNX_LT_TX_FSM_CTRL1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_LT_TX_FSM_CTRL1(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_LT_TX_FSM_CTRL1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_tx_fsm_ctrl2
 *
 * GSERC Ln Lt Tx Fsm Ctrl2 Register
 */
union cavm_gsercx_lnx_lt_tx_fsm_ctrl2
{
    uint32_t u;
    struct cavm_gsercx_lnx_lt_tx_fsm_ctrl2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t max_wait_time_15_8    : 8;  /**< [  7:  0](R/W/H) Same as above. */
#else /* Word 0 - Little Endian */
        uint32_t max_wait_time_15_8    : 8;  /**< [  7:  0](R/W/H) Same as above. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_lt_tx_fsm_ctrl2_s cn; */
};
typedef union cavm_gsercx_lnx_lt_tx_fsm_ctrl2 cavm_gsercx_lnx_lt_tx_fsm_ctrl2_t;

static inline uint64_t CAVM_GSERCX_LNX_LT_TX_FSM_CTRL2(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_LT_TX_FSM_CTRL2(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013c10ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013c10ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_LT_TX_FSM_CTRL2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_LT_TX_FSM_CTRL2(a,b) cavm_gsercx_lnx_lt_tx_fsm_ctrl2_t
#define bustype_CAVM_GSERCX_LNX_LT_TX_FSM_CTRL2(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_LT_TX_FSM_CTRL2(a,b) "GSERCX_LNX_LT_TX_FSM_CTRL2"
#define device_bar_CAVM_GSERCX_LNX_LT_TX_FSM_CTRL2(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_LT_TX_FSM_CTRL2(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_LT_TX_FSM_CTRL2(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_tx_fsm_ctrl3
 *
 * GSERC Ln Lt Tx Fsm Ctrl3 Register
 */
union cavm_gsercx_lnx_lt_tx_fsm_ctrl3
{
    uint32_t u;
    struct cavm_gsercx_lnx_lt_tx_fsm_ctrl3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t wait_time_7_0         : 8;  /**< [  7:  0](R/W/H) Number of additional frames to send after both receivers have been trained and
                                                                 are ready.  This is an 802.3 defined variable.

                                                                 Should be set between 100 and 300 for 802.3 compliance. */
#else /* Word 0 - Little Endian */
        uint32_t wait_time_7_0         : 8;  /**< [  7:  0](R/W/H) Number of additional frames to send after both receivers have been trained and
                                                                 are ready.  This is an 802.3 defined variable.

                                                                 Should be set between 100 and 300 for 802.3 compliance. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_lt_tx_fsm_ctrl3_s cn; */
};
typedef union cavm_gsercx_lnx_lt_tx_fsm_ctrl3 cavm_gsercx_lnx_lt_tx_fsm_ctrl3_t;

static inline uint64_t CAVM_GSERCX_LNX_LT_TX_FSM_CTRL3(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_LT_TX_FSM_CTRL3(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013c20ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013c20ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_LT_TX_FSM_CTRL3", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_LT_TX_FSM_CTRL3(a,b) cavm_gsercx_lnx_lt_tx_fsm_ctrl3_t
#define bustype_CAVM_GSERCX_LNX_LT_TX_FSM_CTRL3(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_LT_TX_FSM_CTRL3(a,b) "GSERCX_LNX_LT_TX_FSM_CTRL3"
#define device_bar_CAVM_GSERCX_LNX_LT_TX_FSM_CTRL3(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_LT_TX_FSM_CTRL3(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_LT_TX_FSM_CTRL3(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_tx_fsm_ctrl4
 *
 * GSERC Ln Lt Tx Fsm Ctrl4 Register
 */
union cavm_gsercx_lnx_lt_tx_fsm_ctrl4
{
    uint32_t u;
    struct cavm_gsercx_lnx_lt_tx_fsm_ctrl4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t wait_time_9_8         : 2;  /**< [  1:  0](R/W/H) Same as above. */
#else /* Word 0 - Little Endian */
        uint32_t wait_time_9_8         : 2;  /**< [  1:  0](R/W/H) Same as above. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_lt_tx_fsm_ctrl4_s cn; */
};
typedef union cavm_gsercx_lnx_lt_tx_fsm_ctrl4 cavm_gsercx_lnx_lt_tx_fsm_ctrl4_t;

static inline uint64_t CAVM_GSERCX_LNX_LT_TX_FSM_CTRL4(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_LT_TX_FSM_CTRL4(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013c28ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013c28ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_LT_TX_FSM_CTRL4", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_LT_TX_FSM_CTRL4(a,b) cavm_gsercx_lnx_lt_tx_fsm_ctrl4_t
#define bustype_CAVM_GSERCX_LNX_LT_TX_FSM_CTRL4(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_LT_TX_FSM_CTRL4(a,b) "GSERCX_LNX_LT_TX_FSM_CTRL4"
#define device_bar_CAVM_GSERCX_LNX_LT_TX_FSM_CTRL4(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_LT_TX_FSM_CTRL4(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_LT_TX_FSM_CTRL4(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_tx_fsm_ctrl5
 *
 * GSERC Ln Lt Tx Fsm Ctrl5 Register
 */
union cavm_gsercx_lnx_lt_tx_fsm_ctrl5
{
    uint32_t u;
    struct cavm_gsercx_lnx_lt_tx_fsm_ctrl5_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t remote_rx_ready       : 1;  /**< [  2:  2](R/W/H) Input to LTSM indicating that the remote receiver is trained and ready.  This
                                                                 value should be taken from the corresponding LT Rx registers.  This is an 802.3
                                                                 defined variable. */
        uint32_t rx_trained            : 1;  /**< [  1:  1](R/W/H) Input to LTSM indicating that the local receiver has completed training.  This
                                                                 is an 802.3 defined variable. */
        uint32_t frame_lock            : 1;  /**< [  0:  0](R/W/H) Input to LTSM that receiver has acquired frame lock.  This value should be taken
                                                                 from the corresponding LT Rx register.  This  an 802.3 defined variable. */
#else /* Word 0 - Little Endian */
        uint32_t frame_lock            : 1;  /**< [  0:  0](R/W/H) Input to LTSM that receiver has acquired frame lock.  This value should be taken
                                                                 from the corresponding LT Rx register.  This  an 802.3 defined variable. */
        uint32_t rx_trained            : 1;  /**< [  1:  1](R/W/H) Input to LTSM indicating that the local receiver has completed training.  This
                                                                 is an 802.3 defined variable. */
        uint32_t remote_rx_ready       : 1;  /**< [  2:  2](R/W/H) Input to LTSM indicating that the remote receiver is trained and ready.  This
                                                                 value should be taken from the corresponding LT Rx registers.  This is an 802.3
                                                                 defined variable. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_lt_tx_fsm_ctrl5_s cn; */
};
typedef union cavm_gsercx_lnx_lt_tx_fsm_ctrl5 cavm_gsercx_lnx_lt_tx_fsm_ctrl5_t;

static inline uint64_t CAVM_GSERCX_LNX_LT_TX_FSM_CTRL5(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_LT_TX_FSM_CTRL5(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013c30ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013c30ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_LT_TX_FSM_CTRL5", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_LT_TX_FSM_CTRL5(a,b) cavm_gsercx_lnx_lt_tx_fsm_ctrl5_t
#define bustype_CAVM_GSERCX_LNX_LT_TX_FSM_CTRL5(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_LT_TX_FSM_CTRL5(a,b) "GSERCX_LNX_LT_TX_FSM_CTRL5"
#define device_bar_CAVM_GSERCX_LNX_LT_TX_FSM_CTRL5(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_LT_TX_FSM_CTRL5(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_LT_TX_FSM_CTRL5(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_tx_fsm_ctrl6
 *
 * GSERC Ln Lt Tx Fsm Ctrl6 Register
 */
union cavm_gsercx_lnx_lt_tx_fsm_ctrl6
{
    uint32_t u;
    struct cavm_gsercx_lnx_lt_tx_fsm_ctrl6_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t max_wait_time_17_16   : 2;  /**< [  1:  0](R/W/H) Same as above. */
#else /* Word 0 - Little Endian */
        uint32_t max_wait_time_17_16   : 2;  /**< [  1:  0](R/W/H) Same as above. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_lt_tx_fsm_ctrl6_s cn; */
};
typedef union cavm_gsercx_lnx_lt_tx_fsm_ctrl6 cavm_gsercx_lnx_lt_tx_fsm_ctrl6_t;

static inline uint64_t CAVM_GSERCX_LNX_LT_TX_FSM_CTRL6(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_LT_TX_FSM_CTRL6(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013c18ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013c18ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_LT_TX_FSM_CTRL6", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_LT_TX_FSM_CTRL6(a,b) cavm_gsercx_lnx_lt_tx_fsm_ctrl6_t
#define bustype_CAVM_GSERCX_LNX_LT_TX_FSM_CTRL6(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_LT_TX_FSM_CTRL6(a,b) "GSERCX_LNX_LT_TX_FSM_CTRL6"
#define device_bar_CAVM_GSERCX_LNX_LT_TX_FSM_CTRL6(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_LT_TX_FSM_CTRL6(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_LT_TX_FSM_CTRL6(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_tx_fsm_state_status0
 *
 * GSERC Ln Lt Tx Fsm State Status0 Register
 */
union cavm_gsercx_lnx_lt_tx_fsm_state_status0
{
    uint32_t u;
    struct cavm_gsercx_lnx_lt_tx_fsm_state_status0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t prev1                 : 3;  /**< [  6:  4](RO/H) One state previous. */
        uint32_t reserved_3            : 1;
        uint32_t current               : 3;  /**< [  2:  0](RO/H) Current state of LTSM.
                                                                 0x0 = INITIALIZE
                                                                 0x1 = SEND_TRAINING
                                                                 0x2 = TRAIN_REMOTE
                                                                 0x3 = TRAIN_LOCAL
                                                                 0x4 = S7
                                                                 0x5 = TRAINING_FAILURE
                                                                 0x6 = LINK_READY
                                                                 0x7 = SEND_DATA */
#else /* Word 0 - Little Endian */
        uint32_t current               : 3;  /**< [  2:  0](RO/H) Current state of LTSM.
                                                                 0x0 = INITIALIZE
                                                                 0x1 = SEND_TRAINING
                                                                 0x2 = TRAIN_REMOTE
                                                                 0x3 = TRAIN_LOCAL
                                                                 0x4 = S7
                                                                 0x5 = TRAINING_FAILURE
                                                                 0x6 = LINK_READY
                                                                 0x7 = SEND_DATA */
        uint32_t reserved_3            : 1;
        uint32_t prev1                 : 3;  /**< [  6:  4](RO/H) One state previous. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_lt_tx_fsm_state_status0_s cn; */
};
typedef union cavm_gsercx_lnx_lt_tx_fsm_state_status0 cavm_gsercx_lnx_lt_tx_fsm_state_status0_t;

static inline uint64_t CAVM_GSERCX_LNX_LT_TX_FSM_STATE_STATUS0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_LT_TX_FSM_STATE_STATUS0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013d80ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013d80ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_LT_TX_FSM_STATE_STATUS0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_LT_TX_FSM_STATE_STATUS0(a,b) cavm_gsercx_lnx_lt_tx_fsm_state_status0_t
#define bustype_CAVM_GSERCX_LNX_LT_TX_FSM_STATE_STATUS0(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_LT_TX_FSM_STATE_STATUS0(a,b) "GSERCX_LNX_LT_TX_FSM_STATE_STATUS0"
#define device_bar_CAVM_GSERCX_LNX_LT_TX_FSM_STATE_STATUS0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_LT_TX_FSM_STATE_STATUS0(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_LT_TX_FSM_STATE_STATUS0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_tx_fsm_state_status1
 *
 * GSERC Ln Lt Tx Fsm State Status1 Register
 */
union cavm_gsercx_lnx_lt_tx_fsm_state_status1
{
    uint32_t u;
    struct cavm_gsercx_lnx_lt_tx_fsm_state_status1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t prev3                 : 3;  /**< [  6:  4](RO/H) Three states previous. */
        uint32_t reserved_3            : 1;
        uint32_t prev2                 : 3;  /**< [  2:  0](RO/H) Two states previous. */
#else /* Word 0 - Little Endian */
        uint32_t prev2                 : 3;  /**< [  2:  0](RO/H) Two states previous. */
        uint32_t reserved_3            : 1;
        uint32_t prev3                 : 3;  /**< [  6:  4](RO/H) Three states previous. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_lt_tx_fsm_state_status1_s cn; */
};
typedef union cavm_gsercx_lnx_lt_tx_fsm_state_status1 cavm_gsercx_lnx_lt_tx_fsm_state_status1_t;

static inline uint64_t CAVM_GSERCX_LNX_LT_TX_FSM_STATE_STATUS1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_LT_TX_FSM_STATE_STATUS1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013d88ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013d88ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_LT_TX_FSM_STATE_STATUS1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_LT_TX_FSM_STATE_STATUS1(a,b) cavm_gsercx_lnx_lt_tx_fsm_state_status1_t
#define bustype_CAVM_GSERCX_LNX_LT_TX_FSM_STATE_STATUS1(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_LT_TX_FSM_STATE_STATUS1(a,b) "GSERCX_LNX_LT_TX_FSM_STATE_STATUS1"
#define device_bar_CAVM_GSERCX_LNX_LT_TX_FSM_STATE_STATUS1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_LT_TX_FSM_STATE_STATUS1(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_LT_TX_FSM_STATE_STATUS1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_tx_fsm_status
 *
 * GSERC Ln Lt Tx Fsm Status Register
 */
union cavm_gsercx_lnx_lt_tx_fsm_status
{
    uint32_t u;
    struct cavm_gsercx_lnx_lt_tx_fsm_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t fsm_local_rx_ready    : 1;  /**< [  4:  4](RO/H) Output from LSM corresponding to 802.3 defined local_rx_ready variable. After
                                                                 this is asserted the corresponding frame status report field should be set. */
        uint32_t reserved_3            : 1;
        uint32_t signal_detect         : 1;  /**< [  2:  2](RO/H) Output from LTSM indicating that link training is complete and successful.  This
                                                                 is an 802.3 defined variable.  This value is only visible internally, and is not
                                                                 the signal_det value driven to PHY top-level. */
        uint32_t training              : 1;  /**< [  1:  1](RO/H) Output from LTSM indicating that link training is in progress.  This is an 802.3 defined variable. */
        uint32_t training_fail         : 1;  /**< [  0:  0](RO/H) Output from LTSM indicating that link training has failed.  This is an 802.3 defined variable. */
#else /* Word 0 - Little Endian */
        uint32_t training_fail         : 1;  /**< [  0:  0](RO/H) Output from LTSM indicating that link training has failed.  This is an 802.3 defined variable. */
        uint32_t training              : 1;  /**< [  1:  1](RO/H) Output from LTSM indicating that link training is in progress.  This is an 802.3 defined variable. */
        uint32_t signal_detect         : 1;  /**< [  2:  2](RO/H) Output from LTSM indicating that link training is complete and successful.  This
                                                                 is an 802.3 defined variable.  This value is only visible internally, and is not
                                                                 the signal_det value driven to PHY top-level. */
        uint32_t reserved_3            : 1;
        uint32_t fsm_local_rx_ready    : 1;  /**< [  4:  4](RO/H) Output from LSM corresponding to 802.3 defined local_rx_ready variable. After
                                                                 this is asserted the corresponding frame status report field should be set. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_lt_tx_fsm_status_s cn; */
};
typedef union cavm_gsercx_lnx_lt_tx_fsm_status cavm_gsercx_lnx_lt_tx_fsm_status_t;

static inline uint64_t CAVM_GSERCX_LNX_LT_TX_FSM_STATUS(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_LT_TX_FSM_STATUS(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013c80ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013c80ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_LT_TX_FSM_STATUS", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_LT_TX_FSM_STATUS(a,b) cavm_gsercx_lnx_lt_tx_fsm_status_t
#define bustype_CAVM_GSERCX_LNX_LT_TX_FSM_STATUS(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_LT_TX_FSM_STATUS(a,b) "GSERCX_LNX_LT_TX_FSM_STATUS"
#define device_bar_CAVM_GSERCX_LNX_LT_TX_FSM_STATUS(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_LT_TX_FSM_STATUS(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_LT_TX_FSM_STATUS(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_tx_prbs_ctrl0
 *
 * GSERC Ln Lt Tx Prbs Ctrl0 Register
 */
union cavm_gsercx_lnx_lt_tx_prbs_ctrl0
{
    uint32_t u;
    struct cavm_gsercx_lnx_lt_tx_prbs_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t polynomial            : 3;  /**< [  2:  0](R/W/H) Selects between CL72 and CL93 PRBS pattern.
                                                                 0 = CL72 1 + x^9 +x^11
                                                                 1 = CL93 1 + x^5 + x^6 + x^10 + x^11
                                                                 2 = CL93 1 + x^5 + x^6 + x^9 + x^11
                                                                 3 = CL93 1 + x^4 + x^6 + x^8 + x^11
                                                                 4 = CL93 1 + x^4 + x^6 + x^7 + x^11 */
#else /* Word 0 - Little Endian */
        uint32_t polynomial            : 3;  /**< [  2:  0](R/W/H) Selects between CL72 and CL93 PRBS pattern.
                                                                 0 = CL72 1 + x^9 +x^11
                                                                 1 = CL93 1 + x^5 + x^6 + x^10 + x^11
                                                                 2 = CL93 1 + x^5 + x^6 + x^9 + x^11
                                                                 3 = CL93 1 + x^4 + x^6 + x^8 + x^11
                                                                 4 = CL93 1 + x^4 + x^6 + x^7 + x^11 */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_lt_tx_prbs_ctrl0_s cn; */
};
typedef union cavm_gsercx_lnx_lt_tx_prbs_ctrl0 cavm_gsercx_lnx_lt_tx_prbs_ctrl0_t;

static inline uint64_t CAVM_GSERCX_LNX_LT_TX_PRBS_CTRL0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_LT_TX_PRBS_CTRL0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013c98ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013c98ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_LT_TX_PRBS_CTRL0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_LT_TX_PRBS_CTRL0(a,b) cavm_gsercx_lnx_lt_tx_prbs_ctrl0_t
#define bustype_CAVM_GSERCX_LNX_LT_TX_PRBS_CTRL0(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_LT_TX_PRBS_CTRL0(a,b) "GSERCX_LNX_LT_TX_PRBS_CTRL0"
#define device_bar_CAVM_GSERCX_LNX_LT_TX_PRBS_CTRL0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_LT_TX_PRBS_CTRL0(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_LT_TX_PRBS_CTRL0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_tx_prbs_ctrl1
 *
 * GSERC Ln Lt Tx Prbs Ctrl1 Register
 */
union cavm_gsercx_lnx_lt_tx_prbs_ctrl1
{
    uint32_t u;
    struct cavm_gsercx_lnx_lt_tx_prbs_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t seed_7_0              : 8;  /**< [  7:  0](R/W/H) Initial PRBS LFSR seed.

                                                                 This needs to be set according to the requirements in 802.3 CL72 or CL93
                                                                 depending on the type of link training and lane bonding being performed. */
#else /* Word 0 - Little Endian */
        uint32_t seed_7_0              : 8;  /**< [  7:  0](R/W/H) Initial PRBS LFSR seed.

                                                                 This needs to be set according to the requirements in 802.3 CL72 or CL93
                                                                 depending on the type of link training and lane bonding being performed. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_lt_tx_prbs_ctrl1_s cn; */
};
typedef union cavm_gsercx_lnx_lt_tx_prbs_ctrl1 cavm_gsercx_lnx_lt_tx_prbs_ctrl1_t;

static inline uint64_t CAVM_GSERCX_LNX_LT_TX_PRBS_CTRL1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_LT_TX_PRBS_CTRL1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013ca0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013ca0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_LT_TX_PRBS_CTRL1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_LT_TX_PRBS_CTRL1(a,b) cavm_gsercx_lnx_lt_tx_prbs_ctrl1_t
#define bustype_CAVM_GSERCX_LNX_LT_TX_PRBS_CTRL1(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_LT_TX_PRBS_CTRL1(a,b) "GSERCX_LNX_LT_TX_PRBS_CTRL1"
#define device_bar_CAVM_GSERCX_LNX_LT_TX_PRBS_CTRL1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_LT_TX_PRBS_CTRL1(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_LT_TX_PRBS_CTRL1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_tx_prbs_ctrl2
 *
 * GSERC Ln Lt Tx Prbs Ctrl2 Register
 */
union cavm_gsercx_lnx_lt_tx_prbs_ctrl2
{
    uint32_t u;
    struct cavm_gsercx_lnx_lt_tx_prbs_ctrl2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t seed_10_8             : 3;  /**< [  2:  0](R/W/H) Same as above. */
#else /* Word 0 - Little Endian */
        uint32_t seed_10_8             : 3;  /**< [  2:  0](R/W/H) Same as above. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_lt_tx_prbs_ctrl2_s cn; */
};
typedef union cavm_gsercx_lnx_lt_tx_prbs_ctrl2 cavm_gsercx_lnx_lt_tx_prbs_ctrl2_t;

static inline uint64_t CAVM_GSERCX_LNX_LT_TX_PRBS_CTRL2(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_LT_TX_PRBS_CTRL2(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013ca8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013ca8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_LT_TX_PRBS_CTRL2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_LT_TX_PRBS_CTRL2(a,b) cavm_gsercx_lnx_lt_tx_prbs_ctrl2_t
#define bustype_CAVM_GSERCX_LNX_LT_TX_PRBS_CTRL2(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_LT_TX_PRBS_CTRL2(a,b) "GSERCX_LNX_LT_TX_PRBS_CTRL2"
#define device_bar_CAVM_GSERCX_LNX_LT_TX_PRBS_CTRL2(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_LT_TX_PRBS_CTRL2(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_LT_TX_PRBS_CTRL2(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_tx_status_report_ctrl0
 *
 * GSERC Ln Lt Tx Status Report Ctrl0 Register
 */
union cavm_gsercx_lnx_lt_tx_status_report_ctrl0
{
    uint32_t u;
    struct cavm_gsercx_lnx_lt_tx_status_report_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t local_rx_ready        : 1;  /**< [  6:  6](R/W/H) Status report field to indicate local receiver is ready.  Should be set based on
                                                                 LTSM output of corresponding variable. */
        uint32_t c_m1                  : 2;  /**< [  5:  4](R/W/H) Status report field for pre-cursor tap. */
        uint32_t c_0                   : 2;  /**< [  3:  2](R/W/H) Status report field for cursor tap. */
        uint32_t c_p1                  : 2;  /**< [  1:  0](R/W/H) Status report field for post-cursor tap.
                                                                 2'b00 = not updated
                                                                 2'b01 = minimum
                                                                 2'b10 = updated
                                                                 2'b11 = maximum */
#else /* Word 0 - Little Endian */
        uint32_t c_p1                  : 2;  /**< [  1:  0](R/W/H) Status report field for post-cursor tap.
                                                                 2'b00 = not updated
                                                                 2'b01 = minimum
                                                                 2'b10 = updated
                                                                 2'b11 = maximum */
        uint32_t c_0                   : 2;  /**< [  3:  2](R/W/H) Status report field for cursor tap. */
        uint32_t c_m1                  : 2;  /**< [  5:  4](R/W/H) Status report field for pre-cursor tap. */
        uint32_t local_rx_ready        : 1;  /**< [  6:  6](R/W/H) Status report field to indicate local receiver is ready.  Should be set based on
                                                                 LTSM output of corresponding variable. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_lt_tx_status_report_ctrl0_s cn; */
};
typedef union cavm_gsercx_lnx_lt_tx_status_report_ctrl0 cavm_gsercx_lnx_lt_tx_status_report_ctrl0_t;

static inline uint64_t CAVM_GSERCX_LNX_LT_TX_STATUS_REPORT_CTRL0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_LT_TX_STATUS_REPORT_CTRL0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013d10ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013d10ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_LT_TX_STATUS_REPORT_CTRL0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_LT_TX_STATUS_REPORT_CTRL0(a,b) cavm_gsercx_lnx_lt_tx_status_report_ctrl0_t
#define bustype_CAVM_GSERCX_LNX_LT_TX_STATUS_REPORT_CTRL0(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_LT_TX_STATUS_REPORT_CTRL0(a,b) "GSERCX_LNX_LT_TX_STATUS_REPORT_CTRL0"
#define device_bar_CAVM_GSERCX_LNX_LT_TX_STATUS_REPORT_CTRL0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_LT_TX_STATUS_REPORT_CTRL0(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_LT_TX_STATUS_REPORT_CTRL0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_tx_status_report_ctrl1
 *
 * GSERC Ln Lt Tx Status Report Ctrl1 Register
 */
union cavm_gsercx_lnx_lt_tx_status_report_ctrl1
{
    uint32_t u;
    struct cavm_gsercx_lnx_lt_tx_status_report_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t field_13_6            : 8;  /**< [  7:  0](R/W/H) Controls bits 13:6 of the status report control channel field. */
#else /* Word 0 - Little Endian */
        uint32_t field_13_6            : 8;  /**< [  7:  0](R/W/H) Controls bits 13:6 of the status report control channel field. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_lt_tx_status_report_ctrl1_s cn; */
};
typedef union cavm_gsercx_lnx_lt_tx_status_report_ctrl1 cavm_gsercx_lnx_lt_tx_status_report_ctrl1_t;

static inline uint64_t CAVM_GSERCX_LNX_LT_TX_STATUS_REPORT_CTRL1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_LT_TX_STATUS_REPORT_CTRL1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013d18ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013d18ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_LT_TX_STATUS_REPORT_CTRL1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_LT_TX_STATUS_REPORT_CTRL1(a,b) cavm_gsercx_lnx_lt_tx_status_report_ctrl1_t
#define bustype_CAVM_GSERCX_LNX_LT_TX_STATUS_REPORT_CTRL1(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_LT_TX_STATUS_REPORT_CTRL1(a,b) "GSERCX_LNX_LT_TX_STATUS_REPORT_CTRL1"
#define device_bar_CAVM_GSERCX_LNX_LT_TX_STATUS_REPORT_CTRL1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_LT_TX_STATUS_REPORT_CTRL1(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_LT_TX_STATUS_REPORT_CTRL1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_tx_status_report_ctrl2
 *
 * GSERC Ln Lt Tx Status Report Ctrl2 Register
 */
union cavm_gsercx_lnx_lt_tx_status_report_ctrl2
{
    uint32_t u;
    struct cavm_gsercx_lnx_lt_tx_status_report_ctrl2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t field_14              : 1;  /**< [  0:  0](R/W/H) Controls bits 14 of the status report control channel field. */
#else /* Word 0 - Little Endian */
        uint32_t field_14              : 1;  /**< [  0:  0](R/W/H) Controls bits 14 of the status report control channel field. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_lt_tx_status_report_ctrl2_s cn; */
};
typedef union cavm_gsercx_lnx_lt_tx_status_report_ctrl2 cavm_gsercx_lnx_lt_tx_status_report_ctrl2_t;

static inline uint64_t CAVM_GSERCX_LNX_LT_TX_STATUS_REPORT_CTRL2(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_LT_TX_STATUS_REPORT_CTRL2(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8013d20ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013d20ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_LT_TX_STATUS_REPORT_CTRL2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_LT_TX_STATUS_REPORT_CTRL2(a,b) cavm_gsercx_lnx_lt_tx_status_report_ctrl2_t
#define bustype_CAVM_GSERCX_LNX_LT_TX_STATUS_REPORT_CTRL2(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_LT_TX_STATUS_REPORT_CTRL2(a,b) "GSERCX_LNX_LT_TX_STATUS_REPORT_CTRL2"
#define device_bar_CAVM_GSERCX_LNX_LT_TX_STATUS_REPORT_CTRL2(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_LT_TX_STATUS_REPORT_CTRL2(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_LT_TX_STATUS_REPORT_CTRL2(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_afe_loopback_ctrl
 *
 * GSERC Ln Top Afe Loopback Ctrl Register
 */
union cavm_gsercx_lnx_top_afe_loopback_ctrl
{
    uint32_t u;
    struct cavm_gsercx_lnx_top_afe_loopback_ctrl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t loopback_nea_en       : 1;  /**< [  3:  3](R/W/H) Enable for Near-End Analog NEA loopback mode. */
        uint32_t loopback_fea_en       : 1;  /**< [  2:  2](R/W/H) Enable for Far-End Analog FEA loopback mode. */
        uint32_t loopback_txclk_en     : 1;  /**< [  1:  1](R/W/H) Enable for TX clock loopback mode. */
        uint32_t loopback_rxclk_en     : 1;  /**< [  0:  0](R/W/H) Enable for RX clock loopback mode. */
#else /* Word 0 - Little Endian */
        uint32_t loopback_rxclk_en     : 1;  /**< [  0:  0](R/W/H) Enable for RX clock loopback mode. */
        uint32_t loopback_txclk_en     : 1;  /**< [  1:  1](R/W/H) Enable for TX clock loopback mode. */
        uint32_t loopback_fea_en       : 1;  /**< [  2:  2](R/W/H) Enable for Far-End Analog FEA loopback mode. */
        uint32_t loopback_nea_en       : 1;  /**< [  3:  3](R/W/H) Enable for Near-End Analog NEA loopback mode. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_top_afe_loopback_ctrl_s cn; */
};
typedef union cavm_gsercx_lnx_top_afe_loopback_ctrl cavm_gsercx_lnx_top_afe_loopback_ctrl_t;

static inline uint64_t CAVM_GSERCX_LNX_TOP_AFE_LOOPBACK_CTRL(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_TOP_AFE_LOOPBACK_CTRL(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8010000ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010000ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_TOP_AFE_LOOPBACK_CTRL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_TOP_AFE_LOOPBACK_CTRL(a,b) cavm_gsercx_lnx_top_afe_loopback_ctrl_t
#define bustype_CAVM_GSERCX_LNX_TOP_AFE_LOOPBACK_CTRL(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_TOP_AFE_LOOPBACK_CTRL(a,b) "GSERCX_LNX_TOP_AFE_LOOPBACK_CTRL"
#define device_bar_CAVM_GSERCX_LNX_TOP_AFE_LOOPBACK_CTRL(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_TOP_AFE_LOOPBACK_CTRL(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_TOP_AFE_LOOPBACK_CTRL(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_afe_rxclkdiv_ctrl0
 *
 * GSERC Ln Top Afe Rxclkdiv Ctrl0 Register
 */
union cavm_gsercx_lnx_top_afe_rxclkdiv_ctrl0
{
    uint32_t u;
    struct cavm_gsercx_lnx_top_afe_rxclkdiv_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t rxclkdiv_sel          : 4;  /**< [  3:  0](R/W/H) RX clock divider division control. This divider affects the output clock RX*X*_CLK_DIV_O clk_rxdiv.
                                                                 0x0 = DIV1
                                                                 0x1 = DIV2
                                                                 0x2 = DIV4
                                                                 0x3 = DIV5 for 20-bit parallel interface via gearbox
                                                                 0x4 = DIV8
                                                                 0x5 = DIV10 for 40-bit parallel interface via gearbox
                                                                 0x6 = DIV16
                                                                 0x7 = DIV 16.5
                                                                 0x8 = DIV 20
                                                                 0x9 = DIV 32
                                                                 0xA = DIV 33
                                                                 0xB = DIV 40
                                                                 0xC = DIV 66
                                                                 0xD = DIV 80
                                                                 0xE = DIV 90
                                                                 0xF = DIV 5 also enable CLK2 to come in instead of CLK4 to create equivalent of CLK10 */
#else /* Word 0 - Little Endian */
        uint32_t rxclkdiv_sel          : 4;  /**< [  3:  0](R/W/H) RX clock divider division control. This divider affects the output clock RX*X*_CLK_DIV_O clk_rxdiv.
                                                                 0x0 = DIV1
                                                                 0x1 = DIV2
                                                                 0x2 = DIV4
                                                                 0x3 = DIV5 for 20-bit parallel interface via gearbox
                                                                 0x4 = DIV8
                                                                 0x5 = DIV10 for 40-bit parallel interface via gearbox
                                                                 0x6 = DIV16
                                                                 0x7 = DIV 16.5
                                                                 0x8 = DIV 20
                                                                 0x9 = DIV 32
                                                                 0xA = DIV 33
                                                                 0xB = DIV 40
                                                                 0xC = DIV 66
                                                                 0xD = DIV 80
                                                                 0xE = DIV 90
                                                                 0xF = DIV 5 also enable CLK2 to come in instead of CLK4 to create equivalent of CLK10 */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_top_afe_rxclkdiv_ctrl0_s cn; */
};
typedef union cavm_gsercx_lnx_top_afe_rxclkdiv_ctrl0 cavm_gsercx_lnx_top_afe_rxclkdiv_ctrl0_t;

static inline uint64_t CAVM_GSERCX_LNX_TOP_AFE_RXCLKDIV_CTRL0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_TOP_AFE_RXCLKDIV_CTRL0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a80100b0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80100b0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_TOP_AFE_RXCLKDIV_CTRL0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_TOP_AFE_RXCLKDIV_CTRL0(a,b) cavm_gsercx_lnx_top_afe_rxclkdiv_ctrl0_t
#define bustype_CAVM_GSERCX_LNX_TOP_AFE_RXCLKDIV_CTRL0(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_TOP_AFE_RXCLKDIV_CTRL0(a,b) "GSERCX_LNX_TOP_AFE_RXCLKDIV_CTRL0"
#define device_bar_CAVM_GSERCX_LNX_TOP_AFE_RXCLKDIV_CTRL0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_TOP_AFE_RXCLKDIV_CTRL0(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_TOP_AFE_RXCLKDIV_CTRL0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_afe_rxdp_ctrl1
 *
 * GSERC Ln Top Afe Rxdp Ctrl1 Register
 */
union cavm_gsercx_lnx_top_afe_rxdp_ctrl1
{
    uint32_t u;
    struct cavm_gsercx_lnx_top_afe_rxdp_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t rxdp_data_width       : 2;  /**< [  1:  0](R/W/H) AFE RXDP data width
                                                                 00 = 16 Bit
                                                                 01 = 20 Bit
                                                                 10 = 32 Bit
                                                                 11 = not used */
#else /* Word 0 - Little Endian */
        uint32_t rxdp_data_width       : 2;  /**< [  1:  0](R/W/H) AFE RXDP data width
                                                                 00 = 16 Bit
                                                                 01 = 20 Bit
                                                                 10 = 32 Bit
                                                                 11 = not used */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_top_afe_rxdp_ctrl1_s cn; */
};
typedef union cavm_gsercx_lnx_top_afe_rxdp_ctrl1 cavm_gsercx_lnx_top_afe_rxdp_ctrl1_t;

static inline uint64_t CAVM_GSERCX_LNX_TOP_AFE_RXDP_CTRL1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_TOP_AFE_RXDP_CTRL1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8010098ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010098ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_TOP_AFE_RXDP_CTRL1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_TOP_AFE_RXDP_CTRL1(a,b) cavm_gsercx_lnx_top_afe_rxdp_ctrl1_t
#define bustype_CAVM_GSERCX_LNX_TOP_AFE_RXDP_CTRL1(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_TOP_AFE_RXDP_CTRL1(a,b) "GSERCX_LNX_TOP_AFE_RXDP_CTRL1"
#define device_bar_CAVM_GSERCX_LNX_TOP_AFE_RXDP_CTRL1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_TOP_AFE_RXDP_CTRL1(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_TOP_AFE_RXDP_CTRL1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_afe_txcp_ctrl2
 *
 * GSERC Ln Top Afe Txcp Ctrl2 Register
 */
union cavm_gsercx_lnx_top_afe_txcp_ctrl2
{
    uint32_t u;
    struct cavm_gsercx_lnx_top_afe_txcp_ctrl2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t txcp_tx3clk_en        : 1;  /**< [  3:  3](R/W/H) Select rate3 input clocks to TXCP from CMU macro.
                                                                 0 = rate1 or rate2 clock from PLL1 or PLL2
                                                                 1 = rate3 clock from PLL3 DIV 4.125
                                                                 This register is configured by firmware at PHY initialization based on data rate
                                                                 and PHY mode determined by top-level interface pins. */
        uint32_t txcp_tx2clk_en        : 1;  /**< [  2:  2](R/W/H) Select either rate1 or rate2 input clocks to TXCP from CMU macro.
                                                                 0 = rate1 clock from PLL1, aka LCPLL
                                                                 1 = rate2 clock from PLL2, aka RPLL
                                                                 This register is configured by firmware at PHY initialization based on data rate
                                                                 and PHY mode determined by top-level interface pins. */
        uint32_t txcp_clkdiv           : 2;  /**< [  1:  0](R/W/H) Enable for TXCP divide-by-2 for rate1 clock from CMU macro.
                                                                 0 = DIV1 mode
                                                                 1 = DIV2 mode
                                                                 2 = DIV4 mode 16G MP PHY only
                                                                 3 = reserved
                                                                 This register is configured by firmware at PHY initialization based on data rate
                                                                 and PHY mode determined by top-level interface pins. */
#else /* Word 0 - Little Endian */
        uint32_t txcp_clkdiv           : 2;  /**< [  1:  0](R/W/H) Enable for TXCP divide-by-2 for rate1 clock from CMU macro.
                                                                 0 = DIV1 mode
                                                                 1 = DIV2 mode
                                                                 2 = DIV4 mode 16G MP PHY only
                                                                 3 = reserved
                                                                 This register is configured by firmware at PHY initialization based on data rate
                                                                 and PHY mode determined by top-level interface pins. */
        uint32_t txcp_tx2clk_en        : 1;  /**< [  2:  2](R/W/H) Select either rate1 or rate2 input clocks to TXCP from CMU macro.
                                                                 0 = rate1 clock from PLL1, aka LCPLL
                                                                 1 = rate2 clock from PLL2, aka RPLL
                                                                 This register is configured by firmware at PHY initialization based on data rate
                                                                 and PHY mode determined by top-level interface pins. */
        uint32_t txcp_tx3clk_en        : 1;  /**< [  3:  3](R/W/H) Select rate3 input clocks to TXCP from CMU macro.
                                                                 0 = rate1 or rate2 clock from PLL1 or PLL2
                                                                 1 = rate3 clock from PLL3 DIV 4.125
                                                                 This register is configured by firmware at PHY initialization based on data rate
                                                                 and PHY mode determined by top-level interface pins. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_top_afe_txcp_ctrl2_s cn; */
};
typedef union cavm_gsercx_lnx_top_afe_txcp_ctrl2 cavm_gsercx_lnx_top_afe_txcp_ctrl2_t;

static inline uint64_t CAVM_GSERCX_LNX_TOP_AFE_TXCP_CTRL2(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_TOP_AFE_TXCP_CTRL2(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8010068ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010068ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_TOP_AFE_TXCP_CTRL2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_TOP_AFE_TXCP_CTRL2(a,b) cavm_gsercx_lnx_top_afe_txcp_ctrl2_t
#define bustype_CAVM_GSERCX_LNX_TOP_AFE_TXCP_CTRL2(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_TOP_AFE_TXCP_CTRL2(a,b) "GSERCX_LNX_TOP_AFE_TXCP_CTRL2"
#define device_bar_CAVM_GSERCX_LNX_TOP_AFE_TXCP_CTRL2(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_TOP_AFE_TXCP_CTRL2(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_TOP_AFE_TXCP_CTRL2(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_afe_txcp_ctrl4
 *
 * GSERC Ln Top Afe Txcp Ctrl4 Register
 */
union cavm_gsercx_lnx_top_afe_txcp_ctrl4
{
    uint32_t u;
    struct cavm_gsercx_lnx_top_afe_txcp_ctrl4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t txcp_loopback_swing   : 2;  /**< [  3:  2](R/W/H) Reserved. */
        uint32_t txcp_tx2clk_tst       : 1;  /**< [  1:  1](R/W/H) Enable for TXCP test clock mode after internal AC coupling.
                                                                 This mode allows the test clock from the CMU macro to be muxed into the main
                                                                 transmit data path after the internal AC coupling within the TXCP. The injection
                                                                 of the test clock after the AC coupling is preferred for lower frequency test
                                                                 clocks approx \< 500MHz. */
        uint32_t txcp_toggle_en        : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t txcp_toggle_en        : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t txcp_tx2clk_tst       : 1;  /**< [  1:  1](R/W/H) Enable for TXCP test clock mode after internal AC coupling.
                                                                 This mode allows the test clock from the CMU macro to be muxed into the main
                                                                 transmit data path after the internal AC coupling within the TXCP. The injection
                                                                 of the test clock after the AC coupling is preferred for lower frequency test
                                                                 clocks approx \< 500MHz. */
        uint32_t txcp_loopback_swing   : 2;  /**< [  3:  2](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_top_afe_txcp_ctrl4_s cn; */
};
typedef union cavm_gsercx_lnx_top_afe_txcp_ctrl4 cavm_gsercx_lnx_top_afe_txcp_ctrl4_t;

static inline uint64_t CAVM_GSERCX_LNX_TOP_AFE_TXCP_CTRL4(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_TOP_AFE_TXCP_CTRL4(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8010078ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010078ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_TOP_AFE_TXCP_CTRL4", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_TOP_AFE_TXCP_CTRL4(a,b) cavm_gsercx_lnx_top_afe_txcp_ctrl4_t
#define bustype_CAVM_GSERCX_LNX_TOP_AFE_TXCP_CTRL4(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_TOP_AFE_TXCP_CTRL4(a,b) "GSERCX_LNX_TOP_AFE_TXCP_CTRL4"
#define device_bar_CAVM_GSERCX_LNX_TOP_AFE_TXCP_CTRL4(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_TOP_AFE_TXCP_CTRL4(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_TOP_AFE_TXCP_CTRL4(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_afe_txdp_ctrl0
 *
 * GSERC Ln Top Afe Txdp Ctrl0 Register
 */
union cavm_gsercx_lnx_top_afe_txdp_ctrl0
{
    uint32_t u;
    struct cavm_gsercx_lnx_top_afe_txdp_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t txdp_data_width       : 2;  /**< [  1:  0](R/W/H) AFE TXDP data width
                                                                 00 = 16 Bit
                                                                 01 = 20 Bit
                                                                 10 = 32 Bit
                                                                 11 = not used */
#else /* Word 0 - Little Endian */
        uint32_t txdp_data_width       : 2;  /**< [  1:  0](R/W/H) AFE TXDP data width
                                                                 00 = 16 Bit
                                                                 01 = 20 Bit
                                                                 10 = 32 Bit
                                                                 11 = not used */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_top_afe_txdp_ctrl0_s cn; */
};
typedef union cavm_gsercx_lnx_top_afe_txdp_ctrl0 cavm_gsercx_lnx_top_afe_txdp_ctrl0_t;

static inline uint64_t CAVM_GSERCX_LNX_TOP_AFE_TXDP_CTRL0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_TOP_AFE_TXDP_CTRL0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8010080ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010080ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_TOP_AFE_TXDP_CTRL0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_TOP_AFE_TXDP_CTRL0(a,b) cavm_gsercx_lnx_top_afe_txdp_ctrl0_t
#define bustype_CAVM_GSERCX_LNX_TOP_AFE_TXDP_CTRL0(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_TOP_AFE_TXDP_CTRL0(a,b) "GSERCX_LNX_TOP_AFE_TXDP_CTRL0"
#define device_bar_CAVM_GSERCX_LNX_TOP_AFE_TXDP_CTRL0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_TOP_AFE_TXDP_CTRL0(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_TOP_AFE_TXDP_CTRL0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_bit_stuff_strip_ctrl
 *
 * GSERC Ln Top Bit Stuff Strip Ctrl Register
 */
union cavm_gsercx_lnx_top_bit_stuff_strip_ctrl
{
    uint32_t u;
    struct cavm_gsercx_lnx_top_bit_stuff_strip_ctrl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t bit_strip_even        : 1;  /**< [  2:  2](R/W/H) Selects which bits to strip when bit stripping is enabled in the DPL RX data path:
                                                                 0x0 = Odd bits stripped from RX data
                                                                 0x1 = Even bits stripped from RX data */
        uint32_t bit_strip_en          : 1;  /**< [  1:  1](R/W/H) Enables bit stripping in the DPL RX data path:
                                                                 0x0 = Bit stripping disabled
                                                                 0x1 = Bit stripping enabled */
        uint32_t bit_stuff_en          : 1;  /**< [  0:  0](R/W/H) Enables bit stuffing in the DPL TX data path:
                                                                 0x0 = Bit stuffing disabled
                                                                 0x1 = Bit stuffing enabled */
#else /* Word 0 - Little Endian */
        uint32_t bit_stuff_en          : 1;  /**< [  0:  0](R/W/H) Enables bit stuffing in the DPL TX data path:
                                                                 0x0 = Bit stuffing disabled
                                                                 0x1 = Bit stuffing enabled */
        uint32_t bit_strip_en          : 1;  /**< [  1:  1](R/W/H) Enables bit stripping in the DPL RX data path:
                                                                 0x0 = Bit stripping disabled
                                                                 0x1 = Bit stripping enabled */
        uint32_t bit_strip_even        : 1;  /**< [  2:  2](R/W/H) Selects which bits to strip when bit stripping is enabled in the DPL RX data path:
                                                                 0x0 = Odd bits stripped from RX data
                                                                 0x1 = Even bits stripped from RX data */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_top_bit_stuff_strip_ctrl_s cn; */
};
typedef union cavm_gsercx_lnx_top_bit_stuff_strip_ctrl cavm_gsercx_lnx_top_bit_stuff_strip_ctrl_t;

static inline uint64_t CAVM_GSERCX_LNX_TOP_BIT_STUFF_STRIP_CTRL(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_TOP_BIT_STUFF_STRIP_CTRL(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a80100c8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80100c8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_TOP_BIT_STUFF_STRIP_CTRL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_TOP_BIT_STUFF_STRIP_CTRL(a,b) cavm_gsercx_lnx_top_bit_stuff_strip_ctrl_t
#define bustype_CAVM_GSERCX_LNX_TOP_BIT_STUFF_STRIP_CTRL(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_TOP_BIT_STUFF_STRIP_CTRL(a,b) "GSERCX_LNX_TOP_BIT_STUFF_STRIP_CTRL"
#define device_bar_CAVM_GSERCX_LNX_TOP_BIT_STUFF_STRIP_CTRL(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_TOP_BIT_STUFF_STRIP_CTRL(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_TOP_BIT_STUFF_STRIP_CTRL(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_dpl_rxdp_ctrl1
 *
 * GSERC Ln Top Dpl Rxdp Ctrl1 Register
 */
union cavm_gsercx_lnx_top_dpl_rxdp_ctrl1
{
    uint32_t u;
    struct cavm_gsercx_lnx_top_dpl_rxdp_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t rx_fifo_en            : 1;  /**< [  1:  1](R/W/H) Enable for the RX gearbox FIFO. */
        uint32_t rx_dmux_sel           : 1;  /**< [  0:  0](R/W/H) A mux select for RX data path
                                                                 0 = AFE rx data
                                                                 1 = TX data for LB_NED */
#else /* Word 0 - Little Endian */
        uint32_t rx_dmux_sel           : 1;  /**< [  0:  0](R/W/H) A mux select for RX data path
                                                                 0 = AFE rx data
                                                                 1 = TX data for LB_NED */
        uint32_t rx_fifo_en            : 1;  /**< [  1:  1](R/W/H) Enable for the RX gearbox FIFO. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_top_dpl_rxdp_ctrl1_s cn; */
};
typedef union cavm_gsercx_lnx_top_dpl_rxdp_ctrl1 cavm_gsercx_lnx_top_dpl_rxdp_ctrl1_t;

static inline uint64_t CAVM_GSERCX_LNX_TOP_DPL_RXDP_CTRL1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_TOP_DPL_RXDP_CTRL1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8010120ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010120ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_TOP_DPL_RXDP_CTRL1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_TOP_DPL_RXDP_CTRL1(a,b) cavm_gsercx_lnx_top_dpl_rxdp_ctrl1_t
#define bustype_CAVM_GSERCX_LNX_TOP_DPL_RXDP_CTRL1(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_TOP_DPL_RXDP_CTRL1(a,b) "GSERCX_LNX_TOP_DPL_RXDP_CTRL1"
#define device_bar_CAVM_GSERCX_LNX_TOP_DPL_RXDP_CTRL1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_TOP_DPL_RXDP_CTRL1(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_TOP_DPL_RXDP_CTRL1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_dpl_txdp_ctrl1
 *
 * GSERC Ln Top Dpl Txdp Ctrl1 Register
 */
union cavm_gsercx_lnx_top_dpl_txdp_ctrl1
{
    uint32_t u;
    struct cavm_gsercx_lnx_top_dpl_txdp_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t lb_fed_tx_en          : 1;  /**< [  7:  7](R/W/H) Enable for tx_en to dmux_txa for LB_FEB path.  Tx_en for the path will be set
                                                                 when both this field is set to 1 and rxvalid is 1. */
        uint32_t tx_fifo_en            : 1;  /**< [  6:  6](R/W/H) Enable for the TX gearbox FIFO. */
        uint32_t txpolarity            : 1;  /**< [  5:  5](R/W/H) TX data polarity control
                                                                 0 = No polarity inversion
                                                                 1 = Polarity inverted */
        uint32_t tx_dmux2_sel          : 1;  /**< [  4:  4](R/W/H) Select control for DPL TX data path mux tx_dumx2
                                                                 0 : TX data from customer logics
                                                                 1 = BIST generator */
        uint32_t dmux_txa_sel_ovr_val  : 3;  /**< [  3:  1](R/W/H) Select value for TX data path mux in DPL.  The corresponding mux select override
                                                                 enable must also be set.
                                                                 0 : TX data from customer logics
                                                                 1 = RX data for Far-End-Digital FED loopback
                                                                 2 = AN/802.3
                                                                 3-7: reserved
                                                                 Note: 2/3 encodiing are invalid when AN/LT is not present */
        uint32_t dmux_txa_sel_ovr_en   : 1;  /**< [  0:  0](R/W/H) Enables register control of TX data path mux in DPL. */
#else /* Word 0 - Little Endian */
        uint32_t dmux_txa_sel_ovr_en   : 1;  /**< [  0:  0](R/W/H) Enables register control of TX data path mux in DPL. */
        uint32_t dmux_txa_sel_ovr_val  : 3;  /**< [  3:  1](R/W/H) Select value for TX data path mux in DPL.  The corresponding mux select override
                                                                 enable must also be set.
                                                                 0 : TX data from customer logics
                                                                 1 = RX data for Far-End-Digital FED loopback
                                                                 2 = AN/802.3
                                                                 3-7: reserved
                                                                 Note: 2/3 encodiing are invalid when AN/LT is not present */
        uint32_t tx_dmux2_sel          : 1;  /**< [  4:  4](R/W/H) Select control for DPL TX data path mux tx_dumx2
                                                                 0 : TX data from customer logics
                                                                 1 = BIST generator */
        uint32_t txpolarity            : 1;  /**< [  5:  5](R/W/H) TX data polarity control
                                                                 0 = No polarity inversion
                                                                 1 = Polarity inverted */
        uint32_t tx_fifo_en            : 1;  /**< [  6:  6](R/W/H) Enable for the TX gearbox FIFO. */
        uint32_t lb_fed_tx_en          : 1;  /**< [  7:  7](R/W/H) Enable for tx_en to dmux_txa for LB_FEB path.  Tx_en for the path will be set
                                                                 when both this field is set to 1 and rxvalid is 1. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_top_dpl_txdp_ctrl1_s cn; */
};
typedef union cavm_gsercx_lnx_top_dpl_txdp_ctrl1 cavm_gsercx_lnx_top_dpl_txdp_ctrl1_t;

static inline uint64_t CAVM_GSERCX_LNX_TOP_DPL_TXDP_CTRL1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_TOP_DPL_TXDP_CTRL1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8010110ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010110ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_TOP_DPL_TXDP_CTRL1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_TOP_DPL_TXDP_CTRL1(a,b) cavm_gsercx_lnx_top_dpl_txdp_ctrl1_t
#define bustype_CAVM_GSERCX_LNX_TOP_DPL_TXDP_CTRL1(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_TOP_DPL_TXDP_CTRL1(a,b) "GSERCX_LNX_TOP_DPL_TXDP_CTRL1"
#define device_bar_CAVM_GSERCX_LNX_TOP_DPL_TXDP_CTRL1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_TOP_DPL_TXDP_CTRL1(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_TOP_DPL_TXDP_CTRL1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_err_ctrl1
 *
 * GSERC Ln Top Err Ctrl1 Register
 */
union cavm_gsercx_lnx_top_err_ctrl1
{
    uint32_t u;
    struct cavm_gsercx_lnx_top_err_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t err_code_7_0          : 8;  /**< [  7:  0](R/W/H) Lane top-level firmware error code lower 8-bits of 16-bit error code. */
#else /* Word 0 - Little Endian */
        uint32_t err_code_7_0          : 8;  /**< [  7:  0](R/W/H) Lane top-level firmware error code lower 8-bits of 16-bit error code. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_top_err_ctrl1_s cn; */
};
typedef union cavm_gsercx_lnx_top_err_ctrl1 cavm_gsercx_lnx_top_err_ctrl1_t;

static inline uint64_t CAVM_GSERCX_LNX_TOP_ERR_CTRL1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_TOP_ERR_CTRL1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8010280ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010280ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_TOP_ERR_CTRL1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_TOP_ERR_CTRL1(a,b) cavm_gsercx_lnx_top_err_ctrl1_t
#define bustype_CAVM_GSERCX_LNX_TOP_ERR_CTRL1(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_TOP_ERR_CTRL1(a,b) "GSERCX_LNX_TOP_ERR_CTRL1"
#define device_bar_CAVM_GSERCX_LNX_TOP_ERR_CTRL1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_TOP_ERR_CTRL1(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_TOP_ERR_CTRL1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_err_ctrl2
 *
 * GSERC Ln Top Err Ctrl2 Register
 */
union cavm_gsercx_lnx_top_err_ctrl2
{
    uint32_t u;
    struct cavm_gsercx_lnx_top_err_ctrl2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t err_code_15_8         : 8;  /**< [  7:  0](R/W/H) Lane top-level firmware error code higher 8-bits of 16-bit error code. */
#else /* Word 0 - Little Endian */
        uint32_t err_code_15_8         : 8;  /**< [  7:  0](R/W/H) Lane top-level firmware error code higher 8-bits of 16-bit error code. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_top_err_ctrl2_s cn; */
};
typedef union cavm_gsercx_lnx_top_err_ctrl2 cavm_gsercx_lnx_top_err_ctrl2_t;

static inline uint64_t CAVM_GSERCX_LNX_TOP_ERR_CTRL2(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_TOP_ERR_CTRL2(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8010288ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010288ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_TOP_ERR_CTRL2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_TOP_ERR_CTRL2(a,b) cavm_gsercx_lnx_top_err_ctrl2_t
#define bustype_CAVM_GSERCX_LNX_TOP_ERR_CTRL2(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_TOP_ERR_CTRL2(a,b) "GSERCX_LNX_TOP_ERR_CTRL2"
#define device_bar_CAVM_GSERCX_LNX_TOP_ERR_CTRL2(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_TOP_ERR_CTRL2(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_TOP_ERR_CTRL2(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_err_ctrl3
 *
 * GSERC Ln Top Err Ctrl3 Register
 */
union cavm_gsercx_lnx_top_err_ctrl3
{
    uint32_t u;
    struct cavm_gsercx_lnx_top_err_ctrl3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t critical_err_rx       : 1;  /**< [  1:  1](R/W/H) Lane RX critical error status.
                                                                 1 indicates that a critical error has occurred in Lane RX. ln()_rx_rdy_o is
                                                                 gated when this is set to 1 */
        uint32_t critical_err_tx       : 1;  /**< [  0:  0](R/W/H) Lane TX critical error status.
                                                                 1 indicates that a critical error has occurred in Lane TX. ln()_tx_rdy_o is
                                                                 gated when this is set to 1 */
#else /* Word 0 - Little Endian */
        uint32_t critical_err_tx       : 1;  /**< [  0:  0](R/W/H) Lane TX critical error status.
                                                                 1 indicates that a critical error has occurred in Lane TX. ln()_tx_rdy_o is
                                                                 gated when this is set to 1 */
        uint32_t critical_err_rx       : 1;  /**< [  1:  1](R/W/H) Lane RX critical error status.
                                                                 1 indicates that a critical error has occurred in Lane RX. ln()_rx_rdy_o is
                                                                 gated when this is set to 1 */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_top_err_ctrl3_s cn; */
};
typedef union cavm_gsercx_lnx_top_err_ctrl3 cavm_gsercx_lnx_top_err_ctrl3_t;

static inline uint64_t CAVM_GSERCX_LNX_TOP_ERR_CTRL3(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_TOP_ERR_CTRL3(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8010290ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010290ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_TOP_ERR_CTRL3", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_TOP_ERR_CTRL3(a,b) cavm_gsercx_lnx_top_err_ctrl3_t
#define bustype_CAVM_GSERCX_LNX_TOP_ERR_CTRL3(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_TOP_ERR_CTRL3(a,b) "GSERCX_LNX_TOP_ERR_CTRL3"
#define device_bar_CAVM_GSERCX_LNX_TOP_ERR_CTRL3(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_TOP_ERR_CTRL3(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_TOP_ERR_CTRL3(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_ln_ctrl_ovr0
 *
 * GSERC Ln Top Ln Ctrl Ovr0 Register
 */
union cavm_gsercx_lnx_top_ln_ctrl_ovr0
{
    uint32_t u;
    struct cavm_gsercx_lnx_top_ln_ctrl_ovr0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t tx_en                 : 1;  /**< [  4:  4](R/W/H) Override value for TX*X*_CTRL_TX_EN_I ln()_tx_en_i.  It takes effect when ovr_en is 1.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t eye_rxpolarity        : 1;  /**< [  3:  3](R/W/H) Eye_rxpolarity  inversion control bit.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t edge_rxpolarity       : 1;  /**< [  2:  2](R/W/H) Edge_rxpolarity  inversion control bit.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t data_rxpolarity       : 1;  /**< [  1:  1](R/W/H) Override value for RX*X*_CTRL_RXPOLARITY_I ln()_rxpolarity_i.  It takes effect when ovr_en is 1.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t ovr_en                : 1;  /**< [  0:  0](R/W/H) Override enable for ln()_ctrl_*_i signals in this register.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
#else /* Word 0 - Little Endian */
        uint32_t ovr_en                : 1;  /**< [  0:  0](R/W/H) Override enable for ln()_ctrl_*_i signals in this register.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t data_rxpolarity       : 1;  /**< [  1:  1](R/W/H) Override value for RX*X*_CTRL_RXPOLARITY_I ln()_rxpolarity_i.  It takes effect when ovr_en is 1.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t edge_rxpolarity       : 1;  /**< [  2:  2](R/W/H) Edge_rxpolarity  inversion control bit.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t eye_rxpolarity        : 1;  /**< [  3:  3](R/W/H) Eye_rxpolarity  inversion control bit.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t tx_en                 : 1;  /**< [  4:  4](R/W/H) Override value for TX*X*_CTRL_TX_EN_I ln()_tx_en_i.  It takes effect when ovr_en is 1.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_top_ln_ctrl_ovr0_s cn; */
};
typedef union cavm_gsercx_lnx_top_ln_ctrl_ovr0 cavm_gsercx_lnx_top_ln_ctrl_ovr0_t;

static inline uint64_t CAVM_GSERCX_LNX_TOP_LN_CTRL_OVR0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_TOP_LN_CTRL_OVR0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a80101d8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80101d8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_TOP_LN_CTRL_OVR0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_TOP_LN_CTRL_OVR0(a,b) cavm_gsercx_lnx_top_ln_ctrl_ovr0_t
#define bustype_CAVM_GSERCX_LNX_TOP_LN_CTRL_OVR0(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_TOP_LN_CTRL_OVR0(a,b) "GSERCX_LNX_TOP_LN_CTRL_OVR0"
#define device_bar_CAVM_GSERCX_LNX_TOP_LN_CTRL_OVR0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_TOP_LN_CTRL_OVR0(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_TOP_LN_CTRL_OVR0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_ln_ctrl_ovr1
 *
 * GSERC Ln Top Ln Ctrl Ovr1 Register
 */
union cavm_gsercx_lnx_top_ln_ctrl_ovr1
{
    uint32_t u;
    struct cavm_gsercx_lnx_top_ln_ctrl_ovr1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t rate_chng             : 1;  /**< [  5:  5](R/W/H) Override value for LN*X*_RATE_CHNG_I ln()_rate_chng_i.  It takes effect when ovr_en is 1.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t iddq                  : 1;  /**< [  4:  4](R/W/H) Override value for LN*X*_IDDQ_I ln()_iddq_i.  It takes effect when ovr_en is 1.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t rst_n                 : 1;  /**< [  3:  3](R/W/H) Override value for LN*X*_RST_N_I ln()_rst_n_i.  It takes effect when ovr_en is 1.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t pd                    : 2;  /**< [  2:  1](R/W/H) Override value for LN*X*_PD_I[1:0] ln()_pd_i.  It takes effect when ovr_en is 1.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t ovr_en                : 1;  /**< [  0:  0](R/W/H) Override enable for ln()_pd_i[1:0] and ln()_rst_n_i.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
#else /* Word 0 - Little Endian */
        uint32_t ovr_en                : 1;  /**< [  0:  0](R/W/H) Override enable for ln()_pd_i[1:0] and ln()_rst_n_i.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t pd                    : 2;  /**< [  2:  1](R/W/H) Override value for LN*X*_PD_I[1:0] ln()_pd_i.  It takes effect when ovr_en is 1.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t rst_n                 : 1;  /**< [  3:  3](R/W/H) Override value for LN*X*_RST_N_I ln()_rst_n_i.  It takes effect when ovr_en is 1.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t iddq                  : 1;  /**< [  4:  4](R/W/H) Override value for LN*X*_IDDQ_I ln()_iddq_i.  It takes effect when ovr_en is 1.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t rate_chng             : 1;  /**< [  5:  5](R/W/H) Override value for LN*X*_RATE_CHNG_I ln()_rate_chng_i.  It takes effect when ovr_en is 1.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_top_ln_ctrl_ovr1_s cn; */
};
typedef union cavm_gsercx_lnx_top_ln_ctrl_ovr1 cavm_gsercx_lnx_top_ln_ctrl_ovr1_t;

static inline uint64_t CAVM_GSERCX_LNX_TOP_LN_CTRL_OVR1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_TOP_LN_CTRL_OVR1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a80101e0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80101e0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_TOP_LN_CTRL_OVR1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_TOP_LN_CTRL_OVR1(a,b) cavm_gsercx_lnx_top_ln_ctrl_ovr1_t
#define bustype_CAVM_GSERCX_LNX_TOP_LN_CTRL_OVR1(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_TOP_LN_CTRL_OVR1(a,b) "GSERCX_LNX_TOP_LN_CTRL_OVR1"
#define device_bar_CAVM_GSERCX_LNX_TOP_LN_CTRL_OVR1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_TOP_LN_CTRL_OVR1(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_TOP_LN_CTRL_OVR1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_ln_ctrl_ovr2
 *
 * GSERC Ln Top Ln Ctrl Ovr2 Register
 */
union cavm_gsercx_lnx_top_ln_ctrl_ovr2
{
    uint32_t u;
    struct cavm_gsercx_lnx_top_ln_ctrl_ovr2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t rx_data_rate          : 3;  /**< [  7:  5](R/W/H) RX override value for LN*X*_CTRL_DATA_RATE_I ln()_ctrl_data_rate_i.  It takes
                                                                 effect when rx_ovr_en is 1.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used.
                                                                 This register should not be used when programming separate TX and RX data rates
                                                                 per lane. Instead the direct TXCP and RXCDR registers should be used to setup
                                                                 the TX and RX data rates respectively. */
        uint32_t rx_ovr_en             : 1;  /**< [  4:  4](R/W/H) RX override enable for ln()_ctrl_*_i signals in this register.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t tx_data_rate          : 3;  /**< [  3:  1](R/W/H) TX override value for LN*X*_CTRL_DATA_RATE_I ln()_ctrl_data_rate_i.  It takes
                                                                 effect when tx_ovr_en is 1.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it can be used to support separate TX and RX data rates per
                                                                 lane. */
        uint32_t tx_ovr_en             : 1;  /**< [  0:  0](R/W/H) TX override enable for ln()_ctrl_*_i signals in this register.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
#else /* Word 0 - Little Endian */
        uint32_t tx_ovr_en             : 1;  /**< [  0:  0](R/W/H) TX override enable for ln()_ctrl_*_i signals in this register.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t tx_data_rate          : 3;  /**< [  3:  1](R/W/H) TX override value for LN*X*_CTRL_DATA_RATE_I ln()_ctrl_data_rate_i.  It takes
                                                                 effect when tx_ovr_en is 1.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it can be used to support separate TX and RX data rates per
                                                                 lane. */
        uint32_t rx_ovr_en             : 1;  /**< [  4:  4](R/W/H) RX override enable for ln()_ctrl_*_i signals in this register.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t rx_data_rate          : 3;  /**< [  7:  5](R/W/H) RX override value for LN*X*_CTRL_DATA_RATE_I ln()_ctrl_data_rate_i.  It takes
                                                                 effect when rx_ovr_en is 1.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used.
                                                                 This register should not be used when programming separate TX and RX data rates
                                                                 per lane. Instead the direct TXCP and RXCDR registers should be used to setup
                                                                 the TX and RX data rates respectively. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_top_ln_ctrl_ovr2_s cn; */
};
typedef union cavm_gsercx_lnx_top_ln_ctrl_ovr2 cavm_gsercx_lnx_top_ln_ctrl_ovr2_t;

static inline uint64_t CAVM_GSERCX_LNX_TOP_LN_CTRL_OVR2(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_TOP_LN_CTRL_OVR2(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a80101e8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80101e8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_TOP_LN_CTRL_OVR2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_TOP_LN_CTRL_OVR2(a,b) cavm_gsercx_lnx_top_ln_ctrl_ovr2_t
#define bustype_CAVM_GSERCX_LNX_TOP_LN_CTRL_OVR2(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_TOP_LN_CTRL_OVR2(a,b) "GSERCX_LNX_TOP_LN_CTRL_OVR2"
#define device_bar_CAVM_GSERCX_LNX_TOP_LN_CTRL_OVR2(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_TOP_LN_CTRL_OVR2(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_TOP_LN_CTRL_OVR2(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_ln_ctrl_ovr3
 *
 * GSERC Ln Top Ln Ctrl Ovr3 Register
 */
union cavm_gsercx_lnx_top_ln_ctrl_ovr3
{
    uint32_t u;
    struct cavm_gsercx_lnx_top_ln_ctrl_ovr3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t rx_data_width         : 3;  /**< [  6:  4](R/W/H) Override value for LN*X*_CTRL_DATA_WIDTH_I[2:0] ln()_data_width_i   for RX.  It
                                                                 takes effect when ovr_en is 1.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t tx_data_width         : 3;  /**< [  3:  1](R/W/H) Override value for LN*X*_CTRL_DATA_WIDTH_I[2:0] ln()_data_width_i  for TX.  It
                                                                 takes effect when ovr_en is 1.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t ovr_en                : 1;  /**< [  0:  0](R/W/H) Override enable for ln()_ctrl_*_i signals in this register.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
#else /* Word 0 - Little Endian */
        uint32_t ovr_en                : 1;  /**< [  0:  0](R/W/H) Override enable for ln()_ctrl_*_i signals in this register.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t tx_data_width         : 3;  /**< [  3:  1](R/W/H) Override value for LN*X*_CTRL_DATA_WIDTH_I[2:0] ln()_data_width_i  for TX.  It
                                                                 takes effect when ovr_en is 1.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t rx_data_width         : 3;  /**< [  6:  4](R/W/H) Override value for LN*X*_CTRL_DATA_WIDTH_I[2:0] ln()_data_width_i   for RX.  It
                                                                 takes effect when ovr_en is 1.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_top_ln_ctrl_ovr3_s cn; */
};
typedef union cavm_gsercx_lnx_top_ln_ctrl_ovr3 cavm_gsercx_lnx_top_ln_ctrl_ovr3_t;

static inline uint64_t CAVM_GSERCX_LNX_TOP_LN_CTRL_OVR3(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_TOP_LN_CTRL_OVR3(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a80101f0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80101f0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_TOP_LN_CTRL_OVR3", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_TOP_LN_CTRL_OVR3(a,b) cavm_gsercx_lnx_top_ln_ctrl_ovr3_t
#define bustype_CAVM_GSERCX_LNX_TOP_LN_CTRL_OVR3(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_TOP_LN_CTRL_OVR3(a,b) "GSERCX_LNX_TOP_LN_CTRL_OVR3"
#define device_bar_CAVM_GSERCX_LNX_TOP_LN_CTRL_OVR3(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_TOP_LN_CTRL_OVR3(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_TOP_LN_CTRL_OVR3(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_ln_ctrl_status0
 *
 * GSERC Ln Top Ln Ctrl Status0 Register
 */
union cavm_gsercx_lnx_top_ln_ctrl_status0
{
    uint32_t u;
    struct cavm_gsercx_lnx_top_ln_ctrl_status0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t rate_chng             : 1;  /**< [  6:  6](RO/H) Effective value of ln()_rst_n. */
        uint32_t iddq                  : 1;  /**< [  5:  5](RO/H) Effective value of ln()_rst_n. */
        uint32_t rst_n                 : 1;  /**< [  4:  4](RO/H) Effective value of ln()_rst_n. */
        uint32_t pd                    : 2;  /**< [  3:  2](RO/H) Effective value of ln()_pd. */
        uint32_t tx_en                 : 1;  /**< [  1:  1](RO/H) Effective value of ln()_tx_en for TX. */
        uint32_t data_rxpolarity       : 1;  /**< [  0:  0](RO/H) Effective value of ln()_rxpolarity for RX. */
#else /* Word 0 - Little Endian */
        uint32_t data_rxpolarity       : 1;  /**< [  0:  0](RO/H) Effective value of ln()_rxpolarity for RX. */
        uint32_t tx_en                 : 1;  /**< [  1:  1](RO/H) Effective value of ln()_tx_en for TX. */
        uint32_t pd                    : 2;  /**< [  3:  2](RO/H) Effective value of ln()_pd. */
        uint32_t rst_n                 : 1;  /**< [  4:  4](RO/H) Effective value of ln()_rst_n. */
        uint32_t iddq                  : 1;  /**< [  5:  5](RO/H) Effective value of ln()_rst_n. */
        uint32_t rate_chng             : 1;  /**< [  6:  6](RO/H) Effective value of ln()_rst_n. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_top_ln_ctrl_status0_s cn; */
};
typedef union cavm_gsercx_lnx_top_ln_ctrl_status0 cavm_gsercx_lnx_top_ln_ctrl_status0_t;

static inline uint64_t CAVM_GSERCX_LNX_TOP_LN_CTRL_STATUS0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_TOP_LN_CTRL_STATUS0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8010230ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010230ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_TOP_LN_CTRL_STATUS0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_TOP_LN_CTRL_STATUS0(a,b) cavm_gsercx_lnx_top_ln_ctrl_status0_t
#define bustype_CAVM_GSERCX_LNX_TOP_LN_CTRL_STATUS0(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_TOP_LN_CTRL_STATUS0(a,b) "GSERCX_LNX_TOP_LN_CTRL_STATUS0"
#define device_bar_CAVM_GSERCX_LNX_TOP_LN_CTRL_STATUS0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_TOP_LN_CTRL_STATUS0(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_TOP_LN_CTRL_STATUS0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_ln_ctrl_status1
 *
 * GSERC Ln Top Ln Ctrl Status1 Register
 */
union cavm_gsercx_lnx_top_ln_ctrl_status1
{
    uint32_t u;
    struct cavm_gsercx_lnx_top_ln_ctrl_status1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t tx_data_width         : 3;  /**< [  5:  3](RO/H) Width of TX data path
                                                                 1 = 10-bit
                                                                 2 = 16-bit
                                                                 3 = 20-bit
                                                                 4 = 32-bit
                                                                 5 = 40-bit */
        uint32_t tx_data_rate          : 3;  /**< [  2:  0](RO/H) Effective value of TX ln()_ctrl_data_rate. */
#else /* Word 0 - Little Endian */
        uint32_t tx_data_rate          : 3;  /**< [  2:  0](RO/H) Effective value of TX ln()_ctrl_data_rate. */
        uint32_t tx_data_width         : 3;  /**< [  5:  3](RO/H) Width of TX data path
                                                                 1 = 10-bit
                                                                 2 = 16-bit
                                                                 3 = 20-bit
                                                                 4 = 32-bit
                                                                 5 = 40-bit */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_top_ln_ctrl_status1_s cn; */
};
typedef union cavm_gsercx_lnx_top_ln_ctrl_status1 cavm_gsercx_lnx_top_ln_ctrl_status1_t;

static inline uint64_t CAVM_GSERCX_LNX_TOP_LN_CTRL_STATUS1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_TOP_LN_CTRL_STATUS1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8010238ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010238ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_TOP_LN_CTRL_STATUS1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_TOP_LN_CTRL_STATUS1(a,b) cavm_gsercx_lnx_top_ln_ctrl_status1_t
#define bustype_CAVM_GSERCX_LNX_TOP_LN_CTRL_STATUS1(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_TOP_LN_CTRL_STATUS1(a,b) "GSERCX_LNX_TOP_LN_CTRL_STATUS1"
#define device_bar_CAVM_GSERCX_LNX_TOP_LN_CTRL_STATUS1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_TOP_LN_CTRL_STATUS1(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_TOP_LN_CTRL_STATUS1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_ln_ctrl_status2
 *
 * GSERC Ln Top Ln Ctrl Status2 Register
 */
union cavm_gsercx_lnx_top_ln_ctrl_status2
{
    uint32_t u;
    struct cavm_gsercx_lnx_top_ln_ctrl_status2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t rx_data_width         : 3;  /**< [  5:  3](RO/H) Width of RX data path
                                                                 1 = 10-bit
                                                                 2 = 16-bit
                                                                 3 = 20-bit
                                                                 4 = 32-bit
                                                                 5 = 40-bit */
        uint32_t rx_data_rate          : 3;  /**< [  2:  0](RO/H) Effective value of RX ln()_ctrl_data_rate. */
#else /* Word 0 - Little Endian */
        uint32_t rx_data_rate          : 3;  /**< [  2:  0](RO/H) Effective value of RX ln()_ctrl_data_rate. */
        uint32_t rx_data_width         : 3;  /**< [  5:  3](RO/H) Width of RX data path
                                                                 1 = 10-bit
                                                                 2 = 16-bit
                                                                 3 = 20-bit
                                                                 4 = 32-bit
                                                                 5 = 40-bit */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_top_ln_ctrl_status2_s cn; */
};
typedef union cavm_gsercx_lnx_top_ln_ctrl_status2 cavm_gsercx_lnx_top_ln_ctrl_status2_t;

static inline uint64_t CAVM_GSERCX_LNX_TOP_LN_CTRL_STATUS2(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_TOP_LN_CTRL_STATUS2(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8010240ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010240ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_TOP_LN_CTRL_STATUS2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_TOP_LN_CTRL_STATUS2(a,b) cavm_gsercx_lnx_top_ln_ctrl_status2_t
#define bustype_CAVM_GSERCX_LNX_TOP_LN_CTRL_STATUS2(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_TOP_LN_CTRL_STATUS2(a,b) "GSERCX_LNX_TOP_LN_CTRL_STATUS2"
#define device_bar_CAVM_GSERCX_LNX_TOP_LN_CTRL_STATUS2(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_TOP_LN_CTRL_STATUS2(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_TOP_LN_CTRL_STATUS2(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_ln_ctrl_status3
 *
 * GSERC Ln Top Ln Ctrl Status3 Register
 */
union cavm_gsercx_lnx_top_ln_ctrl_status3
{
    uint32_t u;
    struct cavm_gsercx_lnx_top_ln_ctrl_status3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t eye_rxpolarity        : 1;  /**< [  1:  1](RO/H) Effective value of eye_rxpolarity for RX. */
        uint32_t edge_rxpolarity       : 1;  /**< [  0:  0](RO/H) Effective value of edge_rxpolarity for RX. */
#else /* Word 0 - Little Endian */
        uint32_t edge_rxpolarity       : 1;  /**< [  0:  0](RO/H) Effective value of edge_rxpolarity for RX. */
        uint32_t eye_rxpolarity        : 1;  /**< [  1:  1](RO/H) Effective value of eye_rxpolarity for RX. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_top_ln_ctrl_status3_s cn; */
};
typedef union cavm_gsercx_lnx_top_ln_ctrl_status3 cavm_gsercx_lnx_top_ln_ctrl_status3_t;

static inline uint64_t CAVM_GSERCX_LNX_TOP_LN_CTRL_STATUS3(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_TOP_LN_CTRL_STATUS3(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8010248ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010248ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_TOP_LN_CTRL_STATUS3", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_TOP_LN_CTRL_STATUS3(a,b) cavm_gsercx_lnx_top_ln_ctrl_status3_t
#define bustype_CAVM_GSERCX_LNX_TOP_LN_CTRL_STATUS3(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_TOP_LN_CTRL_STATUS3(a,b) "GSERCX_LNX_TOP_LN_CTRL_STATUS3"
#define device_bar_CAVM_GSERCX_LNX_TOP_LN_CTRL_STATUS3(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_TOP_LN_CTRL_STATUS3(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_TOP_LN_CTRL_STATUS3(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_ln_stat_ctrl0
 *
 * GSERC Ln Top Ln Stat Ctrl0 Register
 */
union cavm_gsercx_lnx_top_ln_stat_ctrl0
{
    uint32_t u;
    struct cavm_gsercx_lnx_top_ln_stat_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t rxvalid               : 1;  /**< [  0:  0](R/W/H) Rxvalid status output. */
#else /* Word 0 - Little Endian */
        uint32_t rxvalid               : 1;  /**< [  0:  0](R/W/H) Rxvalid status output. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_top_ln_stat_ctrl0_s cn; */
};
typedef union cavm_gsercx_lnx_top_ln_stat_ctrl0 cavm_gsercx_lnx_top_ln_stat_ctrl0_t;

static inline uint64_t CAVM_GSERCX_LNX_TOP_LN_STAT_CTRL0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_TOP_LN_STAT_CTRL0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a80101c0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80101c0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_TOP_LN_STAT_CTRL0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_TOP_LN_STAT_CTRL0(a,b) cavm_gsercx_lnx_top_ln_stat_ctrl0_t
#define bustype_CAVM_GSERCX_LNX_TOP_LN_STAT_CTRL0(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_TOP_LN_STAT_CTRL0(a,b) "GSERCX_LNX_TOP_LN_STAT_CTRL0"
#define device_bar_CAVM_GSERCX_LNX_TOP_LN_STAT_CTRL0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_TOP_LN_STAT_CTRL0(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_TOP_LN_STAT_CTRL0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_ln_stat_status0
 *
 * GSERC Ln Top Ln Stat Status0 Register
 */
union cavm_gsercx_lnx_top_ln_stat_status0
{
    uint32_t u;
    struct cavm_gsercx_lnx_top_ln_stat_status0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t state_chng_rdy        : 1;  /**< [  0:  0](RO/H) Value of ln()_state_chng_rdy_o.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
#else /* Word 0 - Little Endian */
        uint32_t state_chng_rdy        : 1;  /**< [  0:  0](RO/H) Value of ln()_state_chng_rdy_o.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_top_ln_stat_status0_s cn; */
};
typedef union cavm_gsercx_lnx_top_ln_stat_status0 cavm_gsercx_lnx_top_ln_stat_status0_t;

static inline uint64_t CAVM_GSERCX_LNX_TOP_LN_STAT_STATUS0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_TOP_LN_STAT_STATUS0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a80101d0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80101d0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_TOP_LN_STAT_STATUS0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_TOP_LN_STAT_STATUS0(a,b) cavm_gsercx_lnx_top_ln_stat_status0_t
#define bustype_CAVM_GSERCX_LNX_TOP_LN_STAT_STATUS0(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_TOP_LN_STAT_STATUS0(a,b) "GSERCX_LNX_TOP_LN_STAT_STATUS0"
#define device_bar_CAVM_GSERCX_LNX_TOP_LN_STAT_STATUS0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_TOP_LN_STAT_STATUS0(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_TOP_LN_STAT_STATUS0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_phy_if_ctrl_rsvd
 *
 * INTERNAL: GSERC Ln Top Phy If Ctrl Register
 */
union cavm_gsercx_lnx_top_phy_if_ctrl_rsvd
{
    uint32_t u;
    struct cavm_gsercx_lnx_top_phy_if_ctrl_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t ln_rx_rdy             : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t ln_tx_rdy             : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t ln_tx_rdy             : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t ln_rx_rdy             : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_lnx_top_phy_if_ctrl_rsvd_s cn; */
};
typedef union cavm_gsercx_lnx_top_phy_if_ctrl_rsvd cavm_gsercx_lnx_top_phy_if_ctrl_rsvd_t;

static inline uint64_t CAVM_GSERCX_LNX_TOP_PHY_IF_CTRL_RSVD(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_LNX_TOP_PHY_IF_CTRL_RSVD(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a8010150ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010150ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_LNX_TOP_PHY_IF_CTRL_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_LNX_TOP_PHY_IF_CTRL_RSVD(a,b) cavm_gsercx_lnx_top_phy_if_ctrl_rsvd_t
#define bustype_CAVM_GSERCX_LNX_TOP_PHY_IF_CTRL_RSVD(a,b) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_LNX_TOP_PHY_IF_CTRL_RSVD(a,b) "GSERCX_LNX_TOP_PHY_IF_CTRL_RSVD"
#define device_bar_CAVM_GSERCX_LNX_TOP_PHY_IF_CTRL_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_LNX_TOP_PHY_IF_CTRL_RSVD(a,b) (a)
#define arguments_CAVM_GSERCX_LNX_TOP_PHY_IF_CTRL_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxleq_eq_hfg_o_read_val_4_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxleq Eq Hfg O Read Val 4 0 Register
 */
union cavm_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_hfg_o_read_val_4_0_rsvd
{
    uint32_t u;
    struct cavm_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_hfg_o_read_val_4_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t data                  : 5;  /**< [  4:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 5;  /**< [  4:  0](RO/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_hfg_o_read_val_4_0_rsvd_s cn; */
};
typedef union cavm_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_hfg_o_read_val_4_0_rsvd cavm_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_hfg_o_read_val_4_0_rsvd_t;

static inline uint64_t CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_HFG_O_READ_VAL_4_0_RSVD(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_HFG_O_READ_VAL_4_0_RSVD(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8000590ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000590ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_HFG_O_READ_VAL_4_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_HFG_O_READ_VAL_4_0_RSVD(a) cavm_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_hfg_o_read_val_4_0_rsvd_t
#define bustype_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_HFG_O_READ_VAL_4_0_RSVD(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_HFG_O_READ_VAL_4_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_HFG_O_READ_VAL_4_0_RSVD"
#define device_bar_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_HFG_O_READ_VAL_4_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_HFG_O_READ_VAL_4_0_RSVD(a) (a)
#define arguments_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_HFG_O_READ_VAL_4_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxleq_eq_lfg_o_read_val_4_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxleq Eq Lfg O Read Val 4 0 Register
 */
union cavm_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_lfg_o_read_val_4_0_rsvd
{
    uint32_t u;
    struct cavm_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_lfg_o_read_val_4_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t data                  : 5;  /**< [  4:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 5;  /**< [  4:  0](RO/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_lfg_o_read_val_4_0_rsvd_s cn; */
};
typedef union cavm_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_lfg_o_read_val_4_0_rsvd cavm_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_lfg_o_read_val_4_0_rsvd_t;

static inline uint64_t CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_LFG_O_READ_VAL_4_0_RSVD(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_LFG_O_READ_VAL_4_0_RSVD(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a80005a8ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80005a8ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_LFG_O_READ_VAL_4_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_LFG_O_READ_VAL_4_0_RSVD(a) cavm_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_lfg_o_read_val_4_0_rsvd_t
#define bustype_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_LFG_O_READ_VAL_4_0_RSVD(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_LFG_O_READ_VAL_4_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_LFG_O_READ_VAL_4_0_RSVD"
#define device_bar_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_LFG_O_READ_VAL_4_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_LFG_O_READ_VAL_4_0_RSVD(a) (a)
#define arguments_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_LFG_O_READ_VAL_4_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxleq_eq_mbf_o_read_val_3_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxleq Eq Mbf O Read Val 3 0 Register
 */
union cavm_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_mbf_o_read_val_3_0_rsvd
{
    uint32_t u;
    struct cavm_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_mbf_o_read_val_3_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t data                  : 4;  /**< [  3:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 4;  /**< [  3:  0](RO/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_mbf_o_read_val_3_0_rsvd_s cn; */
};
typedef union cavm_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_mbf_o_read_val_3_0_rsvd cavm_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_mbf_o_read_val_3_0_rsvd_t;

static inline uint64_t CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBF_O_READ_VAL_3_0_RSVD(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBF_O_READ_VAL_3_0_RSVD(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a80005c0ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80005c0ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBF_O_READ_VAL_3_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBF_O_READ_VAL_3_0_RSVD(a) cavm_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_mbf_o_read_val_3_0_rsvd_t
#define bustype_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBF_O_READ_VAL_3_0_RSVD(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBF_O_READ_VAL_3_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBF_O_READ_VAL_3_0_RSVD"
#define device_bar_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBF_O_READ_VAL_3_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBF_O_READ_VAL_3_0_RSVD(a) (a)
#define arguments_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBF_O_READ_VAL_3_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxleq_eq_mbg_o_read_val_3_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxleq Eq Mbg O Read Val 3 0 Register
 */
union cavm_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_mbg_o_read_val_3_0_rsvd
{
    uint32_t u;
    struct cavm_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_mbg_o_read_val_3_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t data                  : 4;  /**< [  3:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 4;  /**< [  3:  0](RO/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_mbg_o_read_val_3_0_rsvd_s cn; */
};
typedef union cavm_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_mbg_o_read_val_3_0_rsvd cavm_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_mbg_o_read_val_3_0_rsvd_t;

static inline uint64_t CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBG_O_READ_VAL_3_0_RSVD(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBG_O_READ_VAL_3_0_RSVD(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a80005d8ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80005d8ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBG_O_READ_VAL_3_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBG_O_READ_VAL_3_0_RSVD(a) cavm_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_mbg_o_read_val_3_0_rsvd_t
#define bustype_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBG_O_READ_VAL_3_0_RSVD(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBG_O_READ_VAL_3_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBG_O_READ_VAL_3_0_RSVD"
#define device_bar_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBG_O_READ_VAL_3_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBG_O_READ_VAL_3_0_RSVD(a) (a)
#define arguments_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBG_O_READ_VAL_3_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxleq_eq_sql_o_read_val_2_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxleq Eq Sql O Read Val 2 0 Register
 */
union cavm_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_sql_o_read_val_2_0_rsvd
{
    uint32_t u;
    struct cavm_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_sql_o_read_val_2_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t data                  : 3;  /**< [  2:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 3;  /**< [  2:  0](RO/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_sql_o_read_val_2_0_rsvd_s cn; */
};
typedef union cavm_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_sql_o_read_val_2_0_rsvd cavm_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_sql_o_read_val_2_0_rsvd_t;

static inline uint64_t CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_SQL_O_READ_VAL_2_0_RSVD(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_SQL_O_READ_VAL_2_0_RSVD(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a80005f0ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80005f0ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_SQL_O_READ_VAL_2_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_SQL_O_READ_VAL_2_0_RSVD(a) cavm_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_sql_o_read_val_2_0_rsvd_t
#define bustype_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_SQL_O_READ_VAL_2_0_RSVD(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_SQL_O_READ_VAL_2_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_SQL_O_READ_VAL_2_0_RSVD"
#define device_bar_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_SQL_O_READ_VAL_2_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_SQL_O_READ_VAL_2_0_RSVD(a) (a)
#define arguments_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_SQL_O_READ_VAL_2_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxleq_gn_apg_o_read_val_2_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxleq Gn Apg O Read Val 2 0 Register
 */
union cavm_gsercx_phy0_afe_ovr_afe_ln0_rxleq_gn_apg_o_read_val_2_0_rsvd
{
    uint32_t u;
    struct cavm_gsercx_phy0_afe_ovr_afe_ln0_rxleq_gn_apg_o_read_val_2_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t data                  : 3;  /**< [  2:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 3;  /**< [  2:  0](RO/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_afe_ovr_afe_ln0_rxleq_gn_apg_o_read_val_2_0_rsvd_s cn; */
};
typedef union cavm_gsercx_phy0_afe_ovr_afe_ln0_rxleq_gn_apg_o_read_val_2_0_rsvd cavm_gsercx_phy0_afe_ovr_afe_ln0_rxleq_gn_apg_o_read_val_2_0_rsvd_t;

static inline uint64_t CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_GN_APG_O_READ_VAL_2_0_RSVD(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_GN_APG_O_READ_VAL_2_0_RSVD(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8000608ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000608ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_GN_APG_O_READ_VAL_2_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_GN_APG_O_READ_VAL_2_0_RSVD(a) cavm_gsercx_phy0_afe_ovr_afe_ln0_rxleq_gn_apg_o_read_val_2_0_rsvd_t
#define bustype_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_GN_APG_O_READ_VAL_2_0_RSVD(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_GN_APG_O_READ_VAL_2_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_GN_APG_O_READ_VAL_2_0_RSVD"
#define device_bar_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_GN_APG_O_READ_VAL_2_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_GN_APG_O_READ_VAL_2_0_RSVD(a) (a)
#define arguments_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_GN_APG_O_READ_VAL_2_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxleq_ple_att_o_read_val_2_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxleq Ple Att O Read Val 2 0 Register
 */
union cavm_gsercx_phy0_afe_ovr_afe_ln0_rxleq_ple_att_o_read_val_2_0_rsvd
{
    uint32_t u;
    struct cavm_gsercx_phy0_afe_ovr_afe_ln0_rxleq_ple_att_o_read_val_2_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t data                  : 3;  /**< [  2:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 3;  /**< [  2:  0](RO/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_afe_ovr_afe_ln0_rxleq_ple_att_o_read_val_2_0_rsvd_s cn; */
};
typedef union cavm_gsercx_phy0_afe_ovr_afe_ln0_rxleq_ple_att_o_read_val_2_0_rsvd cavm_gsercx_phy0_afe_ovr_afe_ln0_rxleq_ple_att_o_read_val_2_0_rsvd_t;

static inline uint64_t CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_PLE_ATT_O_READ_VAL_2_0_RSVD(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_PLE_ATT_O_READ_VAL_2_0_RSVD(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8000698ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000698ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_PLE_ATT_O_READ_VAL_2_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_PLE_ATT_O_READ_VAL_2_0_RSVD(a) cavm_gsercx_phy0_afe_ovr_afe_ln0_rxleq_ple_att_o_read_val_2_0_rsvd_t
#define bustype_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_PLE_ATT_O_READ_VAL_2_0_RSVD(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_PLE_ATT_O_READ_VAL_2_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_PLE_ATT_O_READ_VAL_2_0_RSVD"
#define device_bar_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_PLE_ATT_O_READ_VAL_2_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_PLE_ATT_O_READ_VAL_2_0_RSVD(a) (a)
#define arguments_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_PLE_ATT_O_READ_VAL_2_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxleq_eq_hfg_o_read_val_4_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxleq Eq Hfg O Read Val 4 0 Register
 */
union cavm_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_hfg_o_read_val_4_0_rsvd
{
    uint32_t u;
    struct cavm_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_hfg_o_read_val_4_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t data                  : 5;  /**< [  4:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 5;  /**< [  4:  0](RO/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_hfg_o_read_val_4_0_rsvd_s cn; */
};
typedef union cavm_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_hfg_o_read_val_4_0_rsvd cavm_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_hfg_o_read_val_4_0_rsvd_t;

static inline uint64_t CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_HFG_O_READ_VAL_4_0_RSVD(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_HFG_O_READ_VAL_4_0_RSVD(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8000ab0ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000ab0ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_HFG_O_READ_VAL_4_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_HFG_O_READ_VAL_4_0_RSVD(a) cavm_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_hfg_o_read_val_4_0_rsvd_t
#define bustype_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_HFG_O_READ_VAL_4_0_RSVD(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_HFG_O_READ_VAL_4_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_HFG_O_READ_VAL_4_0_RSVD"
#define device_bar_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_HFG_O_READ_VAL_4_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_HFG_O_READ_VAL_4_0_RSVD(a) (a)
#define arguments_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_HFG_O_READ_VAL_4_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxleq_eq_lfg_o_read_val_4_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxleq Eq Lfg O Read Val 4 0 Register
 */
union cavm_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_lfg_o_read_val_4_0_rsvd
{
    uint32_t u;
    struct cavm_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_lfg_o_read_val_4_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t data                  : 5;  /**< [  4:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 5;  /**< [  4:  0](RO/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_lfg_o_read_val_4_0_rsvd_s cn; */
};
typedef union cavm_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_lfg_o_read_val_4_0_rsvd cavm_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_lfg_o_read_val_4_0_rsvd_t;

static inline uint64_t CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_LFG_O_READ_VAL_4_0_RSVD(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_LFG_O_READ_VAL_4_0_RSVD(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8000ac8ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000ac8ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_LFG_O_READ_VAL_4_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_LFG_O_READ_VAL_4_0_RSVD(a) cavm_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_lfg_o_read_val_4_0_rsvd_t
#define bustype_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_LFG_O_READ_VAL_4_0_RSVD(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_LFG_O_READ_VAL_4_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_LFG_O_READ_VAL_4_0_RSVD"
#define device_bar_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_LFG_O_READ_VAL_4_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_LFG_O_READ_VAL_4_0_RSVD(a) (a)
#define arguments_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_LFG_O_READ_VAL_4_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxleq_eq_mbf_o_read_val_3_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxleq Eq Mbf O Read Val 3 0 Register
 */
union cavm_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_mbf_o_read_val_3_0_rsvd
{
    uint32_t u;
    struct cavm_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_mbf_o_read_val_3_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t data                  : 4;  /**< [  3:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 4;  /**< [  3:  0](RO/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_mbf_o_read_val_3_0_rsvd_s cn; */
};
typedef union cavm_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_mbf_o_read_val_3_0_rsvd cavm_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_mbf_o_read_val_3_0_rsvd_t;

static inline uint64_t CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBF_O_READ_VAL_3_0_RSVD(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBF_O_READ_VAL_3_0_RSVD(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8000ae0ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000ae0ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBF_O_READ_VAL_3_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBF_O_READ_VAL_3_0_RSVD(a) cavm_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_mbf_o_read_val_3_0_rsvd_t
#define bustype_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBF_O_READ_VAL_3_0_RSVD(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBF_O_READ_VAL_3_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBF_O_READ_VAL_3_0_RSVD"
#define device_bar_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBF_O_READ_VAL_3_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBF_O_READ_VAL_3_0_RSVD(a) (a)
#define arguments_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBF_O_READ_VAL_3_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxleq_eq_mbg_o_read_val_3_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxleq Eq Mbg O Read Val 3 0 Register
 */
union cavm_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_mbg_o_read_val_3_0_rsvd
{
    uint32_t u;
    struct cavm_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_mbg_o_read_val_3_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t data                  : 4;  /**< [  3:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 4;  /**< [  3:  0](RO/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_mbg_o_read_val_3_0_rsvd_s cn; */
};
typedef union cavm_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_mbg_o_read_val_3_0_rsvd cavm_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_mbg_o_read_val_3_0_rsvd_t;

static inline uint64_t CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBG_O_READ_VAL_3_0_RSVD(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBG_O_READ_VAL_3_0_RSVD(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8000af8ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000af8ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBG_O_READ_VAL_3_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBG_O_READ_VAL_3_0_RSVD(a) cavm_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_mbg_o_read_val_3_0_rsvd_t
#define bustype_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBG_O_READ_VAL_3_0_RSVD(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBG_O_READ_VAL_3_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBG_O_READ_VAL_3_0_RSVD"
#define device_bar_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBG_O_READ_VAL_3_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBG_O_READ_VAL_3_0_RSVD(a) (a)
#define arguments_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBG_O_READ_VAL_3_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxleq_eq_sql_o_read_val_2_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxleq Eq Sql O Read Val 2 0 Register
 */
union cavm_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_sql_o_read_val_2_0_rsvd
{
    uint32_t u;
    struct cavm_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_sql_o_read_val_2_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t data                  : 3;  /**< [  2:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 3;  /**< [  2:  0](RO/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_sql_o_read_val_2_0_rsvd_s cn; */
};
typedef union cavm_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_sql_o_read_val_2_0_rsvd cavm_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_sql_o_read_val_2_0_rsvd_t;

static inline uint64_t CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_SQL_O_READ_VAL_2_0_RSVD(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_SQL_O_READ_VAL_2_0_RSVD(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8000b10ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000b10ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_SQL_O_READ_VAL_2_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_SQL_O_READ_VAL_2_0_RSVD(a) cavm_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_sql_o_read_val_2_0_rsvd_t
#define bustype_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_SQL_O_READ_VAL_2_0_RSVD(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_SQL_O_READ_VAL_2_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_SQL_O_READ_VAL_2_0_RSVD"
#define device_bar_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_SQL_O_READ_VAL_2_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_SQL_O_READ_VAL_2_0_RSVD(a) (a)
#define arguments_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_SQL_O_READ_VAL_2_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxleq_gn_apg_o_read_val_2_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxleq Gn Apg O Read Val 2 0 Register
 */
union cavm_gsercx_phy0_afe_ovr_afe_ln1_rxleq_gn_apg_o_read_val_2_0_rsvd
{
    uint32_t u;
    struct cavm_gsercx_phy0_afe_ovr_afe_ln1_rxleq_gn_apg_o_read_val_2_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t data                  : 3;  /**< [  2:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 3;  /**< [  2:  0](RO/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_afe_ovr_afe_ln1_rxleq_gn_apg_o_read_val_2_0_rsvd_s cn; */
};
typedef union cavm_gsercx_phy0_afe_ovr_afe_ln1_rxleq_gn_apg_o_read_val_2_0_rsvd cavm_gsercx_phy0_afe_ovr_afe_ln1_rxleq_gn_apg_o_read_val_2_0_rsvd_t;

static inline uint64_t CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_GN_APG_O_READ_VAL_2_0_RSVD(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_GN_APG_O_READ_VAL_2_0_RSVD(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8000b28ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000b28ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_GN_APG_O_READ_VAL_2_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_GN_APG_O_READ_VAL_2_0_RSVD(a) cavm_gsercx_phy0_afe_ovr_afe_ln1_rxleq_gn_apg_o_read_val_2_0_rsvd_t
#define bustype_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_GN_APG_O_READ_VAL_2_0_RSVD(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_GN_APG_O_READ_VAL_2_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_GN_APG_O_READ_VAL_2_0_RSVD"
#define device_bar_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_GN_APG_O_READ_VAL_2_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_GN_APG_O_READ_VAL_2_0_RSVD(a) (a)
#define arguments_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_GN_APG_O_READ_VAL_2_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxleq_ple_att_o_read_val_2_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxleq Ple Att O Read Val 2 0 Register
 */
union cavm_gsercx_phy0_afe_ovr_afe_ln1_rxleq_ple_att_o_read_val_2_0_rsvd
{
    uint32_t u;
    struct cavm_gsercx_phy0_afe_ovr_afe_ln1_rxleq_ple_att_o_read_val_2_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t data                  : 3;  /**< [  2:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 3;  /**< [  2:  0](RO/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_afe_ovr_afe_ln1_rxleq_ple_att_o_read_val_2_0_rsvd_s cn; */
};
typedef union cavm_gsercx_phy0_afe_ovr_afe_ln1_rxleq_ple_att_o_read_val_2_0_rsvd cavm_gsercx_phy0_afe_ovr_afe_ln1_rxleq_ple_att_o_read_val_2_0_rsvd_t;

static inline uint64_t CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_PLE_ATT_O_READ_VAL_2_0_RSVD(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_PLE_ATT_O_READ_VAL_2_0_RSVD(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8000bb8ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000bb8ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_PLE_ATT_O_READ_VAL_2_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_PLE_ATT_O_READ_VAL_2_0_RSVD(a) cavm_gsercx_phy0_afe_ovr_afe_ln1_rxleq_ple_att_o_read_val_2_0_rsvd_t
#define bustype_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_PLE_ATT_O_READ_VAL_2_0_RSVD(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_PLE_ATT_O_READ_VAL_2_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_PLE_ATT_O_READ_VAL_2_0_RSVD"
#define device_bar_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_PLE_ATT_O_READ_VAL_2_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_PLE_ATT_O_READ_VAL_2_0_RSVD(a) (a)
#define arguments_CAVM_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_PLE_ATT_O_READ_VAL_2_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_mb_cmd
 *
 * GSERC Phy0 Mb Cmd Register
 */
union cavm_gsercx_phy0_mb_cmd
{
    uint32_t u;
    struct cavm_gsercx_phy0_mb_cmd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Command to the PHY firmware.
                                                                 It is expected that only the APB master writes to the command register.
                                                                 Upon a write to this register, CMD_FLAG is set automatically. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Command to the PHY firmware.
                                                                 It is expected that only the APB master writes to the command register.
                                                                 Upon a write to this register, CMD_FLAG is set automatically. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_mb_cmd_s cn; */
};
typedef union cavm_gsercx_phy0_mb_cmd cavm_gsercx_phy0_mb_cmd_t;

static inline uint64_t CAVM_GSERCX_PHY0_MB_CMD(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_MB_CMD(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8003800ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8003800ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_MB_CMD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_MB_CMD(a) cavm_gsercx_phy0_mb_cmd_t
#define bustype_CAVM_GSERCX_PHY0_MB_CMD(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_MB_CMD(a) "GSERCX_PHY0_MB_CMD"
#define device_bar_CAVM_GSERCX_PHY0_MB_CMD(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_MB_CMD(a) (a)
#define arguments_CAVM_GSERCX_PHY0_MB_CMD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_mb_cmd_data0
 *
 * GSERC Phy0 Mb Cmd Data0 Register
 */
union cavm_gsercx_phy0_mb_cmd_data0
{
    uint32_t u;
    struct cavm_gsercx_phy0_mb_cmd_data0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Command auxiliary data or argument 0. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Command auxiliary data or argument 0. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_mb_cmd_data0_s cn; */
};
typedef union cavm_gsercx_phy0_mb_cmd_data0 cavm_gsercx_phy0_mb_cmd_data0_t;

static inline uint64_t CAVM_GSERCX_PHY0_MB_CMD_DATA0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_MB_CMD_DATA0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8003818ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8003818ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_MB_CMD_DATA0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_MB_CMD_DATA0(a) cavm_gsercx_phy0_mb_cmd_data0_t
#define bustype_CAVM_GSERCX_PHY0_MB_CMD_DATA0(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_MB_CMD_DATA0(a) "GSERCX_PHY0_MB_CMD_DATA0"
#define device_bar_CAVM_GSERCX_PHY0_MB_CMD_DATA0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_MB_CMD_DATA0(a) (a)
#define arguments_CAVM_GSERCX_PHY0_MB_CMD_DATA0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_mb_cmd_data1
 *
 * GSERC Phy0 Mb Cmd Data1 Register
 */
union cavm_gsercx_phy0_mb_cmd_data1
{
    uint32_t u;
    struct cavm_gsercx_phy0_mb_cmd_data1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Command auxiliary data or argument 1. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Command auxiliary data or argument 1. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_mb_cmd_data1_s cn; */
};
typedef union cavm_gsercx_phy0_mb_cmd_data1 cavm_gsercx_phy0_mb_cmd_data1_t;

static inline uint64_t CAVM_GSERCX_PHY0_MB_CMD_DATA1(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_MB_CMD_DATA1(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8003820ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8003820ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_MB_CMD_DATA1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_MB_CMD_DATA1(a) cavm_gsercx_phy0_mb_cmd_data1_t
#define bustype_CAVM_GSERCX_PHY0_MB_CMD_DATA1(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_MB_CMD_DATA1(a) "GSERCX_PHY0_MB_CMD_DATA1"
#define device_bar_CAVM_GSERCX_PHY0_MB_CMD_DATA1(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_MB_CMD_DATA1(a) (a)
#define arguments_CAVM_GSERCX_PHY0_MB_CMD_DATA1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_mb_cmd_data2
 *
 * GSERC Phy0 Mb Cmd Data2 Register
 */
union cavm_gsercx_phy0_mb_cmd_data2
{
    uint32_t u;
    struct cavm_gsercx_phy0_mb_cmd_data2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Command auxiliary data or argument 2. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Command auxiliary data or argument 2. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_mb_cmd_data2_s cn; */
};
typedef union cavm_gsercx_phy0_mb_cmd_data2 cavm_gsercx_phy0_mb_cmd_data2_t;

static inline uint64_t CAVM_GSERCX_PHY0_MB_CMD_DATA2(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_MB_CMD_DATA2(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8003828ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8003828ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_MB_CMD_DATA2", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_MB_CMD_DATA2(a) cavm_gsercx_phy0_mb_cmd_data2_t
#define bustype_CAVM_GSERCX_PHY0_MB_CMD_DATA2(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_MB_CMD_DATA2(a) "GSERCX_PHY0_MB_CMD_DATA2"
#define device_bar_CAVM_GSERCX_PHY0_MB_CMD_DATA2(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_MB_CMD_DATA2(a) (a)
#define arguments_CAVM_GSERCX_PHY0_MB_CMD_DATA2(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_mb_cmd_data3
 *
 * GSERC Phy0 Mb Cmd Data3 Register
 */
union cavm_gsercx_phy0_mb_cmd_data3
{
    uint32_t u;
    struct cavm_gsercx_phy0_mb_cmd_data3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Command auxiliary data or argument 3. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Command auxiliary data or argument 3. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_mb_cmd_data3_s cn; */
};
typedef union cavm_gsercx_phy0_mb_cmd_data3 cavm_gsercx_phy0_mb_cmd_data3_t;

static inline uint64_t CAVM_GSERCX_PHY0_MB_CMD_DATA3(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_MB_CMD_DATA3(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8003830ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8003830ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_MB_CMD_DATA3", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_MB_CMD_DATA3(a) cavm_gsercx_phy0_mb_cmd_data3_t
#define bustype_CAVM_GSERCX_PHY0_MB_CMD_DATA3(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_MB_CMD_DATA3(a) "GSERCX_PHY0_MB_CMD_DATA3"
#define device_bar_CAVM_GSERCX_PHY0_MB_CMD_DATA3(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_MB_CMD_DATA3(a) (a)
#define arguments_CAVM_GSERCX_PHY0_MB_CMD_DATA3(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_mb_cmd_data4
 *
 * GSERC Phy0 Mb Cmd Data4 Register
 */
union cavm_gsercx_phy0_mb_cmd_data4
{
    uint32_t u;
    struct cavm_gsercx_phy0_mb_cmd_data4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Command auxiliary data or argument 4. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Command auxiliary data or argument 4. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_mb_cmd_data4_s cn; */
};
typedef union cavm_gsercx_phy0_mb_cmd_data4 cavm_gsercx_phy0_mb_cmd_data4_t;

static inline uint64_t CAVM_GSERCX_PHY0_MB_CMD_DATA4(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_MB_CMD_DATA4(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8003838ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8003838ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_MB_CMD_DATA4", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_MB_CMD_DATA4(a) cavm_gsercx_phy0_mb_cmd_data4_t
#define bustype_CAVM_GSERCX_PHY0_MB_CMD_DATA4(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_MB_CMD_DATA4(a) "GSERCX_PHY0_MB_CMD_DATA4"
#define device_bar_CAVM_GSERCX_PHY0_MB_CMD_DATA4(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_MB_CMD_DATA4(a) (a)
#define arguments_CAVM_GSERCX_PHY0_MB_CMD_DATA4(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_mb_cmd_data5
 *
 * GSERC Phy0 Mb Cmd Data5 Register
 */
union cavm_gsercx_phy0_mb_cmd_data5
{
    uint32_t u;
    struct cavm_gsercx_phy0_mb_cmd_data5_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Command auxiliary data or argument 5. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Command auxiliary data or argument 5. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_mb_cmd_data5_s cn; */
};
typedef union cavm_gsercx_phy0_mb_cmd_data5 cavm_gsercx_phy0_mb_cmd_data5_t;

static inline uint64_t CAVM_GSERCX_PHY0_MB_CMD_DATA5(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_MB_CMD_DATA5(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8003840ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8003840ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_MB_CMD_DATA5", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_MB_CMD_DATA5(a) cavm_gsercx_phy0_mb_cmd_data5_t
#define bustype_CAVM_GSERCX_PHY0_MB_CMD_DATA5(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_MB_CMD_DATA5(a) "GSERCX_PHY0_MB_CMD_DATA5"
#define device_bar_CAVM_GSERCX_PHY0_MB_CMD_DATA5(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_MB_CMD_DATA5(a) (a)
#define arguments_CAVM_GSERCX_PHY0_MB_CMD_DATA5(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_mb_cmd_data6
 *
 * GSERC Phy0 Mb Cmd Data6 Register
 */
union cavm_gsercx_phy0_mb_cmd_data6
{
    uint32_t u;
    struct cavm_gsercx_phy0_mb_cmd_data6_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Command auxiliary data or argument 6. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Command auxiliary data or argument 6. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_mb_cmd_data6_s cn; */
};
typedef union cavm_gsercx_phy0_mb_cmd_data6 cavm_gsercx_phy0_mb_cmd_data6_t;

static inline uint64_t CAVM_GSERCX_PHY0_MB_CMD_DATA6(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_MB_CMD_DATA6(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8003848ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8003848ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_MB_CMD_DATA6", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_MB_CMD_DATA6(a) cavm_gsercx_phy0_mb_cmd_data6_t
#define bustype_CAVM_GSERCX_PHY0_MB_CMD_DATA6(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_MB_CMD_DATA6(a) "GSERCX_PHY0_MB_CMD_DATA6"
#define device_bar_CAVM_GSERCX_PHY0_MB_CMD_DATA6(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_MB_CMD_DATA6(a) (a)
#define arguments_CAVM_GSERCX_PHY0_MB_CMD_DATA6(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_mb_cmd_data7
 *
 * GSERC Phy0 Mb Cmd Data7 Register
 */
union cavm_gsercx_phy0_mb_cmd_data7
{
    uint32_t u;
    struct cavm_gsercx_phy0_mb_cmd_data7_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Command auxiliary data or argument 7. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Command auxiliary data or argument 7. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_mb_cmd_data7_s cn; */
};
typedef union cavm_gsercx_phy0_mb_cmd_data7 cavm_gsercx_phy0_mb_cmd_data7_t;

static inline uint64_t CAVM_GSERCX_PHY0_MB_CMD_DATA7(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_MB_CMD_DATA7(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8003850ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8003850ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_MB_CMD_DATA7", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_MB_CMD_DATA7(a) cavm_gsercx_phy0_mb_cmd_data7_t
#define bustype_CAVM_GSERCX_PHY0_MB_CMD_DATA7(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_MB_CMD_DATA7(a) "GSERCX_PHY0_MB_CMD_DATA7"
#define device_bar_CAVM_GSERCX_PHY0_MB_CMD_DATA7(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_MB_CMD_DATA7(a) (a)
#define arguments_CAVM_GSERCX_PHY0_MB_CMD_DATA7(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_mb_cmd_flag
 *
 * GSERC Phy0 Mb Cmd Flag Register
 */
union cavm_gsercx_phy0_mb_cmd_flag
{
    uint32_t u;
    struct cavm_gsercx_phy0_mb_cmd_flag_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W1C/H) Indicates the presence of a new command to the PHY firmware.
                                                                 It is set automatically when CMD is written.
                                                                 It is expected to be cleared by the PHY firmware by writing 1 to it. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W1C/H) Indicates the presence of a new command to the PHY firmware.
                                                                 It is set automatically when CMD is written.
                                                                 It is expected to be cleared by the PHY firmware by writing 1 to it. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_mb_cmd_flag_s cn; */
};
typedef union cavm_gsercx_phy0_mb_cmd_flag cavm_gsercx_phy0_mb_cmd_flag_t;

static inline uint64_t CAVM_GSERCX_PHY0_MB_CMD_FLAG(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_MB_CMD_FLAG(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8003810ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8003810ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_MB_CMD_FLAG", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_MB_CMD_FLAG(a) cavm_gsercx_phy0_mb_cmd_flag_t
#define bustype_CAVM_GSERCX_PHY0_MB_CMD_FLAG(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_MB_CMD_FLAG(a) "GSERCX_PHY0_MB_CMD_FLAG"
#define device_bar_CAVM_GSERCX_PHY0_MB_CMD_FLAG(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_MB_CMD_FLAG(a) (a)
#define arguments_CAVM_GSERCX_PHY0_MB_CMD_FLAG(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_mb_rsp
 *
 * GSERC Phy0 Mb Rsp Register
 */
union cavm_gsercx_phy0_mb_rsp
{
    uint32_t u;
    struct cavm_gsercx_phy0_mb_rsp_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response from the PHY firmware.
                                                                 It is expected that only the firmware writes to the Response register.
                                                                 Upon a write to this register, RSP_FLAG is set automatically. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response from the PHY firmware.
                                                                 It is expected that only the firmware writes to the Response register.
                                                                 Upon a write to this register, RSP_FLAG is set automatically. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_mb_rsp_s cn; */
};
typedef union cavm_gsercx_phy0_mb_rsp cavm_gsercx_phy0_mb_rsp_t;

static inline uint64_t CAVM_GSERCX_PHY0_MB_RSP(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_MB_RSP(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8003880ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8003880ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_MB_RSP", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_MB_RSP(a) cavm_gsercx_phy0_mb_rsp_t
#define bustype_CAVM_GSERCX_PHY0_MB_RSP(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_MB_RSP(a) "GSERCX_PHY0_MB_RSP"
#define device_bar_CAVM_GSERCX_PHY0_MB_RSP(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_MB_RSP(a) (a)
#define arguments_CAVM_GSERCX_PHY0_MB_RSP(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_mb_rsp_data0
 *
 * GSERC Phy0 Mb Rsp Data0 Register
 */
union cavm_gsercx_phy0_mb_rsp_data0
{
    uint32_t u;
    struct cavm_gsercx_phy0_mb_rsp_data0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response auxiliary data or argument 0. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response auxiliary data or argument 0. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_mb_rsp_data0_s cn; */
};
typedef union cavm_gsercx_phy0_mb_rsp_data0 cavm_gsercx_phy0_mb_rsp_data0_t;

static inline uint64_t CAVM_GSERCX_PHY0_MB_RSP_DATA0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_MB_RSP_DATA0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8003898ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8003898ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_MB_RSP_DATA0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_MB_RSP_DATA0(a) cavm_gsercx_phy0_mb_rsp_data0_t
#define bustype_CAVM_GSERCX_PHY0_MB_RSP_DATA0(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_MB_RSP_DATA0(a) "GSERCX_PHY0_MB_RSP_DATA0"
#define device_bar_CAVM_GSERCX_PHY0_MB_RSP_DATA0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_MB_RSP_DATA0(a) (a)
#define arguments_CAVM_GSERCX_PHY0_MB_RSP_DATA0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_mb_rsp_data1
 *
 * GSERC Phy0 Mb Rsp Data1 Register
 */
union cavm_gsercx_phy0_mb_rsp_data1
{
    uint32_t u;
    struct cavm_gsercx_phy0_mb_rsp_data1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response auxiliary data or argument 1. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response auxiliary data or argument 1. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_mb_rsp_data1_s cn; */
};
typedef union cavm_gsercx_phy0_mb_rsp_data1 cavm_gsercx_phy0_mb_rsp_data1_t;

static inline uint64_t CAVM_GSERCX_PHY0_MB_RSP_DATA1(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_MB_RSP_DATA1(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a80038a0ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80038a0ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_MB_RSP_DATA1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_MB_RSP_DATA1(a) cavm_gsercx_phy0_mb_rsp_data1_t
#define bustype_CAVM_GSERCX_PHY0_MB_RSP_DATA1(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_MB_RSP_DATA1(a) "GSERCX_PHY0_MB_RSP_DATA1"
#define device_bar_CAVM_GSERCX_PHY0_MB_RSP_DATA1(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_MB_RSP_DATA1(a) (a)
#define arguments_CAVM_GSERCX_PHY0_MB_RSP_DATA1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_mb_rsp_data10
 *
 * GSERC Phy0 Mb Rsp Data10 Register
 */
union cavm_gsercx_phy0_mb_rsp_data10
{
    uint32_t u;
    struct cavm_gsercx_phy0_mb_rsp_data10_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response auxiliary data or argument 10. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response auxiliary data or argument 10. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_mb_rsp_data10_s cn; */
};
typedef union cavm_gsercx_phy0_mb_rsp_data10 cavm_gsercx_phy0_mb_rsp_data10_t;

static inline uint64_t CAVM_GSERCX_PHY0_MB_RSP_DATA10(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_MB_RSP_DATA10(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a80038e8ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80038e8ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_MB_RSP_DATA10", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_MB_RSP_DATA10(a) cavm_gsercx_phy0_mb_rsp_data10_t
#define bustype_CAVM_GSERCX_PHY0_MB_RSP_DATA10(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_MB_RSP_DATA10(a) "GSERCX_PHY0_MB_RSP_DATA10"
#define device_bar_CAVM_GSERCX_PHY0_MB_RSP_DATA10(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_MB_RSP_DATA10(a) (a)
#define arguments_CAVM_GSERCX_PHY0_MB_RSP_DATA10(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_mb_rsp_data11
 *
 * GSERC Phy0 Mb Rsp Data11 Register
 */
union cavm_gsercx_phy0_mb_rsp_data11
{
    uint32_t u;
    struct cavm_gsercx_phy0_mb_rsp_data11_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response auxiliary data or argument 11. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response auxiliary data or argument 11. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_mb_rsp_data11_s cn; */
};
typedef union cavm_gsercx_phy0_mb_rsp_data11 cavm_gsercx_phy0_mb_rsp_data11_t;

static inline uint64_t CAVM_GSERCX_PHY0_MB_RSP_DATA11(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_MB_RSP_DATA11(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a80038f0ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80038f0ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_MB_RSP_DATA11", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_MB_RSP_DATA11(a) cavm_gsercx_phy0_mb_rsp_data11_t
#define bustype_CAVM_GSERCX_PHY0_MB_RSP_DATA11(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_MB_RSP_DATA11(a) "GSERCX_PHY0_MB_RSP_DATA11"
#define device_bar_CAVM_GSERCX_PHY0_MB_RSP_DATA11(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_MB_RSP_DATA11(a) (a)
#define arguments_CAVM_GSERCX_PHY0_MB_RSP_DATA11(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_mb_rsp_data12
 *
 * GSERC Phy0 Mb Rsp Data12 Register
 */
union cavm_gsercx_phy0_mb_rsp_data12
{
    uint32_t u;
    struct cavm_gsercx_phy0_mb_rsp_data12_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response auxiliary data or argument 12. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response auxiliary data or argument 12. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_mb_rsp_data12_s cn; */
};
typedef union cavm_gsercx_phy0_mb_rsp_data12 cavm_gsercx_phy0_mb_rsp_data12_t;

static inline uint64_t CAVM_GSERCX_PHY0_MB_RSP_DATA12(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_MB_RSP_DATA12(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a80038f8ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80038f8ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_MB_RSP_DATA12", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_MB_RSP_DATA12(a) cavm_gsercx_phy0_mb_rsp_data12_t
#define bustype_CAVM_GSERCX_PHY0_MB_RSP_DATA12(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_MB_RSP_DATA12(a) "GSERCX_PHY0_MB_RSP_DATA12"
#define device_bar_CAVM_GSERCX_PHY0_MB_RSP_DATA12(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_MB_RSP_DATA12(a) (a)
#define arguments_CAVM_GSERCX_PHY0_MB_RSP_DATA12(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_mb_rsp_data13
 *
 * GSERC Phy0 Mb Rsp Data13 Register
 */
union cavm_gsercx_phy0_mb_rsp_data13
{
    uint32_t u;
    struct cavm_gsercx_phy0_mb_rsp_data13_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response auxiliary data or argument 13. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response auxiliary data or argument 13. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_mb_rsp_data13_s cn; */
};
typedef union cavm_gsercx_phy0_mb_rsp_data13 cavm_gsercx_phy0_mb_rsp_data13_t;

static inline uint64_t CAVM_GSERCX_PHY0_MB_RSP_DATA13(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_MB_RSP_DATA13(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8003900ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8003900ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_MB_RSP_DATA13", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_MB_RSP_DATA13(a) cavm_gsercx_phy0_mb_rsp_data13_t
#define bustype_CAVM_GSERCX_PHY0_MB_RSP_DATA13(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_MB_RSP_DATA13(a) "GSERCX_PHY0_MB_RSP_DATA13"
#define device_bar_CAVM_GSERCX_PHY0_MB_RSP_DATA13(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_MB_RSP_DATA13(a) (a)
#define arguments_CAVM_GSERCX_PHY0_MB_RSP_DATA13(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_mb_rsp_data14
 *
 * GSERC Phy0 Mb Rsp Data14 Register
 */
union cavm_gsercx_phy0_mb_rsp_data14
{
    uint32_t u;
    struct cavm_gsercx_phy0_mb_rsp_data14_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response auxiliary data or argument 14. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response auxiliary data or argument 14. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_mb_rsp_data14_s cn; */
};
typedef union cavm_gsercx_phy0_mb_rsp_data14 cavm_gsercx_phy0_mb_rsp_data14_t;

static inline uint64_t CAVM_GSERCX_PHY0_MB_RSP_DATA14(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_MB_RSP_DATA14(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8003908ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8003908ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_MB_RSP_DATA14", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_MB_RSP_DATA14(a) cavm_gsercx_phy0_mb_rsp_data14_t
#define bustype_CAVM_GSERCX_PHY0_MB_RSP_DATA14(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_MB_RSP_DATA14(a) "GSERCX_PHY0_MB_RSP_DATA14"
#define device_bar_CAVM_GSERCX_PHY0_MB_RSP_DATA14(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_MB_RSP_DATA14(a) (a)
#define arguments_CAVM_GSERCX_PHY0_MB_RSP_DATA14(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_mb_rsp_data15
 *
 * GSERC Phy0 Mb Rsp Data15 Register
 */
union cavm_gsercx_phy0_mb_rsp_data15
{
    uint32_t u;
    struct cavm_gsercx_phy0_mb_rsp_data15_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response auxiliary data or argument 15. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response auxiliary data or argument 15. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_mb_rsp_data15_s cn; */
};
typedef union cavm_gsercx_phy0_mb_rsp_data15 cavm_gsercx_phy0_mb_rsp_data15_t;

static inline uint64_t CAVM_GSERCX_PHY0_MB_RSP_DATA15(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_MB_RSP_DATA15(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8003910ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8003910ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_MB_RSP_DATA15", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_MB_RSP_DATA15(a) cavm_gsercx_phy0_mb_rsp_data15_t
#define bustype_CAVM_GSERCX_PHY0_MB_RSP_DATA15(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_MB_RSP_DATA15(a) "GSERCX_PHY0_MB_RSP_DATA15"
#define device_bar_CAVM_GSERCX_PHY0_MB_RSP_DATA15(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_MB_RSP_DATA15(a) (a)
#define arguments_CAVM_GSERCX_PHY0_MB_RSP_DATA15(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_mb_rsp_data2
 *
 * GSERC Phy0 Mb Rsp Data2 Register
 */
union cavm_gsercx_phy0_mb_rsp_data2
{
    uint32_t u;
    struct cavm_gsercx_phy0_mb_rsp_data2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response auxiliary data or argument 2. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response auxiliary data or argument 2. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_mb_rsp_data2_s cn; */
};
typedef union cavm_gsercx_phy0_mb_rsp_data2 cavm_gsercx_phy0_mb_rsp_data2_t;

static inline uint64_t CAVM_GSERCX_PHY0_MB_RSP_DATA2(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_MB_RSP_DATA2(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a80038a8ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80038a8ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_MB_RSP_DATA2", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_MB_RSP_DATA2(a) cavm_gsercx_phy0_mb_rsp_data2_t
#define bustype_CAVM_GSERCX_PHY0_MB_RSP_DATA2(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_MB_RSP_DATA2(a) "GSERCX_PHY0_MB_RSP_DATA2"
#define device_bar_CAVM_GSERCX_PHY0_MB_RSP_DATA2(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_MB_RSP_DATA2(a) (a)
#define arguments_CAVM_GSERCX_PHY0_MB_RSP_DATA2(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_mb_rsp_data3
 *
 * GSERC Phy0 Mb Rsp Data3 Register
 */
union cavm_gsercx_phy0_mb_rsp_data3
{
    uint32_t u;
    struct cavm_gsercx_phy0_mb_rsp_data3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response auxiliary data or argument 3. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response auxiliary data or argument 3. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_mb_rsp_data3_s cn; */
};
typedef union cavm_gsercx_phy0_mb_rsp_data3 cavm_gsercx_phy0_mb_rsp_data3_t;

static inline uint64_t CAVM_GSERCX_PHY0_MB_RSP_DATA3(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_MB_RSP_DATA3(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a80038b0ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80038b0ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_MB_RSP_DATA3", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_MB_RSP_DATA3(a) cavm_gsercx_phy0_mb_rsp_data3_t
#define bustype_CAVM_GSERCX_PHY0_MB_RSP_DATA3(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_MB_RSP_DATA3(a) "GSERCX_PHY0_MB_RSP_DATA3"
#define device_bar_CAVM_GSERCX_PHY0_MB_RSP_DATA3(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_MB_RSP_DATA3(a) (a)
#define arguments_CAVM_GSERCX_PHY0_MB_RSP_DATA3(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_mb_rsp_data4
 *
 * GSERC Phy0 Mb Rsp Data4 Register
 */
union cavm_gsercx_phy0_mb_rsp_data4
{
    uint32_t u;
    struct cavm_gsercx_phy0_mb_rsp_data4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response auxiliary data or argument 4. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response auxiliary data or argument 4. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_mb_rsp_data4_s cn; */
};
typedef union cavm_gsercx_phy0_mb_rsp_data4 cavm_gsercx_phy0_mb_rsp_data4_t;

static inline uint64_t CAVM_GSERCX_PHY0_MB_RSP_DATA4(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_MB_RSP_DATA4(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a80038b8ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80038b8ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_MB_RSP_DATA4", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_MB_RSP_DATA4(a) cavm_gsercx_phy0_mb_rsp_data4_t
#define bustype_CAVM_GSERCX_PHY0_MB_RSP_DATA4(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_MB_RSP_DATA4(a) "GSERCX_PHY0_MB_RSP_DATA4"
#define device_bar_CAVM_GSERCX_PHY0_MB_RSP_DATA4(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_MB_RSP_DATA4(a) (a)
#define arguments_CAVM_GSERCX_PHY0_MB_RSP_DATA4(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_mb_rsp_data5
 *
 * GSERC Phy0 Mb Rsp Data5 Register
 */
union cavm_gsercx_phy0_mb_rsp_data5
{
    uint32_t u;
    struct cavm_gsercx_phy0_mb_rsp_data5_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response auxiliary data or argument 5. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response auxiliary data or argument 5. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_mb_rsp_data5_s cn; */
};
typedef union cavm_gsercx_phy0_mb_rsp_data5 cavm_gsercx_phy0_mb_rsp_data5_t;

static inline uint64_t CAVM_GSERCX_PHY0_MB_RSP_DATA5(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_MB_RSP_DATA5(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a80038c0ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80038c0ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_MB_RSP_DATA5", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_MB_RSP_DATA5(a) cavm_gsercx_phy0_mb_rsp_data5_t
#define bustype_CAVM_GSERCX_PHY0_MB_RSP_DATA5(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_MB_RSP_DATA5(a) "GSERCX_PHY0_MB_RSP_DATA5"
#define device_bar_CAVM_GSERCX_PHY0_MB_RSP_DATA5(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_MB_RSP_DATA5(a) (a)
#define arguments_CAVM_GSERCX_PHY0_MB_RSP_DATA5(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_mb_rsp_data6
 *
 * GSERC Phy0 Mb Rsp Data6 Register
 */
union cavm_gsercx_phy0_mb_rsp_data6
{
    uint32_t u;
    struct cavm_gsercx_phy0_mb_rsp_data6_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response auxiliary data or argument 6. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response auxiliary data or argument 6. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_mb_rsp_data6_s cn; */
};
typedef union cavm_gsercx_phy0_mb_rsp_data6 cavm_gsercx_phy0_mb_rsp_data6_t;

static inline uint64_t CAVM_GSERCX_PHY0_MB_RSP_DATA6(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_MB_RSP_DATA6(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a80038c8ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80038c8ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_MB_RSP_DATA6", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_MB_RSP_DATA6(a) cavm_gsercx_phy0_mb_rsp_data6_t
#define bustype_CAVM_GSERCX_PHY0_MB_RSP_DATA6(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_MB_RSP_DATA6(a) "GSERCX_PHY0_MB_RSP_DATA6"
#define device_bar_CAVM_GSERCX_PHY0_MB_RSP_DATA6(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_MB_RSP_DATA6(a) (a)
#define arguments_CAVM_GSERCX_PHY0_MB_RSP_DATA6(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_mb_rsp_data7
 *
 * GSERC Phy0 Mb Rsp Data7 Register
 */
union cavm_gsercx_phy0_mb_rsp_data7
{
    uint32_t u;
    struct cavm_gsercx_phy0_mb_rsp_data7_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response auxiliary data or argument 7. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response auxiliary data or argument 7. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_mb_rsp_data7_s cn; */
};
typedef union cavm_gsercx_phy0_mb_rsp_data7 cavm_gsercx_phy0_mb_rsp_data7_t;

static inline uint64_t CAVM_GSERCX_PHY0_MB_RSP_DATA7(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_MB_RSP_DATA7(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a80038d0ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80038d0ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_MB_RSP_DATA7", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_MB_RSP_DATA7(a) cavm_gsercx_phy0_mb_rsp_data7_t
#define bustype_CAVM_GSERCX_PHY0_MB_RSP_DATA7(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_MB_RSP_DATA7(a) "GSERCX_PHY0_MB_RSP_DATA7"
#define device_bar_CAVM_GSERCX_PHY0_MB_RSP_DATA7(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_MB_RSP_DATA7(a) (a)
#define arguments_CAVM_GSERCX_PHY0_MB_RSP_DATA7(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_mb_rsp_data8
 *
 * GSERC Phy0 Mb Rsp Data8 Register
 */
union cavm_gsercx_phy0_mb_rsp_data8
{
    uint32_t u;
    struct cavm_gsercx_phy0_mb_rsp_data8_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response auxiliary data or argument 8. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response auxiliary data or argument 8. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_mb_rsp_data8_s cn; */
};
typedef union cavm_gsercx_phy0_mb_rsp_data8 cavm_gsercx_phy0_mb_rsp_data8_t;

static inline uint64_t CAVM_GSERCX_PHY0_MB_RSP_DATA8(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_MB_RSP_DATA8(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a80038d8ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80038d8ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_MB_RSP_DATA8", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_MB_RSP_DATA8(a) cavm_gsercx_phy0_mb_rsp_data8_t
#define bustype_CAVM_GSERCX_PHY0_MB_RSP_DATA8(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_MB_RSP_DATA8(a) "GSERCX_PHY0_MB_RSP_DATA8"
#define device_bar_CAVM_GSERCX_PHY0_MB_RSP_DATA8(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_MB_RSP_DATA8(a) (a)
#define arguments_CAVM_GSERCX_PHY0_MB_RSP_DATA8(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_mb_rsp_data9
 *
 * GSERC Phy0 Mb Rsp Data9 Register
 */
union cavm_gsercx_phy0_mb_rsp_data9
{
    uint32_t u;
    struct cavm_gsercx_phy0_mb_rsp_data9_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response auxiliary data or argument 9. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response auxiliary data or argument 9. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_mb_rsp_data9_s cn; */
};
typedef union cavm_gsercx_phy0_mb_rsp_data9 cavm_gsercx_phy0_mb_rsp_data9_t;

static inline uint64_t CAVM_GSERCX_PHY0_MB_RSP_DATA9(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_MB_RSP_DATA9(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a80038e0ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80038e0ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_MB_RSP_DATA9", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_MB_RSP_DATA9(a) cavm_gsercx_phy0_mb_rsp_data9_t
#define bustype_CAVM_GSERCX_PHY0_MB_RSP_DATA9(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_MB_RSP_DATA9(a) "GSERCX_PHY0_MB_RSP_DATA9"
#define device_bar_CAVM_GSERCX_PHY0_MB_RSP_DATA9(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_MB_RSP_DATA9(a) (a)
#define arguments_CAVM_GSERCX_PHY0_MB_RSP_DATA9(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_mb_rsp_flag
 *
 * GSERC Phy0 Mb Rsp Flag Register
 */
union cavm_gsercx_phy0_mb_rsp_flag
{
    uint32_t u;
    struct cavm_gsercx_phy0_mb_rsp_flag_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W1C/H) Indicates the presence of a new Response to the PHY firmware.
                                                                 It is set automatically when RSP is written.
                                                                 It is expected to be cleared by the APB Master by writing 1 to it. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W1C/H) Indicates the presence of a new Response to the PHY firmware.
                                                                 It is set automatically when RSP is written.
                                                                 It is expected to be cleared by the APB Master by writing 1 to it. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_mb_rsp_flag_s cn; */
};
typedef union cavm_gsercx_phy0_mb_rsp_flag cavm_gsercx_phy0_mb_rsp_flag_t;

static inline uint64_t CAVM_GSERCX_PHY0_MB_RSP_FLAG(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_MB_RSP_FLAG(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8003890ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8003890ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_MB_RSP_FLAG", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_MB_RSP_FLAG(a) cavm_gsercx_phy0_mb_rsp_flag_t
#define bustype_CAVM_GSERCX_PHY0_MB_RSP_FLAG(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_MB_RSP_FLAG(a) "GSERCX_PHY0_MB_RSP_FLAG"
#define device_bar_CAVM_GSERCX_PHY0_MB_RSP_FLAG(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_MB_RSP_FLAG(a) (a)
#define arguments_CAVM_GSERCX_PHY0_MB_RSP_FLAG(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_afe_atest_ctrl0
 *
 * GSERC Phy0 Top Afe Atest Ctrl0 Register
 */
union cavm_gsercx_phy0_top_afe_atest_ctrl0
{
    uint32_t u;
    struct cavm_gsercx_phy0_top_afe_atest_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t atest_en              : 4;  /**< [  3:  0](R/W/H) Analog test bus enable.
                                                                 0 = off
                                                                 1 = CMU macro atest enabled
                                                                 3 = lane 0 atest enabled
                                                                 4 = lane 1 atest enabled
                                                                 5 = lane 2 atest enabled
                                                                 6 = lane 3 atest enabled
                                                                 7 = lane 4 atest enabled
                                                                 8 = lane 5 atest enabled
                                                                 9 = lane 6 atest enabled
                                                                 10 = lane 7 atest enabled
                                                                 15 = soc_atest enabled
                                                                 others = reserved */
#else /* Word 0 - Little Endian */
        uint32_t atest_en              : 4;  /**< [  3:  0](R/W/H) Analog test bus enable.
                                                                 0 = off
                                                                 1 = CMU macro atest enabled
                                                                 3 = lane 0 atest enabled
                                                                 4 = lane 1 atest enabled
                                                                 5 = lane 2 atest enabled
                                                                 6 = lane 3 atest enabled
                                                                 7 = lane 4 atest enabled
                                                                 8 = lane 5 atest enabled
                                                                 9 = lane 6 atest enabled
                                                                 10 = lane 7 atest enabled
                                                                 15 = soc_atest enabled
                                                                 others = reserved */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_top_afe_atest_ctrl0_s cn; */
};
typedef union cavm_gsercx_phy0_top_afe_atest_ctrl0 cavm_gsercx_phy0_top_afe_atest_ctrl0_t;

static inline uint64_t CAVM_GSERCX_PHY0_TOP_AFE_ATEST_CTRL0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_TOP_AFE_ATEST_CTRL0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a80051c0ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80051c0ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_TOP_AFE_ATEST_CTRL0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_TOP_AFE_ATEST_CTRL0(a) cavm_gsercx_phy0_top_afe_atest_ctrl0_t
#define bustype_CAVM_GSERCX_PHY0_TOP_AFE_ATEST_CTRL0(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_TOP_AFE_ATEST_CTRL0(a) "GSERCX_PHY0_TOP_AFE_ATEST_CTRL0"
#define device_bar_CAVM_GSERCX_PHY0_TOP_AFE_ATEST_CTRL0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_TOP_AFE_ATEST_CTRL0(a) (a)
#define arguments_CAVM_GSERCX_PHY0_TOP_AFE_ATEST_CTRL0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_afe_atest_ctrl1
 *
 * GSERC Phy0 Top Afe Atest Ctrl1 Register
 */
union cavm_gsercx_phy0_top_afe_atest_ctrl1
{
    uint32_t u;
    struct cavm_gsercx_phy0_top_afe_atest_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t atest_sel             : 6;  /**< [  5:  0](R/W/H) Analog test bus selection.
                                                                 Once a lane or CMU is selected, then the desired analog voltage or current
                                                                 signals that is sent to the ATEST1/2 C4s is determined by this register. A
                                                                 different mapping is used for both CMU and lane macros. This mapping is provided
                                                                 in separate documentation. */
#else /* Word 0 - Little Endian */
        uint32_t atest_sel             : 6;  /**< [  5:  0](R/W/H) Analog test bus selection.
                                                                 Once a lane or CMU is selected, then the desired analog voltage or current
                                                                 signals that is sent to the ATEST1/2 C4s is determined by this register. A
                                                                 different mapping is used for both CMU and lane macros. This mapping is provided
                                                                 in separate documentation. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_top_afe_atest_ctrl1_s cn; */
};
typedef union cavm_gsercx_phy0_top_afe_atest_ctrl1 cavm_gsercx_phy0_top_afe_atest_ctrl1_t;

static inline uint64_t CAVM_GSERCX_PHY0_TOP_AFE_ATEST_CTRL1(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_TOP_AFE_ATEST_CTRL1(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a80051c8ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80051c8ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_TOP_AFE_ATEST_CTRL1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_TOP_AFE_ATEST_CTRL1(a) cavm_gsercx_phy0_top_afe_atest_ctrl1_t
#define bustype_CAVM_GSERCX_PHY0_TOP_AFE_ATEST_CTRL1(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_TOP_AFE_ATEST_CTRL1(a) "GSERCX_PHY0_TOP_AFE_ATEST_CTRL1"
#define device_bar_CAVM_GSERCX_PHY0_TOP_AFE_ATEST_CTRL1(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_TOP_AFE_ATEST_CTRL1(a) (a)
#define arguments_CAVM_GSERCX_PHY0_TOP_AFE_ATEST_CTRL1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_clock_afe_ln0_clk_rx
 *
 * GSERC Phy0 Top Clock Afe Ln0 Clk Rx Register
 */
union cavm_gsercx_phy0_top_clock_afe_ln0_clk_rx
{
    uint32_t u;
    struct cavm_gsercx_phy0_top_clock_afe_ln0_clk_rx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t stat_rx_clk_en        : 1;  /**< [  2:  2](RO/H) Reserved. */
        uint32_t stat_default_clk_en   : 1;  /**< [  1:  1](RO/H) Reserved. */
        uint32_t ctrl_src_sel          : 1;  /**< [  0:  0](R/W/H) Clock source select for the lane afe_ln0_clk_rx
                                                                 0x0 = select the default clock life clock
                                                                 0x1 = afe_ln0_clk_rxdata AFE rx word clock */
#else /* Word 0 - Little Endian */
        uint32_t ctrl_src_sel          : 1;  /**< [  0:  0](R/W/H) Clock source select for the lane afe_ln0_clk_rx
                                                                 0x0 = select the default clock life clock
                                                                 0x1 = afe_ln0_clk_rxdata AFE rx word clock */
        uint32_t stat_default_clk_en   : 1;  /**< [  1:  1](RO/H) Reserved. */
        uint32_t stat_rx_clk_en        : 1;  /**< [  2:  2](RO/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_top_clock_afe_ln0_clk_rx_s cn; */
};
typedef union cavm_gsercx_phy0_top_clock_afe_ln0_clk_rx cavm_gsercx_phy0_top_clock_afe_ln0_clk_rx_t;

static inline uint64_t CAVM_GSERCX_PHY0_TOP_CLOCK_AFE_LN0_CLK_RX(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_TOP_CLOCK_AFE_LN0_CLK_RX(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8005890ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005890ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_TOP_CLOCK_AFE_LN0_CLK_RX", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_TOP_CLOCK_AFE_LN0_CLK_RX(a) cavm_gsercx_phy0_top_clock_afe_ln0_clk_rx_t
#define bustype_CAVM_GSERCX_PHY0_TOP_CLOCK_AFE_LN0_CLK_RX(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_TOP_CLOCK_AFE_LN0_CLK_RX(a) "GSERCX_PHY0_TOP_CLOCK_AFE_LN0_CLK_RX"
#define device_bar_CAVM_GSERCX_PHY0_TOP_CLOCK_AFE_LN0_CLK_RX(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_TOP_CLOCK_AFE_LN0_CLK_RX(a) (a)
#define arguments_CAVM_GSERCX_PHY0_TOP_CLOCK_AFE_LN0_CLK_RX(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_clock_afe_ln1_clk_rx
 *
 * GSERC Phy0 Top Clock Afe Ln1 Clk Rx Register
 */
union cavm_gsercx_phy0_top_clock_afe_ln1_clk_rx
{
    uint32_t u;
    struct cavm_gsercx_phy0_top_clock_afe_ln1_clk_rx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t stat_rx_clk_en        : 1;  /**< [  2:  2](RO/H) Reserved. */
        uint32_t stat_default_clk_en   : 1;  /**< [  1:  1](RO/H) Reserved. */
        uint32_t ctrl_src_sel          : 1;  /**< [  0:  0](R/W/H) Clock source select for the lane afe_ln1_clk_rx
                                                                 0x0 = select the default clock life clock
                                                                 0x1 = afe_ln1_clk_rxdata AFE rx word clock */
#else /* Word 0 - Little Endian */
        uint32_t ctrl_src_sel          : 1;  /**< [  0:  0](R/W/H) Clock source select for the lane afe_ln1_clk_rx
                                                                 0x0 = select the default clock life clock
                                                                 0x1 = afe_ln1_clk_rxdata AFE rx word clock */
        uint32_t stat_default_clk_en   : 1;  /**< [  1:  1](RO/H) Reserved. */
        uint32_t stat_rx_clk_en        : 1;  /**< [  2:  2](RO/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_top_clock_afe_ln1_clk_rx_s cn; */
};
typedef union cavm_gsercx_phy0_top_clock_afe_ln1_clk_rx cavm_gsercx_phy0_top_clock_afe_ln1_clk_rx_t;

static inline uint64_t CAVM_GSERCX_PHY0_TOP_CLOCK_AFE_LN1_CLK_RX(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_TOP_CLOCK_AFE_LN1_CLK_RX(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8005910ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005910ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_TOP_CLOCK_AFE_LN1_CLK_RX", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_TOP_CLOCK_AFE_LN1_CLK_RX(a) cavm_gsercx_phy0_top_clock_afe_ln1_clk_rx_t
#define bustype_CAVM_GSERCX_PHY0_TOP_CLOCK_AFE_LN1_CLK_RX(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_TOP_CLOCK_AFE_LN1_CLK_RX(a) "GSERCX_PHY0_TOP_CLOCK_AFE_LN1_CLK_RX"
#define device_bar_CAVM_GSERCX_PHY0_TOP_CLOCK_AFE_LN1_CLK_RX(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_TOP_CLOCK_AFE_LN1_CLK_RX(a) (a)
#define arguments_CAVM_GSERCX_PHY0_TOP_CLOCK_AFE_LN1_CLK_RX(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_clock_ln0_cg_ctrl
 *
 * GSERC Phy0 Top Clock Ln0 Cg Ctrl Register
 */
union cavm_gsercx_phy0_top_clock_ln0_cg_ctrl
{
    uint32_t u;
    struct cavm_gsercx_phy0_top_clock_ln0_cg_ctrl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t clk_rx_cg_disable     : 1;  /**< [  7:  7](R/W/H) Reserved. */
        uint32_t reserved_6            : 1;
        uint32_t gcfsm                 : 1;  /**< [  5:  5](R/W/H) Reserved. */
        uint32_t dfe                   : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t leq                   : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t bist_rx               : 1;  /**< [  2:  2](R/W/H) Clock gate enable for RXF bist clock branch. */
        uint32_t clk_rx                : 1;  /**< [  1:  1](R/W/H) Clock gate enable for ln0 clk_rx. */
        uint32_t bist_tx               : 1;  /**< [  0:  0](R/W/H) Clock gate enable for TXF bist clock branch. */
#else /* Word 0 - Little Endian */
        uint32_t bist_tx               : 1;  /**< [  0:  0](R/W/H) Clock gate enable for TXF bist clock branch. */
        uint32_t clk_rx                : 1;  /**< [  1:  1](R/W/H) Clock gate enable for ln0 clk_rx. */
        uint32_t bist_rx               : 1;  /**< [  2:  2](R/W/H) Clock gate enable for RXF bist clock branch. */
        uint32_t leq                   : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t dfe                   : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t gcfsm                 : 1;  /**< [  5:  5](R/W/H) Reserved. */
        uint32_t reserved_6            : 1;
        uint32_t clk_rx_cg_disable     : 1;  /**< [  7:  7](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_top_clock_ln0_cg_ctrl_s cn; */
};
typedef union cavm_gsercx_phy0_top_clock_ln0_cg_ctrl cavm_gsercx_phy0_top_clock_ln0_cg_ctrl_t;

static inline uint64_t CAVM_GSERCX_PHY0_TOP_CLOCK_LN0_CG_CTRL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_TOP_CLOCK_LN0_CG_CTRL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a80058b0ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80058b0ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_TOP_CLOCK_LN0_CG_CTRL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_TOP_CLOCK_LN0_CG_CTRL(a) cavm_gsercx_phy0_top_clock_ln0_cg_ctrl_t
#define bustype_CAVM_GSERCX_PHY0_TOP_CLOCK_LN0_CG_CTRL(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_TOP_CLOCK_LN0_CG_CTRL(a) "GSERCX_PHY0_TOP_CLOCK_LN0_CG_CTRL"
#define device_bar_CAVM_GSERCX_PHY0_TOP_CLOCK_LN0_CG_CTRL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_TOP_CLOCK_LN0_CG_CTRL(a) (a)
#define arguments_CAVM_GSERCX_PHY0_TOP_CLOCK_LN0_CG_CTRL(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_clock_ln0_clk_rxb
 *
 * GSERC Phy0 Top Clock Ln0 Clk Rxb Register
 */
union cavm_gsercx_phy0_top_clock_ln0_clk_rxb
{
    uint32_t u;
    struct cavm_gsercx_phy0_top_clock_ln0_clk_rxb_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t ctrl_src_ovr_en       : 1;  /**< [  2:  2](R/W/H) Override enable for ln0_clk_rxb. */
        uint32_t ctrl_src_ovr_val      : 2;  /**< [  1:  0](R/W/H) Override value for ln0_clk_rxb.
                                                                 0x0 = ln()_txclk_i
                                                                 0x1 = rxdiv clock
                                                                 0x2 = cmu clock
                                                                 0x3 = rxclock */
#else /* Word 0 - Little Endian */
        uint32_t ctrl_src_ovr_val      : 2;  /**< [  1:  0](R/W/H) Override value for ln0_clk_rxb.
                                                                 0x0 = ln()_txclk_i
                                                                 0x1 = rxdiv clock
                                                                 0x2 = cmu clock
                                                                 0x3 = rxclock */
        uint32_t ctrl_src_ovr_en       : 1;  /**< [  2:  2](R/W/H) Override enable for ln0_clk_rxb. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_top_clock_ln0_clk_rxb_s cn; */
};
typedef union cavm_gsercx_phy0_top_clock_ln0_clk_rxb cavm_gsercx_phy0_top_clock_ln0_clk_rxb_t;

static inline uint64_t CAVM_GSERCX_PHY0_TOP_CLOCK_LN0_CLK_RXB(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_TOP_CLOCK_LN0_CLK_RXB(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a80058a0ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80058a0ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_TOP_CLOCK_LN0_CLK_RXB", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_TOP_CLOCK_LN0_CLK_RXB(a) cavm_gsercx_phy0_top_clock_ln0_clk_rxb_t
#define bustype_CAVM_GSERCX_PHY0_TOP_CLOCK_LN0_CLK_RXB(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_TOP_CLOCK_LN0_CLK_RXB(a) "GSERCX_PHY0_TOP_CLOCK_LN0_CLK_RXB"
#define device_bar_CAVM_GSERCX_PHY0_TOP_CLOCK_LN0_CLK_RXB(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_TOP_CLOCK_LN0_CLK_RXB(a) (a)
#define arguments_CAVM_GSERCX_PHY0_TOP_CLOCK_LN0_CLK_RXB(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_clock_ln0_clk_rxf
 *
 * GSERC Phy0 Top Clock Ln0 Clk Rxf Register
 */
union cavm_gsercx_phy0_top_clock_ln0_clk_rxf
{
    uint32_t u;
    struct cavm_gsercx_phy0_top_clock_ln0_clk_rxf_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t ctrl_src_sel          : 2;  /**< [  1:  0](R/W/H) Clock source select for lane 0 RXF clock.
                                                                 0x0 = ln()_txclk_i
                                                                 0x1 = unused
                                                                 0x2 = cmu clock
                                                                 0x3 = rxclock */
#else /* Word 0 - Little Endian */
        uint32_t ctrl_src_sel          : 2;  /**< [  1:  0](R/W/H) Clock source select for lane 0 RXF clock.
                                                                 0x0 = ln()_txclk_i
                                                                 0x1 = unused
                                                                 0x2 = cmu clock
                                                                 0x3 = rxclock */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_top_clock_ln0_clk_rxf_s cn; */
};
typedef union cavm_gsercx_phy0_top_clock_ln0_clk_rxf cavm_gsercx_phy0_top_clock_ln0_clk_rxf_t;

static inline uint64_t CAVM_GSERCX_PHY0_TOP_CLOCK_LN0_CLK_RXF(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_TOP_CLOCK_LN0_CLK_RXF(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a80058a8ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80058a8ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_TOP_CLOCK_LN0_CLK_RXF", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_TOP_CLOCK_LN0_CLK_RXF(a) cavm_gsercx_phy0_top_clock_ln0_clk_rxf_t
#define bustype_CAVM_GSERCX_PHY0_TOP_CLOCK_LN0_CLK_RXF(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_TOP_CLOCK_LN0_CLK_RXF(a) "GSERCX_PHY0_TOP_CLOCK_LN0_CLK_RXF"
#define device_bar_CAVM_GSERCX_PHY0_TOP_CLOCK_LN0_CLK_RXF(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_TOP_CLOCK_LN0_CLK_RXF(a) (a)
#define arguments_CAVM_GSERCX_PHY0_TOP_CLOCK_LN0_CLK_RXF(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_clock_ln0_clk_txb
 *
 * GSERC Phy0 Top Clock Ln0 Clk Txb Register
 */
union cavm_gsercx_phy0_top_clock_ln0_clk_txb
{
    uint32_t u;
    struct cavm_gsercx_phy0_top_clock_ln0_clk_txb_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t ctrl_src_ovr_en       : 1;  /**< [  2:  2](R/W/H) Override enable for ln0_clk_txb. */
        uint32_t ctrl_src_ovr_val      : 2;  /**< [  1:  0](R/W/H) Clock source select override value for ln0_clk_txb
                                                                 0x0 = rx clock
                                                                 0x1 = rxdiv clock
                                                                 0x2 = cmu clock
                                                                 0x3 = ln0_txclk_i PHY input clock */
#else /* Word 0 - Little Endian */
        uint32_t ctrl_src_ovr_val      : 2;  /**< [  1:  0](R/W/H) Clock source select override value for ln0_clk_txb
                                                                 0x0 = rx clock
                                                                 0x1 = rxdiv clock
                                                                 0x2 = cmu clock
                                                                 0x3 = ln0_txclk_i PHY input clock */
        uint32_t ctrl_src_ovr_en       : 1;  /**< [  2:  2](R/W/H) Override enable for ln0_clk_txb. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_top_clock_ln0_clk_txb_s cn; */
};
typedef union cavm_gsercx_phy0_top_clock_ln0_clk_txb cavm_gsercx_phy0_top_clock_ln0_clk_txb_t;

static inline uint64_t CAVM_GSERCX_PHY0_TOP_CLOCK_LN0_CLK_TXB(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_TOP_CLOCK_LN0_CLK_TXB(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8005880ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005880ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_TOP_CLOCK_LN0_CLK_TXB", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_TOP_CLOCK_LN0_CLK_TXB(a) cavm_gsercx_phy0_top_clock_ln0_clk_txb_t
#define bustype_CAVM_GSERCX_PHY0_TOP_CLOCK_LN0_CLK_TXB(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_TOP_CLOCK_LN0_CLK_TXB(a) "GSERCX_PHY0_TOP_CLOCK_LN0_CLK_TXB"
#define device_bar_CAVM_GSERCX_PHY0_TOP_CLOCK_LN0_CLK_TXB(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_TOP_CLOCK_LN0_CLK_TXB(a) (a)
#define arguments_CAVM_GSERCX_PHY0_TOP_CLOCK_LN0_CLK_TXB(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_clock_ln0_clk_txf
 *
 * GSERC Phy0 Top Clock Ln0 Clk Txf Register
 */
union cavm_gsercx_phy0_top_clock_ln0_clk_txf
{
    uint32_t u;
    struct cavm_gsercx_phy0_top_clock_ln0_clk_txf_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t ctrl_src_ovr_en       : 1;  /**< [  2:  2](R/W/H) Override enable for ln0_clk_txf. */
        uint32_t ctrl_src_ovr_val      : 2;  /**< [  1:  0](R/W/H) Override value for ln0_clk_txf.
                                                                 0x0 = rx clock
                                                                 0x1 = reserved
                                                                 0x2 = cmu clock
                                                                 0x3 = ln0_txclk_i PHY input clock */
#else /* Word 0 - Little Endian */
        uint32_t ctrl_src_ovr_val      : 2;  /**< [  1:  0](R/W/H) Override value for ln0_clk_txf.
                                                                 0x0 = rx clock
                                                                 0x1 = reserved
                                                                 0x2 = cmu clock
                                                                 0x3 = ln0_txclk_i PHY input clock */
        uint32_t ctrl_src_ovr_en       : 1;  /**< [  2:  2](R/W/H) Override enable for ln0_clk_txf. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_top_clock_ln0_clk_txf_s cn; */
};
typedef union cavm_gsercx_phy0_top_clock_ln0_clk_txf cavm_gsercx_phy0_top_clock_ln0_clk_txf_t;

static inline uint64_t CAVM_GSERCX_PHY0_TOP_CLOCK_LN0_CLK_TXF(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_TOP_CLOCK_LN0_CLK_TXF(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8005888ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005888ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_TOP_CLOCK_LN0_CLK_TXF", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_TOP_CLOCK_LN0_CLK_TXF(a) cavm_gsercx_phy0_top_clock_ln0_clk_txf_t
#define bustype_CAVM_GSERCX_PHY0_TOP_CLOCK_LN0_CLK_TXF(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_TOP_CLOCK_LN0_CLK_TXF(a) "GSERCX_PHY0_TOP_CLOCK_LN0_CLK_TXF"
#define device_bar_CAVM_GSERCX_PHY0_TOP_CLOCK_LN0_CLK_TXF(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_TOP_CLOCK_LN0_CLK_TXF(a) (a)
#define arguments_CAVM_GSERCX_PHY0_TOP_CLOCK_LN0_CLK_TXF(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_clock_ln0_cm0_clk_gs_mode_ctrl0_rsvd
 *
 * GSERC Phy0 Top Clock Ln0 Cm0 Clk Gs Mode Ctrl0 Register
 */
union cavm_gsercx_phy0_top_clock_ln0_cm0_clk_gs_mode_ctrl0_rsvd
{
    uint32_t u;
    struct cavm_gsercx_phy0_top_clock_ln0_cm0_clk_gs_mode_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t ctrl_div_ovr_en       : 1;  /**< [  7:  7](R/W/H) Reserved. */
        uint32_t reserved_6            : 1;
        uint32_t ctrl_div_ovr_val      : 2;  /**< [  5:  4](R/W/H) Reserved. */
        uint32_t ctrl_src_ovr_en       : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t ctrl_src_ovr_val      : 3;  /**< [  2:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t ctrl_src_ovr_val      : 3;  /**< [  2:  0](R/W/H) Reserved. */
        uint32_t ctrl_src_ovr_en       : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t ctrl_div_ovr_val      : 2;  /**< [  5:  4](R/W/H) Reserved. */
        uint32_t reserved_6            : 1;
        uint32_t ctrl_div_ovr_en       : 1;  /**< [  7:  7](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_top_clock_ln0_cm0_clk_gs_mode_ctrl0_rsvd_s cn; */
};
typedef union cavm_gsercx_phy0_top_clock_ln0_cm0_clk_gs_mode_ctrl0_rsvd cavm_gsercx_phy0_top_clock_ln0_cm0_clk_gs_mode_ctrl0_rsvd_t;

static inline uint64_t CAVM_GSERCX_PHY0_TOP_CLOCK_LN0_CM0_CLK_GS_MODE_CTRL0_RSVD(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_TOP_CLOCK_LN0_CM0_CLK_GS_MODE_CTRL0_RSVD(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80058f0ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_TOP_CLOCK_LN0_CM0_CLK_GS_MODE_CTRL0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_TOP_CLOCK_LN0_CM0_CLK_GS_MODE_CTRL0_RSVD(a) cavm_gsercx_phy0_top_clock_ln0_cm0_clk_gs_mode_ctrl0_rsvd_t
#define bustype_CAVM_GSERCX_PHY0_TOP_CLOCK_LN0_CM0_CLK_GS_MODE_CTRL0_RSVD(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_TOP_CLOCK_LN0_CM0_CLK_GS_MODE_CTRL0_RSVD(a) "GSERCX_PHY0_TOP_CLOCK_LN0_CM0_CLK_GS_MODE_CTRL0_RSVD"
#define device_bar_CAVM_GSERCX_PHY0_TOP_CLOCK_LN0_CM0_CLK_GS_MODE_CTRL0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_TOP_CLOCK_LN0_CM0_CLK_GS_MODE_CTRL0_RSVD(a) (a)
#define arguments_CAVM_GSERCX_PHY0_TOP_CLOCK_LN0_CM0_CLK_GS_MODE_CTRL0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_clock_ln0_tx_rate
 *
 * GSERC Phy0 Top Clock Ln0 Tx Rate Register
 */
union cavm_gsercx_phy0_top_clock_ln0_tx_rate
{
    uint32_t u;
    struct cavm_gsercx_phy0_top_clock_ln0_tx_rate_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t div_sel               : 2;  /**< [  3:  2](R/W/H) 0x0 = DIV1
                                                                 0x1 = DIV2
                                                                 0x3 = DIV4
                                                                 others = reserved */
        uint32_t rate_sel              : 2;  /**< [  1:  0](R/W/H) Clock selection in Gearbox mode
                                                                 0x0 = PLL1
                                                                 0x1 = PLL2
                                                                 0x2 = PLL3
                                                                 others = reserved */
#else /* Word 0 - Little Endian */
        uint32_t rate_sel              : 2;  /**< [  1:  0](R/W/H) Clock selection in Gearbox mode
                                                                 0x0 = PLL1
                                                                 0x1 = PLL2
                                                                 0x2 = PLL3
                                                                 others = reserved */
        uint32_t div_sel               : 2;  /**< [  3:  2](R/W/H) 0x0 = DIV1
                                                                 0x1 = DIV2
                                                                 0x3 = DIV4
                                                                 others = reserved */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_top_clock_ln0_tx_rate_s cn; */
};
typedef union cavm_gsercx_phy0_top_clock_ln0_tx_rate cavm_gsercx_phy0_top_clock_ln0_tx_rate_t;

static inline uint64_t CAVM_GSERCX_PHY0_TOP_CLOCK_LN0_TX_RATE(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_TOP_CLOCK_LN0_TX_RATE(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a80058c0ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80058c0ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_TOP_CLOCK_LN0_TX_RATE", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_TOP_CLOCK_LN0_TX_RATE(a) cavm_gsercx_phy0_top_clock_ln0_tx_rate_t
#define bustype_CAVM_GSERCX_PHY0_TOP_CLOCK_LN0_TX_RATE(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_TOP_CLOCK_LN0_TX_RATE(a) "GSERCX_PHY0_TOP_CLOCK_LN0_TX_RATE"
#define device_bar_CAVM_GSERCX_PHY0_TOP_CLOCK_LN0_TX_RATE(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_TOP_CLOCK_LN0_TX_RATE(a) (a)
#define arguments_CAVM_GSERCX_PHY0_TOP_CLOCK_LN0_TX_RATE(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_clock_ln1_cg_ctrl
 *
 * GSERC Phy0 Top Clock Ln1 Cg Ctrl Register
 */
union cavm_gsercx_phy0_top_clock_ln1_cg_ctrl
{
    uint32_t u;
    struct cavm_gsercx_phy0_top_clock_ln1_cg_ctrl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t clk_rx_cg_disable     : 1;  /**< [  7:  7](R/W/H) Reserved. */
        uint32_t reserved_6            : 1;
        uint32_t gcfsm                 : 1;  /**< [  5:  5](R/W/H) Reserved. */
        uint32_t dfe                   : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t leq                   : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t bist_rx               : 1;  /**< [  2:  2](R/W/H) Clock gate enable for RXF bist clock branch. */
        uint32_t clk_rx                : 1;  /**< [  1:  1](R/W/H) Clock gate enable for ln1 clk_rx. */
        uint32_t bist_tx               : 1;  /**< [  0:  0](R/W/H) Clock gate enable for TXF bist clock branch. */
#else /* Word 0 - Little Endian */
        uint32_t bist_tx               : 1;  /**< [  0:  0](R/W/H) Clock gate enable for TXF bist clock branch. */
        uint32_t clk_rx                : 1;  /**< [  1:  1](R/W/H) Clock gate enable for ln1 clk_rx. */
        uint32_t bist_rx               : 1;  /**< [  2:  2](R/W/H) Clock gate enable for RXF bist clock branch. */
        uint32_t leq                   : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t dfe                   : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t gcfsm                 : 1;  /**< [  5:  5](R/W/H) Reserved. */
        uint32_t reserved_6            : 1;
        uint32_t clk_rx_cg_disable     : 1;  /**< [  7:  7](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_top_clock_ln1_cg_ctrl_s cn; */
};
typedef union cavm_gsercx_phy0_top_clock_ln1_cg_ctrl cavm_gsercx_phy0_top_clock_ln1_cg_ctrl_t;

static inline uint64_t CAVM_GSERCX_PHY0_TOP_CLOCK_LN1_CG_CTRL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_TOP_CLOCK_LN1_CG_CTRL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8005930ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005930ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_TOP_CLOCK_LN1_CG_CTRL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_TOP_CLOCK_LN1_CG_CTRL(a) cavm_gsercx_phy0_top_clock_ln1_cg_ctrl_t
#define bustype_CAVM_GSERCX_PHY0_TOP_CLOCK_LN1_CG_CTRL(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_TOP_CLOCK_LN1_CG_CTRL(a) "GSERCX_PHY0_TOP_CLOCK_LN1_CG_CTRL"
#define device_bar_CAVM_GSERCX_PHY0_TOP_CLOCK_LN1_CG_CTRL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_TOP_CLOCK_LN1_CG_CTRL(a) (a)
#define arguments_CAVM_GSERCX_PHY0_TOP_CLOCK_LN1_CG_CTRL(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_clock_ln1_clk_rxb
 *
 * GSERC Phy0 Top Clock Ln1 Clk Rxb Register
 */
union cavm_gsercx_phy0_top_clock_ln1_clk_rxb
{
    uint32_t u;
    struct cavm_gsercx_phy0_top_clock_ln1_clk_rxb_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t ctrl_src_ovr_en       : 1;  /**< [  2:  2](R/W/H) Override enable for ln1_clk_rxb. */
        uint32_t ctrl_src_ovr_val      : 2;  /**< [  1:  0](R/W/H) Override value for ln1_clk_rxb.
                                                                 0x0 = ln()_txclk_i
                                                                 0x1 = rxdiv clock
                                                                 0x2 = cmu clock
                                                                 0x3 = rxclock */
#else /* Word 0 - Little Endian */
        uint32_t ctrl_src_ovr_val      : 2;  /**< [  1:  0](R/W/H) Override value for ln1_clk_rxb.
                                                                 0x0 = ln()_txclk_i
                                                                 0x1 = rxdiv clock
                                                                 0x2 = cmu clock
                                                                 0x3 = rxclock */
        uint32_t ctrl_src_ovr_en       : 1;  /**< [  2:  2](R/W/H) Override enable for ln1_clk_rxb. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_top_clock_ln1_clk_rxb_s cn; */
};
typedef union cavm_gsercx_phy0_top_clock_ln1_clk_rxb cavm_gsercx_phy0_top_clock_ln1_clk_rxb_t;

static inline uint64_t CAVM_GSERCX_PHY0_TOP_CLOCK_LN1_CLK_RXB(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_TOP_CLOCK_LN1_CLK_RXB(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8005920ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005920ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_TOP_CLOCK_LN1_CLK_RXB", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_TOP_CLOCK_LN1_CLK_RXB(a) cavm_gsercx_phy0_top_clock_ln1_clk_rxb_t
#define bustype_CAVM_GSERCX_PHY0_TOP_CLOCK_LN1_CLK_RXB(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_TOP_CLOCK_LN1_CLK_RXB(a) "GSERCX_PHY0_TOP_CLOCK_LN1_CLK_RXB"
#define device_bar_CAVM_GSERCX_PHY0_TOP_CLOCK_LN1_CLK_RXB(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_TOP_CLOCK_LN1_CLK_RXB(a) (a)
#define arguments_CAVM_GSERCX_PHY0_TOP_CLOCK_LN1_CLK_RXB(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_clock_ln1_clk_rxf
 *
 * GSERC Phy0 Top Clock Ln1 Clk Rxf Register
 */
union cavm_gsercx_phy0_top_clock_ln1_clk_rxf
{
    uint32_t u;
    struct cavm_gsercx_phy0_top_clock_ln1_clk_rxf_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t ctrl_src_sel          : 2;  /**< [  1:  0](R/W/H) Clock source select for lane 1 RXF clock.
                                                                 0x0 = ln()_txclk_i
                                                                 0x1 = unused
                                                                 0x2 = cmu clock
                                                                 0x3 = rxclock */
#else /* Word 0 - Little Endian */
        uint32_t ctrl_src_sel          : 2;  /**< [  1:  0](R/W/H) Clock source select for lane 1 RXF clock.
                                                                 0x0 = ln()_txclk_i
                                                                 0x1 = unused
                                                                 0x2 = cmu clock
                                                                 0x3 = rxclock */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_top_clock_ln1_clk_rxf_s cn; */
};
typedef union cavm_gsercx_phy0_top_clock_ln1_clk_rxf cavm_gsercx_phy0_top_clock_ln1_clk_rxf_t;

static inline uint64_t CAVM_GSERCX_PHY0_TOP_CLOCK_LN1_CLK_RXF(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_TOP_CLOCK_LN1_CLK_RXF(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8005928ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005928ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_TOP_CLOCK_LN1_CLK_RXF", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_TOP_CLOCK_LN1_CLK_RXF(a) cavm_gsercx_phy0_top_clock_ln1_clk_rxf_t
#define bustype_CAVM_GSERCX_PHY0_TOP_CLOCK_LN1_CLK_RXF(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_TOP_CLOCK_LN1_CLK_RXF(a) "GSERCX_PHY0_TOP_CLOCK_LN1_CLK_RXF"
#define device_bar_CAVM_GSERCX_PHY0_TOP_CLOCK_LN1_CLK_RXF(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_TOP_CLOCK_LN1_CLK_RXF(a) (a)
#define arguments_CAVM_GSERCX_PHY0_TOP_CLOCK_LN1_CLK_RXF(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_clock_ln1_clk_txb
 *
 * GSERC Phy0 Top Clock Ln1 Clk Txb Register
 */
union cavm_gsercx_phy0_top_clock_ln1_clk_txb
{
    uint32_t u;
    struct cavm_gsercx_phy0_top_clock_ln1_clk_txb_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t ctrl_src_ovr_en       : 1;  /**< [  2:  2](R/W/H) Override enable for ln1_clk_txb. */
        uint32_t ctrl_src_ovr_val      : 2;  /**< [  1:  0](R/W/H) Override value for ln0_clk_rxb.
                                                                 0x0 = ln()_txclk_i
                                                                 0x1 = rxdiv clock
                                                                 0x2 = cmu clock
                                                                 0x3 = rxclock */
#else /* Word 0 - Little Endian */
        uint32_t ctrl_src_ovr_val      : 2;  /**< [  1:  0](R/W/H) Override value for ln0_clk_rxb.
                                                                 0x0 = ln()_txclk_i
                                                                 0x1 = rxdiv clock
                                                                 0x2 = cmu clock
                                                                 0x3 = rxclock */
        uint32_t ctrl_src_ovr_en       : 1;  /**< [  2:  2](R/W/H) Override enable for ln1_clk_txb. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_top_clock_ln1_clk_txb_s cn; */
};
typedef union cavm_gsercx_phy0_top_clock_ln1_clk_txb cavm_gsercx_phy0_top_clock_ln1_clk_txb_t;

static inline uint64_t CAVM_GSERCX_PHY0_TOP_CLOCK_LN1_CLK_TXB(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_TOP_CLOCK_LN1_CLK_TXB(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8005900ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005900ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_TOP_CLOCK_LN1_CLK_TXB", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_TOP_CLOCK_LN1_CLK_TXB(a) cavm_gsercx_phy0_top_clock_ln1_clk_txb_t
#define bustype_CAVM_GSERCX_PHY0_TOP_CLOCK_LN1_CLK_TXB(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_TOP_CLOCK_LN1_CLK_TXB(a) "GSERCX_PHY0_TOP_CLOCK_LN1_CLK_TXB"
#define device_bar_CAVM_GSERCX_PHY0_TOP_CLOCK_LN1_CLK_TXB(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_TOP_CLOCK_LN1_CLK_TXB(a) (a)
#define arguments_CAVM_GSERCX_PHY0_TOP_CLOCK_LN1_CLK_TXB(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_clock_ln1_clk_txf
 *
 * GSERC Phy0 Top Clock Ln1 Clk Txf Register
 */
union cavm_gsercx_phy0_top_clock_ln1_clk_txf
{
    uint32_t u;
    struct cavm_gsercx_phy0_top_clock_ln1_clk_txf_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t ctrl_src_ovr_en       : 1;  /**< [  2:  2](R/W/H) Override enable for ln1_clk_txf. */
        uint32_t ctrl_src_ovr_val      : 2;  /**< [  1:  0](R/W/H) Override value for ln1_clk_txf.
                                                                 0x0 = rx clock
                                                                 0x1 = reserved
                                                                 0x2 = cmu clock
                                                                 0x3 = ln0_txclk_i PHY input clock */
#else /* Word 0 - Little Endian */
        uint32_t ctrl_src_ovr_val      : 2;  /**< [  1:  0](R/W/H) Override value for ln1_clk_txf.
                                                                 0x0 = rx clock
                                                                 0x1 = reserved
                                                                 0x2 = cmu clock
                                                                 0x3 = ln0_txclk_i PHY input clock */
        uint32_t ctrl_src_ovr_en       : 1;  /**< [  2:  2](R/W/H) Override enable for ln1_clk_txf. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_top_clock_ln1_clk_txf_s cn; */
};
typedef union cavm_gsercx_phy0_top_clock_ln1_clk_txf cavm_gsercx_phy0_top_clock_ln1_clk_txf_t;

static inline uint64_t CAVM_GSERCX_PHY0_TOP_CLOCK_LN1_CLK_TXF(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_TOP_CLOCK_LN1_CLK_TXF(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8005908ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005908ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_TOP_CLOCK_LN1_CLK_TXF", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_TOP_CLOCK_LN1_CLK_TXF(a) cavm_gsercx_phy0_top_clock_ln1_clk_txf_t
#define bustype_CAVM_GSERCX_PHY0_TOP_CLOCK_LN1_CLK_TXF(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_TOP_CLOCK_LN1_CLK_TXF(a) "GSERCX_PHY0_TOP_CLOCK_LN1_CLK_TXF"
#define device_bar_CAVM_GSERCX_PHY0_TOP_CLOCK_LN1_CLK_TXF(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_TOP_CLOCK_LN1_CLK_TXF(a) (a)
#define arguments_CAVM_GSERCX_PHY0_TOP_CLOCK_LN1_CLK_TXF(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_clock_ln1_cm0_clk_gs_mode_ctrl0_rsvd
 *
 * GSERC Phy0 Top Clock Ln1 Cm0 Clk Gs Mode Ctrl0 Register
 */
union cavm_gsercx_phy0_top_clock_ln1_cm0_clk_gs_mode_ctrl0_rsvd
{
    uint32_t u;
    struct cavm_gsercx_phy0_top_clock_ln1_cm0_clk_gs_mode_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t ctrl_div_ovr_en       : 1;  /**< [  7:  7](R/W/H) Reserved. */
        uint32_t reserved_6            : 1;
        uint32_t ctrl_div_ovr_val      : 2;  /**< [  5:  4](R/W/H) Reserved. */
        uint32_t ctrl_src_ovr_en       : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t ctrl_src_ovr_val      : 3;  /**< [  2:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t ctrl_src_ovr_val      : 3;  /**< [  2:  0](R/W/H) Reserved. */
        uint32_t ctrl_src_ovr_en       : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t ctrl_div_ovr_val      : 2;  /**< [  5:  4](R/W/H) Reserved. */
        uint32_t reserved_6            : 1;
        uint32_t ctrl_div_ovr_en       : 1;  /**< [  7:  7](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_top_clock_ln1_cm0_clk_gs_mode_ctrl0_rsvd_s cn; */
};
typedef union cavm_gsercx_phy0_top_clock_ln1_cm0_clk_gs_mode_ctrl0_rsvd cavm_gsercx_phy0_top_clock_ln1_cm0_clk_gs_mode_ctrl0_rsvd_t;

static inline uint64_t CAVM_GSERCX_PHY0_TOP_CLOCK_LN1_CM0_CLK_GS_MODE_CTRL0_RSVD(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_TOP_CLOCK_LN1_CM0_CLK_GS_MODE_CTRL0_RSVD(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005970ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_TOP_CLOCK_LN1_CM0_CLK_GS_MODE_CTRL0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_TOP_CLOCK_LN1_CM0_CLK_GS_MODE_CTRL0_RSVD(a) cavm_gsercx_phy0_top_clock_ln1_cm0_clk_gs_mode_ctrl0_rsvd_t
#define bustype_CAVM_GSERCX_PHY0_TOP_CLOCK_LN1_CM0_CLK_GS_MODE_CTRL0_RSVD(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_TOP_CLOCK_LN1_CM0_CLK_GS_MODE_CTRL0_RSVD(a) "GSERCX_PHY0_TOP_CLOCK_LN1_CM0_CLK_GS_MODE_CTRL0_RSVD"
#define device_bar_CAVM_GSERCX_PHY0_TOP_CLOCK_LN1_CM0_CLK_GS_MODE_CTRL0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_TOP_CLOCK_LN1_CM0_CLK_GS_MODE_CTRL0_RSVD(a) (a)
#define arguments_CAVM_GSERCX_PHY0_TOP_CLOCK_LN1_CM0_CLK_GS_MODE_CTRL0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_clock_ln1_tx_rate
 *
 * GSERC Phy0 Top Clock Ln1 Tx Rate Register
 */
union cavm_gsercx_phy0_top_clock_ln1_tx_rate
{
    uint32_t u;
    struct cavm_gsercx_phy0_top_clock_ln1_tx_rate_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t div_sel               : 2;  /**< [  3:  2](R/W/H) 0x0 = DIV1
                                                                 0x1 = DIV2
                                                                 0x3 = DIV4
                                                                 others = reserved */
        uint32_t rate_sel              : 2;  /**< [  1:  0](R/W/H) Clock selection in Gearbox mode
                                                                 0x0 = PLL1
                                                                 0x1 = PLL2
                                                                 0x2 = PLL3
                                                                 others = reserved */
#else /* Word 0 - Little Endian */
        uint32_t rate_sel              : 2;  /**< [  1:  0](R/W/H) Clock selection in Gearbox mode
                                                                 0x0 = PLL1
                                                                 0x1 = PLL2
                                                                 0x2 = PLL3
                                                                 others = reserved */
        uint32_t div_sel               : 2;  /**< [  3:  2](R/W/H) 0x0 = DIV1
                                                                 0x1 = DIV2
                                                                 0x3 = DIV4
                                                                 others = reserved */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_top_clock_ln1_tx_rate_s cn; */
};
typedef union cavm_gsercx_phy0_top_clock_ln1_tx_rate cavm_gsercx_phy0_top_clock_ln1_tx_rate_t;

static inline uint64_t CAVM_GSERCX_PHY0_TOP_CLOCK_LN1_TX_RATE(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_TOP_CLOCK_LN1_TX_RATE(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8005940ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005940ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_TOP_CLOCK_LN1_TX_RATE", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_TOP_CLOCK_LN1_TX_RATE(a) cavm_gsercx_phy0_top_clock_ln1_tx_rate_t
#define bustype_CAVM_GSERCX_PHY0_TOP_CLOCK_LN1_TX_RATE(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_TOP_CLOCK_LN1_TX_RATE(a) "GSERCX_PHY0_TOP_CLOCK_LN1_TX_RATE"
#define device_bar_CAVM_GSERCX_PHY0_TOP_CLOCK_LN1_TX_RATE(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_TOP_CLOCK_LN1_TX_RATE(a) (a)
#define arguments_CAVM_GSERCX_PHY0_TOP_CLOCK_LN1_TX_RATE(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_dosc_temp_during_cal
 *
 * GSERC Phy0 Top Dosc Temp During Cal Register
 */
union cavm_gsercx_phy0_top_dosc_temp_during_cal
{
    uint32_t u;
    struct cavm_gsercx_phy0_top_dosc_temp_during_cal_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t temp_value            : 8;  /**< [  7:  0](R/W/H) Temperature value supplied by user. Value needs to be set to temperature + 40
                                                                 e.g. if temperature is -40Celsius then value = -40 + 40 = 0; if temperature is
                                                                 120Celsius then value = 120 + 40 = 160. */
#else /* Word 0 - Little Endian */
        uint32_t temp_value            : 8;  /**< [  7:  0](R/W/H) Temperature value supplied by user. Value needs to be set to temperature + 40
                                                                 e.g. if temperature is -40Celsius then value = -40 + 40 = 0; if temperature is
                                                                 120Celsius then value = 120 + 40 = 160. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_top_dosc_temp_during_cal_s cn; */
};
typedef union cavm_gsercx_phy0_top_dosc_temp_during_cal cavm_gsercx_phy0_top_dosc_temp_during_cal_t;

static inline uint64_t CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_DURING_CAL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_DURING_CAL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8005ec8ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005ec8ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_TOP_DOSC_TEMP_DURING_CAL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_DURING_CAL(a) cavm_gsercx_phy0_top_dosc_temp_during_cal_t
#define bustype_CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_DURING_CAL(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_DURING_CAL(a) "GSERCX_PHY0_TOP_DOSC_TEMP_DURING_CAL"
#define device_bar_CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_DURING_CAL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_DURING_CAL(a) (a)
#define arguments_CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_DURING_CAL(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_dosc_temp_range_ext_bin0_adj
 *
 * GSERC Phy0 Top Dosc Temp Range Ext Bin0 Adj Register
 */
union cavm_gsercx_phy0_top_dosc_temp_range_ext_bin0_adj
{
    uint32_t u;
    struct cavm_gsercx_phy0_top_dosc_temp_range_ext_bin0_adj_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t dosc_level_sel        : 4;  /**< [  3:  0](R/W/H) Enums for selecting a value between DOSC_TEMP_MIN and DOSC_TEMP_MAX
                                                                 0 = DOSC_CURRENT_PLUS_ONE
                                                                 1 = DOSC_CURRENT_MINUS_ONE
                                                                 2 = DOSC_MAX_ONE_FOURTH_DOWN
                                                                 3 = DOSC_MIN_ONE_FOURTH_UP
                                                                 4 = DOSC_MAX_ONE_EIGHTH_DOWN
                                                                 5 = DOSC_MIN_ONE_EIGHTH_UP
                                                                 6 = DOSC_MAX_MINUS_ONE
                                                                 7 = DOSC_MIN_PLUS_ONE
                                                                 Default value: 6 */
#else /* Word 0 - Little Endian */
        uint32_t dosc_level_sel        : 4;  /**< [  3:  0](R/W/H) Enums for selecting a value between DOSC_TEMP_MIN and DOSC_TEMP_MAX
                                                                 0 = DOSC_CURRENT_PLUS_ONE
                                                                 1 = DOSC_CURRENT_MINUS_ONE
                                                                 2 = DOSC_MAX_ONE_FOURTH_DOWN
                                                                 3 = DOSC_MIN_ONE_FOURTH_UP
                                                                 4 = DOSC_MAX_ONE_EIGHTH_DOWN
                                                                 5 = DOSC_MIN_ONE_EIGHTH_UP
                                                                 6 = DOSC_MAX_MINUS_ONE
                                                                 7 = DOSC_MIN_PLUS_ONE
                                                                 Default value: 6 */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_top_dosc_temp_range_ext_bin0_adj_s cn; */
};
typedef union cavm_gsercx_phy0_top_dosc_temp_range_ext_bin0_adj cavm_gsercx_phy0_top_dosc_temp_range_ext_bin0_adj_t;

static inline uint64_t CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN0_ADJ(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN0_ADJ(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8005ed8ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005ed8ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN0_ADJ", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN0_ADJ(a) cavm_gsercx_phy0_top_dosc_temp_range_ext_bin0_adj_t
#define bustype_CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN0_ADJ(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN0_ADJ(a) "GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN0_ADJ"
#define device_bar_CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN0_ADJ(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN0_ADJ(a) (a)
#define arguments_CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN0_ADJ(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_dosc_temp_range_ext_bin1_adj
 *
 * GSERC Phy0 Top Dosc Temp Range Ext Bin1 Adj Register
 */
union cavm_gsercx_phy0_top_dosc_temp_range_ext_bin1_adj
{
    uint32_t u;
    struct cavm_gsercx_phy0_top_dosc_temp_range_ext_bin1_adj_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t dosc_level_sel        : 4;  /**< [  3:  0](R/W/H) Enums for selecting a value between DOSC_TEMP_MIN and DOSC_TEMP_MAX
                                                                 0 = DOSC_CURRENT_PLUS_ONE
                                                                 1 = DOSC_CURRENT_MINUS_ONE
                                                                 2 = DOSC_MAX_ONE_FOURTH_DOWN
                                                                 3 = DOSC_MIN_ONE_FOURTH_UP
                                                                 4 = DOSC_MAX_ONE_EIGHTH_DOWN
                                                                 5 = DOSC_MIN_ONE_EIGHTH_UP
                                                                 6 = DOSC_MAX_MINUS_ONE
                                                                 7 = DOSC_MIN_PLUS_ONE
                                                                 Default value: 4 */
#else /* Word 0 - Little Endian */
        uint32_t dosc_level_sel        : 4;  /**< [  3:  0](R/W/H) Enums for selecting a value between DOSC_TEMP_MIN and DOSC_TEMP_MAX
                                                                 0 = DOSC_CURRENT_PLUS_ONE
                                                                 1 = DOSC_CURRENT_MINUS_ONE
                                                                 2 = DOSC_MAX_ONE_FOURTH_DOWN
                                                                 3 = DOSC_MIN_ONE_FOURTH_UP
                                                                 4 = DOSC_MAX_ONE_EIGHTH_DOWN
                                                                 5 = DOSC_MIN_ONE_EIGHTH_UP
                                                                 6 = DOSC_MAX_MINUS_ONE
                                                                 7 = DOSC_MIN_PLUS_ONE
                                                                 Default value: 4 */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_top_dosc_temp_range_ext_bin1_adj_s cn; */
};
typedef union cavm_gsercx_phy0_top_dosc_temp_range_ext_bin1_adj cavm_gsercx_phy0_top_dosc_temp_range_ext_bin1_adj_t;

static inline uint64_t CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN1_ADJ(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN1_ADJ(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8005ee0ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005ee0ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN1_ADJ", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN1_ADJ(a) cavm_gsercx_phy0_top_dosc_temp_range_ext_bin1_adj_t
#define bustype_CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN1_ADJ(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN1_ADJ(a) "GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN1_ADJ"
#define device_bar_CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN1_ADJ(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN1_ADJ(a) (a)
#define arguments_CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN1_ADJ(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_dosc_temp_range_ext_bin2_adj
 *
 * GSERC Phy0 Top Dosc Temp Range Ext Bin2 Adj Register
 */
union cavm_gsercx_phy0_top_dosc_temp_range_ext_bin2_adj
{
    uint32_t u;
    struct cavm_gsercx_phy0_top_dosc_temp_range_ext_bin2_adj_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t dosc_level_sel        : 4;  /**< [  3:  0](R/W/H) Enums for selecting a value between DOSC_TEMP_MIN and DOSC_TEMP_MAX

                                                                 0 = DOSC_CURRENT_PLUS_ONE
                                                                 1 = DOSC_CURRENT_MINUS_ONE
                                                                 2 = DOSC_MAX_ONE_FOURTH_DOWN
                                                                 3 = DOSC_MIN_ONE_FOURTH_UP
                                                                 4 = DOSC_MAX_ONE_EIGHTH_DOWN
                                                                 5 = DOSC_MIN_ONE_EIGHTH_UP
                                                                 6 = DOSC_MAX_MINUS_ONE
                                                                 7 = DOSC_MIN_PLUS_ONE
                                                                 Default value: 2 */
#else /* Word 0 - Little Endian */
        uint32_t dosc_level_sel        : 4;  /**< [  3:  0](R/W/H) Enums for selecting a value between DOSC_TEMP_MIN and DOSC_TEMP_MAX

                                                                 0 = DOSC_CURRENT_PLUS_ONE
                                                                 1 = DOSC_CURRENT_MINUS_ONE
                                                                 2 = DOSC_MAX_ONE_FOURTH_DOWN
                                                                 3 = DOSC_MIN_ONE_FOURTH_UP
                                                                 4 = DOSC_MAX_ONE_EIGHTH_DOWN
                                                                 5 = DOSC_MIN_ONE_EIGHTH_UP
                                                                 6 = DOSC_MAX_MINUS_ONE
                                                                 7 = DOSC_MIN_PLUS_ONE
                                                                 Default value: 2 */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_top_dosc_temp_range_ext_bin2_adj_s cn; */
};
typedef union cavm_gsercx_phy0_top_dosc_temp_range_ext_bin2_adj cavm_gsercx_phy0_top_dosc_temp_range_ext_bin2_adj_t;

static inline uint64_t CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN2_ADJ(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN2_ADJ(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8005ee8ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005ee8ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN2_ADJ", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN2_ADJ(a) cavm_gsercx_phy0_top_dosc_temp_range_ext_bin2_adj_t
#define bustype_CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN2_ADJ(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN2_ADJ(a) "GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN2_ADJ"
#define device_bar_CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN2_ADJ(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN2_ADJ(a) (a)
#define arguments_CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN2_ADJ(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_dosc_temp_range_ext_bin3_adj
 *
 * GSERC Phy0 Top Dosc Temp Range Ext Bin3 Adj Register
 */
union cavm_gsercx_phy0_top_dosc_temp_range_ext_bin3_adj
{
    uint32_t u;
    struct cavm_gsercx_phy0_top_dosc_temp_range_ext_bin3_adj_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t dosc_level_sel        : 4;  /**< [  3:  0](R/W/H) Enums for selecting a value between DOSC_TEMP_MIN and DOSC_TEMP_MAX
                                                                 0 = DOSC_CURRENT_PLUS_ONE
                                                                 1 = DOSC_CURRENT_MINUS_ONE
                                                                 2 = DOSC_MAX_ONE_FOURTH_DOWN
                                                                 3 = DOSC_MIN_ONE_FOURTH_UP
                                                                 4 = DOSC_MAX_ONE_EIGHTH_DOWN
                                                                 5 = DOSC_MIN_ONE_EIGHTH_UP
                                                                 6 = DOSC_MAX_MINUS_ONE
                                                                 7 = DOSC_MIN_PLUS_ONE
                                                                 Default value:0 */
#else /* Word 0 - Little Endian */
        uint32_t dosc_level_sel        : 4;  /**< [  3:  0](R/W/H) Enums for selecting a value between DOSC_TEMP_MIN and DOSC_TEMP_MAX
                                                                 0 = DOSC_CURRENT_PLUS_ONE
                                                                 1 = DOSC_CURRENT_MINUS_ONE
                                                                 2 = DOSC_MAX_ONE_FOURTH_DOWN
                                                                 3 = DOSC_MIN_ONE_FOURTH_UP
                                                                 4 = DOSC_MAX_ONE_EIGHTH_DOWN
                                                                 5 = DOSC_MIN_ONE_EIGHTH_UP
                                                                 6 = DOSC_MAX_MINUS_ONE
                                                                 7 = DOSC_MIN_PLUS_ONE
                                                                 Default value:0 */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_top_dosc_temp_range_ext_bin3_adj_s cn; */
};
typedef union cavm_gsercx_phy0_top_dosc_temp_range_ext_bin3_adj cavm_gsercx_phy0_top_dosc_temp_range_ext_bin3_adj_t;

static inline uint64_t CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN3_ADJ(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN3_ADJ(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8005ef0ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005ef0ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN3_ADJ", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN3_ADJ(a) cavm_gsercx_phy0_top_dosc_temp_range_ext_bin3_adj_t
#define bustype_CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN3_ADJ(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN3_ADJ(a) "GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN3_ADJ"
#define device_bar_CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN3_ADJ(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN3_ADJ(a) (a)
#define arguments_CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN3_ADJ(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_dosc_temp_range_ext_bin4_adj
 *
 * GSERC Phy0 Top Dosc Temp Range Ext Bin4 Adj Register
 */
union cavm_gsercx_phy0_top_dosc_temp_range_ext_bin4_adj
{
    uint32_t u;
    struct cavm_gsercx_phy0_top_dosc_temp_range_ext_bin4_adj_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t dosc_level_sel        : 4;  /**< [  3:  0](R/W/H) Enums for selecting a value between DOSC_TEMP_MIN and DOSC_TEMP_MAX
                                                                 0 = DOSC_CURRENT_PLUS_ONE
                                                                 1 = DOSC_CURRENT_MINUS_ONE
                                                                 2 = DOSC_MAX_ONE_FOURTH_DOWN
                                                                 3 = DOSC_MIN_ONE_FOURTH_UP
                                                                 4 = DOSC_MAX_ONE_EIGHTH_DOWN
                                                                 5 = DOSC_MIN_ONE_EIGHTH_UP
                                                                 6 = DOSC_MAX_MINUS_ONE
                                                                 7 = DOSC_MIN_PLUS_ONE
                                                                 Default value: 1 */
#else /* Word 0 - Little Endian */
        uint32_t dosc_level_sel        : 4;  /**< [  3:  0](R/W/H) Enums for selecting a value between DOSC_TEMP_MIN and DOSC_TEMP_MAX
                                                                 0 = DOSC_CURRENT_PLUS_ONE
                                                                 1 = DOSC_CURRENT_MINUS_ONE
                                                                 2 = DOSC_MAX_ONE_FOURTH_DOWN
                                                                 3 = DOSC_MIN_ONE_FOURTH_UP
                                                                 4 = DOSC_MAX_ONE_EIGHTH_DOWN
                                                                 5 = DOSC_MIN_ONE_EIGHTH_UP
                                                                 6 = DOSC_MAX_MINUS_ONE
                                                                 7 = DOSC_MIN_PLUS_ONE
                                                                 Default value: 1 */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_top_dosc_temp_range_ext_bin4_adj_s cn; */
};
typedef union cavm_gsercx_phy0_top_dosc_temp_range_ext_bin4_adj cavm_gsercx_phy0_top_dosc_temp_range_ext_bin4_adj_t;

static inline uint64_t CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN4_ADJ(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN4_ADJ(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8005ef8ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005ef8ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN4_ADJ", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN4_ADJ(a) cavm_gsercx_phy0_top_dosc_temp_range_ext_bin4_adj_t
#define bustype_CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN4_ADJ(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN4_ADJ(a) "GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN4_ADJ"
#define device_bar_CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN4_ADJ(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN4_ADJ(a) (a)
#define arguments_CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN4_ADJ(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_dosc_temp_range_ext_bin5_adj
 *
 * GSERC Phy0 Top Dosc Temp Range Ext Bin5 Adj Register
 */
union cavm_gsercx_phy0_top_dosc_temp_range_ext_bin5_adj
{
    uint32_t u;
    struct cavm_gsercx_phy0_top_dosc_temp_range_ext_bin5_adj_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t dosc_level_sel        : 4;  /**< [  3:  0](R/W/H) Enums for selecting a value between DOSC_TEMP_MIN and DOSC_TEMP_MAX
                                                                 0 = DOSC_CURRENT_PLUS_ONE
                                                                 1 = DOSC_CURRENT_MINUS_ONE
                                                                 2 = DOSC_MAX_ONE_FOURTH_DOWN
                                                                 3 = DOSC_MIN_ONE_FOURTH_UP
                                                                 4 = DOSC_MAX_ONE_EIGHTH_DOWN
                                                                 5 = DOSC_MIN_ONE_EIGHTH_UP
                                                                 6 = DOSC_MAX_MINUS_ONE
                                                                 7 = DOSC_MIN_PLUS_ONE
                                                                  Default value: 3 */
#else /* Word 0 - Little Endian */
        uint32_t dosc_level_sel        : 4;  /**< [  3:  0](R/W/H) Enums for selecting a value between DOSC_TEMP_MIN and DOSC_TEMP_MAX
                                                                 0 = DOSC_CURRENT_PLUS_ONE
                                                                 1 = DOSC_CURRENT_MINUS_ONE
                                                                 2 = DOSC_MAX_ONE_FOURTH_DOWN
                                                                 3 = DOSC_MIN_ONE_FOURTH_UP
                                                                 4 = DOSC_MAX_ONE_EIGHTH_DOWN
                                                                 5 = DOSC_MIN_ONE_EIGHTH_UP
                                                                 6 = DOSC_MAX_MINUS_ONE
                                                                 7 = DOSC_MIN_PLUS_ONE
                                                                  Default value: 3 */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_top_dosc_temp_range_ext_bin5_adj_s cn; */
};
typedef union cavm_gsercx_phy0_top_dosc_temp_range_ext_bin5_adj cavm_gsercx_phy0_top_dosc_temp_range_ext_bin5_adj_t;

static inline uint64_t CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN5_ADJ(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN5_ADJ(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8005f00ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005f00ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN5_ADJ", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN5_ADJ(a) cavm_gsercx_phy0_top_dosc_temp_range_ext_bin5_adj_t
#define bustype_CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN5_ADJ(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN5_ADJ(a) "GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN5_ADJ"
#define device_bar_CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN5_ADJ(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN5_ADJ(a) (a)
#define arguments_CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN5_ADJ(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_dosc_temp_range_ext_bin6_adj
 *
 * GSERC Phy0 Top Dosc Temp Range Ext Bin6 Adj Register
 */
union cavm_gsercx_phy0_top_dosc_temp_range_ext_bin6_adj
{
    uint32_t u;
    struct cavm_gsercx_phy0_top_dosc_temp_range_ext_bin6_adj_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t dosc_level_sel        : 4;  /**< [  3:  0](R/W/H) Enums for selecting a value between DOSC_TEMP_MIN and DOSC_TEMP_MAX 0: DOSC_CURRENT_PLUS_ONE
                                                                 1 = DOSC_CURRENT_MINUS_ONE
                                                                 2 = DOSC_MAX_ONE_FOURTH_DOWN
                                                                 3 = DOSC_MIN_ONE_FOURTH_UP
                                                                 4 = DOSC_MAX_ONE_EIGHTH_DOWN
                                                                 5 = DOSC_MIN_ONE_EIGHTH_UP
                                                                 6 = DOSC_MAX_MINUS_ONE
                                                                 7 = DOSC_MIN_PLUS_ONE
                                                                 Default value: 5 */
#else /* Word 0 - Little Endian */
        uint32_t dosc_level_sel        : 4;  /**< [  3:  0](R/W/H) Enums for selecting a value between DOSC_TEMP_MIN and DOSC_TEMP_MAX 0: DOSC_CURRENT_PLUS_ONE
                                                                 1 = DOSC_CURRENT_MINUS_ONE
                                                                 2 = DOSC_MAX_ONE_FOURTH_DOWN
                                                                 3 = DOSC_MIN_ONE_FOURTH_UP
                                                                 4 = DOSC_MAX_ONE_EIGHTH_DOWN
                                                                 5 = DOSC_MIN_ONE_EIGHTH_UP
                                                                 6 = DOSC_MAX_MINUS_ONE
                                                                 7 = DOSC_MIN_PLUS_ONE
                                                                 Default value: 5 */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_top_dosc_temp_range_ext_bin6_adj_s cn; */
};
typedef union cavm_gsercx_phy0_top_dosc_temp_range_ext_bin6_adj cavm_gsercx_phy0_top_dosc_temp_range_ext_bin6_adj_t;

static inline uint64_t CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN6_ADJ(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN6_ADJ(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8005f08ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005f08ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN6_ADJ", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN6_ADJ(a) cavm_gsercx_phy0_top_dosc_temp_range_ext_bin6_adj_t
#define bustype_CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN6_ADJ(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN6_ADJ(a) "GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN6_ADJ"
#define device_bar_CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN6_ADJ(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN6_ADJ(a) (a)
#define arguments_CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN6_ADJ(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_dosc_temp_range_ext_bin7_adj
 *
 * GSERC Phy0 Top Dosc Temp Range Ext Bin7 Adj Register
 */
union cavm_gsercx_phy0_top_dosc_temp_range_ext_bin7_adj
{
    uint32_t u;
    struct cavm_gsercx_phy0_top_dosc_temp_range_ext_bin7_adj_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t dosc_level_sel        : 4;  /**< [  3:  0](R/W/H) Enums for selecting a value between DOSC_TEMP_MIN and DOSC_TEMP_MAX
                                                                 0 = DOSC_CURRENT_PLUS_ONE
                                                                 1 = DOSC_CURRENT_MINUS_ONE
                                                                 2 = DOSC_MAX_ONE_FOURTH_DOWN
                                                                 3 = DOSC_MIN_ONE_FOURTH_UP
                                                                 4 = DOSC_MAX_ONE_EIGHTH_DOWN
                                                                 5 = DOSC_MIN_ONE_EIGHTH_UP
                                                                 6 = DOSC_MAX_MINUS_ONE
                                                                 7 = DOSC_MIN_PLUS_ONE
                                                                 Default value: 7 */
#else /* Word 0 - Little Endian */
        uint32_t dosc_level_sel        : 4;  /**< [  3:  0](R/W/H) Enums for selecting a value between DOSC_TEMP_MIN and DOSC_TEMP_MAX
                                                                 0 = DOSC_CURRENT_PLUS_ONE
                                                                 1 = DOSC_CURRENT_MINUS_ONE
                                                                 2 = DOSC_MAX_ONE_FOURTH_DOWN
                                                                 3 = DOSC_MIN_ONE_FOURTH_UP
                                                                 4 = DOSC_MAX_ONE_EIGHTH_DOWN
                                                                 5 = DOSC_MIN_ONE_EIGHTH_UP
                                                                 6 = DOSC_MAX_MINUS_ONE
                                                                 7 = DOSC_MIN_PLUS_ONE
                                                                 Default value: 7 */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_top_dosc_temp_range_ext_bin7_adj_s cn; */
};
typedef union cavm_gsercx_phy0_top_dosc_temp_range_ext_bin7_adj cavm_gsercx_phy0_top_dosc_temp_range_ext_bin7_adj_t;

static inline uint64_t CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN7_ADJ(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN7_ADJ(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8005f10ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005f10ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN7_ADJ", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN7_ADJ(a) cavm_gsercx_phy0_top_dosc_temp_range_ext_bin7_adj_t
#define bustype_CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN7_ADJ(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN7_ADJ(a) "GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN7_ADJ"
#define device_bar_CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN7_ADJ(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN7_ADJ(a) (a)
#define arguments_CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN7_ADJ(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_dosc_temp_range_ext_num_bins
 *
 * GSERC Phy0 Top Dosc Temp Range Ext Num Bins Register
 */
union cavm_gsercx_phy0_top_dosc_temp_range_ext_num_bins
{
    uint32_t u;
    struct cavm_gsercx_phy0_top_dosc_temp_range_ext_num_bins_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t temp_bins             : 2;  /**< [  1:  0](R/W/H) Enum for temperature bins supported: 0: 8 bins -40C to -20C; -20C to 0C; 0C to
                                                                 20C; 20C to 40C; 40C to 60C; 60C to 80C; 80C to 100C; 100C and beyond Default
                                                                 value: 0
                                                                 1 = 4 bins -40C to 10C; 11C to 60C; 61C to 110C; 111C to 165C */
#else /* Word 0 - Little Endian */
        uint32_t temp_bins             : 2;  /**< [  1:  0](R/W/H) Enum for temperature bins supported: 0: 8 bins -40C to -20C; -20C to 0C; 0C to
                                                                 20C; 20C to 40C; 40C to 60C; 60C to 80C; 80C to 100C; 100C and beyond Default
                                                                 value: 0
                                                                 1 = 4 bins -40C to 10C; 11C to 60C; 61C to 110C; 111C to 165C */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_top_dosc_temp_range_ext_num_bins_s cn; */
};
typedef union cavm_gsercx_phy0_top_dosc_temp_range_ext_num_bins cavm_gsercx_phy0_top_dosc_temp_range_ext_num_bins_t;

static inline uint64_t CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_NUM_BINS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_NUM_BINS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8005ed0ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005ed0ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_NUM_BINS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_NUM_BINS(a) cavm_gsercx_phy0_top_dosc_temp_range_ext_num_bins_t
#define bustype_CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_NUM_BINS(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_NUM_BINS(a) "GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_NUM_BINS"
#define device_bar_CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_NUM_BINS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_NUM_BINS(a) (a)
#define arguments_CAVM_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_NUM_BINS(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_err_ctrl0
 *
 * GSERC Phy0 Top Err Ctrl0 Register
 */
union cavm_gsercx_phy0_top_err_ctrl0
{
    uint32_t u;
    struct cavm_gsercx_phy0_top_err_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t err_o                 : 1;  /**< [  0:  0](R/W/H) PHY error status.
                                                                 PHY firmware sets sets this to 1 to assert PHY top-level err_o signal. */
#else /* Word 0 - Little Endian */
        uint32_t err_o                 : 1;  /**< [  0:  0](R/W/H) PHY error status.
                                                                 PHY firmware sets sets this to 1 to assert PHY top-level err_o signal. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_top_err_ctrl0_s cn; */
};
typedef union cavm_gsercx_phy0_top_err_ctrl0 cavm_gsercx_phy0_top_err_ctrl0_t;

static inline uint64_t CAVM_GSERCX_PHY0_TOP_ERR_CTRL0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_TOP_ERR_CTRL0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8005d00ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005d00ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_TOP_ERR_CTRL0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_TOP_ERR_CTRL0(a) cavm_gsercx_phy0_top_err_ctrl0_t
#define bustype_CAVM_GSERCX_PHY0_TOP_ERR_CTRL0(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_TOP_ERR_CTRL0(a) "GSERCX_PHY0_TOP_ERR_CTRL0"
#define device_bar_CAVM_GSERCX_PHY0_TOP_ERR_CTRL0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_TOP_ERR_CTRL0(a) (a)
#define arguments_CAVM_GSERCX_PHY0_TOP_ERR_CTRL0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_err_ctrl1
 *
 * GSERC Phy0 Top Err Ctrl1 Register
 */
union cavm_gsercx_phy0_top_err_ctrl1
{
    uint32_t u;
    struct cavm_gsercx_phy0_top_err_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t err_code_7_0          : 8;  /**< [  7:  0](R/W/H) PHY error status lower 8-bits of 16-bit top-level error code. 0 indicates that there is no error. */
#else /* Word 0 - Little Endian */
        uint32_t err_code_7_0          : 8;  /**< [  7:  0](R/W/H) PHY error status lower 8-bits of 16-bit top-level error code. 0 indicates that there is no error. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_top_err_ctrl1_s cn; */
};
typedef union cavm_gsercx_phy0_top_err_ctrl1 cavm_gsercx_phy0_top_err_ctrl1_t;

static inline uint64_t CAVM_GSERCX_PHY0_TOP_ERR_CTRL1(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_TOP_ERR_CTRL1(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8005d08ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005d08ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_TOP_ERR_CTRL1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_TOP_ERR_CTRL1(a) cavm_gsercx_phy0_top_err_ctrl1_t
#define bustype_CAVM_GSERCX_PHY0_TOP_ERR_CTRL1(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_TOP_ERR_CTRL1(a) "GSERCX_PHY0_TOP_ERR_CTRL1"
#define device_bar_CAVM_GSERCX_PHY0_TOP_ERR_CTRL1(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_TOP_ERR_CTRL1(a) (a)
#define arguments_CAVM_GSERCX_PHY0_TOP_ERR_CTRL1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_err_ctrl2
 *
 * GSERC Phy0 Top Err Ctrl2 Register
 */
union cavm_gsercx_phy0_top_err_ctrl2
{
    uint32_t u;
    struct cavm_gsercx_phy0_top_err_ctrl2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t err_code_15_8         : 8;  /**< [  7:  0](R/W/H) PHY error status higher 8-bits of 16-bit top-level error code. 0 indicates that there is no error. */
#else /* Word 0 - Little Endian */
        uint32_t err_code_15_8         : 8;  /**< [  7:  0](R/W/H) PHY error status higher 8-bits of 16-bit top-level error code. 0 indicates that there is no error. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_top_err_ctrl2_s cn; */
};
typedef union cavm_gsercx_phy0_top_err_ctrl2 cavm_gsercx_phy0_top_err_ctrl2_t;

static inline uint64_t CAVM_GSERCX_PHY0_TOP_ERR_CTRL2(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_TOP_ERR_CTRL2(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8005d10ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005d10ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_TOP_ERR_CTRL2", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_TOP_ERR_CTRL2(a) cavm_gsercx_phy0_top_err_ctrl2_t
#define bustype_CAVM_GSERCX_PHY0_TOP_ERR_CTRL2(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_TOP_ERR_CTRL2(a) "GSERCX_PHY0_TOP_ERR_CTRL2"
#define device_bar_CAVM_GSERCX_PHY0_TOP_ERR_CTRL2(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_TOP_ERR_CTRL2(a) (a)
#define arguments_CAVM_GSERCX_PHY0_TOP_ERR_CTRL2(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_err_status0
 *
 * GSERC Phy0 Top Err Status0 Register
 */
union cavm_gsercx_phy0_top_err_status0
{
    uint32_t u;
    struct cavm_gsercx_phy0_top_err_status0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t regbus_err            : 1;  /**< [  0:  0](R/W1C/H) Regbug error status.  Write 1 to clear. */
#else /* Word 0 - Little Endian */
        uint32_t regbus_err            : 1;  /**< [  0:  0](R/W1C/H) Regbug error status.  Write 1 to clear. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_top_err_status0_s cn; */
};
typedef union cavm_gsercx_phy0_top_err_status0 cavm_gsercx_phy0_top_err_status0_t;

static inline uint64_t CAVM_GSERCX_PHY0_TOP_ERR_STATUS0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_TOP_ERR_STATUS0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8005d28ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005d28ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_TOP_ERR_STATUS0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_TOP_ERR_STATUS0(a) cavm_gsercx_phy0_top_err_status0_t
#define bustype_CAVM_GSERCX_PHY0_TOP_ERR_STATUS0(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_TOP_ERR_STATUS0(a) "GSERCX_PHY0_TOP_ERR_STATUS0"
#define device_bar_CAVM_GSERCX_PHY0_TOP_ERR_STATUS0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_TOP_ERR_STATUS0(a) (a)
#define arguments_CAVM_GSERCX_PHY0_TOP_ERR_STATUS0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_ln0_tx_gb
 *
 * GSERC Phy0 Top Ln0 Tx Gb Register
 */
union cavm_gsercx_phy0_top_ln0_tx_gb
{
    uint32_t u;
    struct cavm_gsercx_phy0_top_ln0_tx_gb_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t ml_mode_master_en     : 1;  /**< [  3:  3](R/W/H) TX Gearbox FIFO enable; valid only when ln()_tx_gb_ml_mode = 1; default is 0. */
        uint32_t reserved_2            : 1;
        uint32_t ml_mode_master_ln     : 1;  /**< [  1:  1](R/W/H) Selects the master lane for each lane, valid only when ln()_tx_gb_ml_mode == 1;
                                                                 default is 2'b00=lane0, ... 2'b11=lane3. */
        uint32_t ml_mode               : 1;  /**< [  0:  0](R/W/H) Multi-lane mode enable; 0=independent operation; 1=multi-lane latency matching mode; default is 0. */
#else /* Word 0 - Little Endian */
        uint32_t ml_mode               : 1;  /**< [  0:  0](R/W/H) Multi-lane mode enable; 0=independent operation; 1=multi-lane latency matching mode; default is 0. */
        uint32_t ml_mode_master_ln     : 1;  /**< [  1:  1](R/W/H) Selects the master lane for each lane, valid only when ln()_tx_gb_ml_mode == 1;
                                                                 default is 2'b00=lane0, ... 2'b11=lane3. */
        uint32_t reserved_2            : 1;
        uint32_t ml_mode_master_en     : 1;  /**< [  3:  3](R/W/H) TX Gearbox FIFO enable; valid only when ln()_tx_gb_ml_mode = 1; default is 0. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_top_ln0_tx_gb_s cn; */
};
typedef union cavm_gsercx_phy0_top_ln0_tx_gb cavm_gsercx_phy0_top_ln0_tx_gb_t;

static inline uint64_t CAVM_GSERCX_PHY0_TOP_LN0_TX_GB(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_TOP_LN0_TX_GB(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8005f28ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005f28ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_TOP_LN0_TX_GB", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_TOP_LN0_TX_GB(a) cavm_gsercx_phy0_top_ln0_tx_gb_t
#define bustype_CAVM_GSERCX_PHY0_TOP_LN0_TX_GB(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_TOP_LN0_TX_GB(a) "GSERCX_PHY0_TOP_LN0_TX_GB"
#define device_bar_CAVM_GSERCX_PHY0_TOP_LN0_TX_GB(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_TOP_LN0_TX_GB(a) (a)
#define arguments_CAVM_GSERCX_PHY0_TOP_LN0_TX_GB(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_ln1_tx_gb
 *
 * GSERC Phy0 Top Ln1 Tx Gb Register
 */
union cavm_gsercx_phy0_top_ln1_tx_gb
{
    uint32_t u;
    struct cavm_gsercx_phy0_top_ln1_tx_gb_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t ml_mode_master_en     : 1;  /**< [  3:  3](R/W/H) TX Gearbox FIFO enable; valid only when ln()_tx_gb_ml_mode = 1; default is 0. */
        uint32_t reserved_2            : 1;
        uint32_t ml_mode_master_ln     : 1;  /**< [  1:  1](R/W/H) Selects the master lane for each lane, valid only when ln()_tx_gb_ml_mode == 1;
                                                                 default is 2'b00=lane0, ... 2'b11=lane3. */
        uint32_t ml_mode               : 1;  /**< [  0:  0](R/W/H) Multi-lane mode enable; 0=independent operation; 1=multi-lane latency matching mode; default is 0. */
#else /* Word 0 - Little Endian */
        uint32_t ml_mode               : 1;  /**< [  0:  0](R/W/H) Multi-lane mode enable; 0=independent operation; 1=multi-lane latency matching mode; default is 0. */
        uint32_t ml_mode_master_ln     : 1;  /**< [  1:  1](R/W/H) Selects the master lane for each lane, valid only when ln()_tx_gb_ml_mode == 1;
                                                                 default is 2'b00=lane0, ... 2'b11=lane3. */
        uint32_t reserved_2            : 1;
        uint32_t ml_mode_master_en     : 1;  /**< [  3:  3](R/W/H) TX Gearbox FIFO enable; valid only when ln()_tx_gb_ml_mode = 1; default is 0. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_top_ln1_tx_gb_s cn; */
};
typedef union cavm_gsercx_phy0_top_ln1_tx_gb cavm_gsercx_phy0_top_ln1_tx_gb_t;

static inline uint64_t CAVM_GSERCX_PHY0_TOP_LN1_TX_GB(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_TOP_LN1_TX_GB(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8005f30ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005f30ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_TOP_LN1_TX_GB", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_TOP_LN1_TX_GB(a) cavm_gsercx_phy0_top_ln1_tx_gb_t
#define bustype_CAVM_GSERCX_PHY0_TOP_LN1_TX_GB(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_TOP_LN1_TX_GB(a) "GSERCX_PHY0_TOP_LN1_TX_GB"
#define device_bar_CAVM_GSERCX_PHY0_TOP_LN1_TX_GB(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_TOP_LN1_TX_GB(a) (a)
#define arguments_CAVM_GSERCX_PHY0_TOP_LN1_TX_GB(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_phy_cfg0
 *
 * GSERC Phy0 Top Phy Cfg0 Register
 */
union cavm_gsercx_phy0_top_phy_cfg0
{
    uint32_t u;
    struct cavm_gsercx_phy0_top_phy_cfg0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t cpu_clk_freq          : 8;  /**< [  7:  0](R/W/H) CPU clock frequency in units of 10 MHz. */
#else /* Word 0 - Little Endian */
        uint32_t cpu_clk_freq          : 8;  /**< [  7:  0](R/W/H) CPU clock frequency in units of 10 MHz. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_top_phy_cfg0_s cn; */
};
typedef union cavm_gsercx_phy0_top_phy_cfg0 cavm_gsercx_phy0_top_phy_cfg0_t;

static inline uint64_t CAVM_GSERCX_PHY0_TOP_PHY_CFG0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_TOP_PHY_CFG0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8005100ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005100ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_TOP_PHY_CFG0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_TOP_PHY_CFG0(a) cavm_gsercx_phy0_top_phy_cfg0_t
#define bustype_CAVM_GSERCX_PHY0_TOP_PHY_CFG0(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_TOP_PHY_CFG0(a) "GSERCX_PHY0_TOP_PHY_CFG0"
#define device_bar_CAVM_GSERCX_PHY0_TOP_PHY_CFG0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_TOP_PHY_CFG0(a) (a)
#define arguments_CAVM_GSERCX_PHY0_TOP_PHY_CFG0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_phy_ctrl5
 *
 * GSERC Phy0 Top Phy Ctrl5 Register
 */
union cavm_gsercx_phy0_top_phy_ctrl5
{
    uint32_t u;
    struct cavm_gsercx_phy0_top_phy_ctrl5_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t phy_rext_ovr_en       : 1;  /**< [  7:  7](R/W/H) Override enable for HSS_PHY_REXT_*_I HSS_PHY_REXT_MASTER_I, HSS_PHY_REXT_READY_I
                                                                 and HSS_PHY_REXT_TRIM_I . */
        uint32_t reserved_2_6          : 5;
        uint32_t phy_rext_ready_ovr_val : 1; /**< [  1:  1](R/W/H) Override value for HSS_PHY_REXT_READY_I in case hardwired tie off is incorrectly done. */
        uint32_t phy_rext_master_ovr_val : 1;/**< [  0:  0](R/W/H) Override value for HSS_PHY_REXT_MASTER_I in case hardwired tie off is incorrectly done. */
#else /* Word 0 - Little Endian */
        uint32_t phy_rext_master_ovr_val : 1;/**< [  0:  0](R/W/H) Override value for HSS_PHY_REXT_MASTER_I in case hardwired tie off is incorrectly done. */
        uint32_t phy_rext_ready_ovr_val : 1; /**< [  1:  1](R/W/H) Override value for HSS_PHY_REXT_READY_I in case hardwired tie off is incorrectly done. */
        uint32_t reserved_2_6          : 5;
        uint32_t phy_rext_ovr_en       : 1;  /**< [  7:  7](R/W/H) Override enable for HSS_PHY_REXT_*_I HSS_PHY_REXT_MASTER_I, HSS_PHY_REXT_READY_I
                                                                 and HSS_PHY_REXT_TRIM_I . */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_top_phy_ctrl5_s cn; */
};
typedef union cavm_gsercx_phy0_top_phy_ctrl5 cavm_gsercx_phy0_top_phy_ctrl5_t;

static inline uint64_t CAVM_GSERCX_PHY0_TOP_PHY_CTRL5(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_TOP_PHY_CTRL5(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a80050b0ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80050b0ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_TOP_PHY_CTRL5", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_TOP_PHY_CTRL5(a) cavm_gsercx_phy0_top_phy_ctrl5_t
#define bustype_CAVM_GSERCX_PHY0_TOP_PHY_CTRL5(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_TOP_PHY_CTRL5(a) "GSERCX_PHY0_TOP_PHY_CTRL5"
#define device_bar_CAVM_GSERCX_PHY0_TOP_PHY_CTRL5(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_TOP_PHY_CTRL5(a) (a)
#define arguments_CAVM_GSERCX_PHY0_TOP_PHY_CTRL5(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_phy_ctrl6
 *
 * GSERC Phy0 Top Phy Ctrl6 Register
 */
union cavm_gsercx_phy0_top_phy_ctrl6
{
    uint32_t u;
    struct cavm_gsercx_phy0_top_phy_ctrl6_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t phy_rext_trim_ovr_val : 8;  /**< [  7:  0](R/W/H) Override value for HSS_PHY_REXT_TRIM_I in case hardwired tie off is incorrectly done. */
#else /* Word 0 - Little Endian */
        uint32_t phy_rext_trim_ovr_val : 8;  /**< [  7:  0](R/W/H) Override value for HSS_PHY_REXT_TRIM_I in case hardwired tie off is incorrectly done. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_top_phy_ctrl6_s cn; */
};
typedef union cavm_gsercx_phy0_top_phy_ctrl6 cavm_gsercx_phy0_top_phy_ctrl6_t;

static inline uint64_t CAVM_GSERCX_PHY0_TOP_PHY_CTRL6(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_TOP_PHY_CTRL6(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a80050b8ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80050b8ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_TOP_PHY_CTRL6", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_TOP_PHY_CTRL6(a) cavm_gsercx_phy0_top_phy_ctrl6_t
#define bustype_CAVM_GSERCX_PHY0_TOP_PHY_CTRL6(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_TOP_PHY_CTRL6(a) "GSERCX_PHY0_TOP_PHY_CTRL6"
#define device_bar_CAVM_GSERCX_PHY0_TOP_PHY_CTRL6(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_TOP_PHY_CTRL6(a) (a)
#define arguments_CAVM_GSERCX_PHY0_TOP_PHY_CTRL6(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_phy_ctrl7
 *
 * GSERC Phy0 Top Phy Ctrl7 Register
 */
union cavm_gsercx_phy0_top_phy_ctrl7
{
    uint32_t u;
    struct cavm_gsercx_phy0_top_phy_ctrl7_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t phy_ctrl_vddha_sel_ovr_en : 1;/**< [  7:  7](R/W/H) Override enable for HSS_PHY_CTRL_VDDHA_SEL_I. */
        uint32_t phy_ctrl_vdda_sel_ovr_en : 1;/**< [  6:  6](R/W/H) Override enable for HSS_PHY_CTRL_VDDA_SEL_I. */
        uint32_t reserved_2_5          : 4;
        uint32_t phy_ctrl_vddha_sel_ovr_val : 1;/**< [  1:  1](R/W/H) Override value for HSS_PHY_CTRL_VDDHA_SEL_I in case hardwired tie off is incorrectly done. */
        uint32_t phy_ctrl_vdda_sel_ovr_val : 1;/**< [  0:  0](R/W/H) Override value for HSS_PHY_CTRL_VDDA_SEL_I in case hardwired tie off is incorrectly done. */
#else /* Word 0 - Little Endian */
        uint32_t phy_ctrl_vdda_sel_ovr_val : 1;/**< [  0:  0](R/W/H) Override value for HSS_PHY_CTRL_VDDA_SEL_I in case hardwired tie off is incorrectly done. */
        uint32_t phy_ctrl_vddha_sel_ovr_val : 1;/**< [  1:  1](R/W/H) Override value for HSS_PHY_CTRL_VDDHA_SEL_I in case hardwired tie off is incorrectly done. */
        uint32_t reserved_2_5          : 4;
        uint32_t phy_ctrl_vdda_sel_ovr_en : 1;/**< [  6:  6](R/W/H) Override enable for HSS_PHY_CTRL_VDDA_SEL_I. */
        uint32_t phy_ctrl_vddha_sel_ovr_en : 1;/**< [  7:  7](R/W/H) Override enable for HSS_PHY_CTRL_VDDHA_SEL_I. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_top_phy_ctrl7_s cn; */
};
typedef union cavm_gsercx_phy0_top_phy_ctrl7 cavm_gsercx_phy0_top_phy_ctrl7_t;

static inline uint64_t CAVM_GSERCX_PHY0_TOP_PHY_CTRL7(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_TOP_PHY_CTRL7(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a80050c0ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80050c0ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_TOP_PHY_CTRL7", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_TOP_PHY_CTRL7(a) cavm_gsercx_phy0_top_phy_ctrl7_t
#define bustype_CAVM_GSERCX_PHY0_TOP_PHY_CTRL7(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_TOP_PHY_CTRL7(a) "GSERCX_PHY0_TOP_PHY_CTRL7"
#define device_bar_CAVM_GSERCX_PHY0_TOP_PHY_CTRL7(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_TOP_PHY_CTRL7(a) (a)
#define arguments_CAVM_GSERCX_PHY0_TOP_PHY_CTRL7(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_regbus_err_info_ctrl
 *
 * GSERC Phy0 Top Regbus Err Info Ctrl Register
 */
union cavm_gsercx_phy0_top_regbus_err_info_ctrl
{
    uint32_t u;
    struct cavm_gsercx_phy0_top_regbus_err_info_ctrl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t clr                   : 1;  /**< [  0:  0](R/W/H) Regbus error information clear.
                                                                 Write 1 to clear the debug info presented in REGBUS_ERR_INFO_STATUS* registers. */
#else /* Word 0 - Little Endian */
        uint32_t clr                   : 1;  /**< [  0:  0](R/W/H) Regbus error information clear.
                                                                 Write 1 to clear the debug info presented in REGBUS_ERR_INFO_STATUS* registers. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_top_regbus_err_info_ctrl_s cn; */
};
typedef union cavm_gsercx_phy0_top_regbus_err_info_ctrl cavm_gsercx_phy0_top_regbus_err_info_ctrl_t;

static inline uint64_t CAVM_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_CTRL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_CTRL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8005d38ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005d38ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_TOP_REGBUS_ERR_INFO_CTRL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_CTRL(a) cavm_gsercx_phy0_top_regbus_err_info_ctrl_t
#define bustype_CAVM_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_CTRL(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_CTRL(a) "GSERCX_PHY0_TOP_REGBUS_ERR_INFO_CTRL"
#define device_bar_CAVM_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_CTRL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_CTRL(a) (a)
#define arguments_CAVM_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_CTRL(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_regbus_err_info_status0
 *
 * GSERC Phy0 Top Regbus Err Info Status0 Register
 */
union cavm_gsercx_phy0_top_regbus_err_info_status0
{
    uint32_t u;
    struct cavm_gsercx_phy0_top_regbus_err_info_status0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t transfer_rw           : 1;  /**< [  2:  2](RO/H) Regbus error information errored register transfer type:
                                                                 0 = read transfer
                                                                 1 = write transfer */
        uint32_t err_type              : 2;  /**< [  1:  0](RO/H) Regbus error information type of error:
                                                                 1 = err ack
                                                                 2 = timeout */
#else /* Word 0 - Little Endian */
        uint32_t err_type              : 2;  /**< [  1:  0](RO/H) Regbus error information type of error:
                                                                 1 = err ack
                                                                 2 = timeout */
        uint32_t transfer_rw           : 1;  /**< [  2:  2](RO/H) Regbus error information errored register transfer type:
                                                                 0 = read transfer
                                                                 1 = write transfer */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_top_regbus_err_info_status0_s cn; */
};
typedef union cavm_gsercx_phy0_top_regbus_err_info_status0 cavm_gsercx_phy0_top_regbus_err_info_status0_t;

static inline uint64_t CAVM_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8005d40ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005d40ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS0(a) cavm_gsercx_phy0_top_regbus_err_info_status0_t
#define bustype_CAVM_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS0(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS0(a) "GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS0"
#define device_bar_CAVM_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS0(a) (a)
#define arguments_CAVM_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_regbus_err_info_status1
 *
 * GSERC Phy0 Top Regbus Err Info Status1 Register
 */
union cavm_gsercx_phy0_top_regbus_err_info_status1
{
    uint32_t u;
    struct cavm_gsercx_phy0_top_regbus_err_info_status1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t transfer_addr_lsb     : 8;  /**< [  7:  0](RO/H) Regbus error information errored register transfer address lower bits. */
#else /* Word 0 - Little Endian */
        uint32_t transfer_addr_lsb     : 8;  /**< [  7:  0](RO/H) Regbus error information errored register transfer address lower bits. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_top_regbus_err_info_status1_s cn; */
};
typedef union cavm_gsercx_phy0_top_regbus_err_info_status1 cavm_gsercx_phy0_top_regbus_err_info_status1_t;

static inline uint64_t CAVM_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS1(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS1(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8005d48ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005d48ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS1(a) cavm_gsercx_phy0_top_regbus_err_info_status1_t
#define bustype_CAVM_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS1(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS1(a) "GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS1"
#define device_bar_CAVM_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS1(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS1(a) (a)
#define arguments_CAVM_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_regbus_err_info_status2
 *
 * GSERC Phy0 Top Regbus Err Info Status2 Register
 */
union cavm_gsercx_phy0_top_regbus_err_info_status2
{
    uint32_t u;
    struct cavm_gsercx_phy0_top_regbus_err_info_status2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t transfer_addr_msb     : 8;  /**< [  7:  0](RO/H) Regbus error information errored register transfer address upper bits. */
#else /* Word 0 - Little Endian */
        uint32_t transfer_addr_msb     : 8;  /**< [  7:  0](RO/H) Regbus error information errored register transfer address upper bits. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_top_regbus_err_info_status2_s cn; */
};
typedef union cavm_gsercx_phy0_top_regbus_err_info_status2 cavm_gsercx_phy0_top_regbus_err_info_status2_t;

static inline uint64_t CAVM_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS2(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS2(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8005d50ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005d50ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS2", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS2(a) cavm_gsercx_phy0_top_regbus_err_info_status2_t
#define bustype_CAVM_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS2(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS2(a) "GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS2"
#define device_bar_CAVM_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS2(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS2(a) (a)
#define arguments_CAVM_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS2(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_regbus_err_info_status3
 *
 * GSERC Phy0 Top Regbus Err Info Status3 Register
 */
union cavm_gsercx_phy0_top_regbus_err_info_status3
{
    uint32_t u;
    struct cavm_gsercx_phy0_top_regbus_err_info_status3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t transfer_wd           : 8;  /**< [  7:  0](RO/H) Regbus error information errored register transfer write data. */
#else /* Word 0 - Little Endian */
        uint32_t transfer_wd           : 8;  /**< [  7:  0](RO/H) Regbus error information errored register transfer write data. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_top_regbus_err_info_status3_s cn; */
};
typedef union cavm_gsercx_phy0_top_regbus_err_info_status3 cavm_gsercx_phy0_top_regbus_err_info_status3_t;

static inline uint64_t CAVM_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS3(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS3(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8005d58ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005d58ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS3", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS3(a) cavm_gsercx_phy0_top_regbus_err_info_status3_t
#define bustype_CAVM_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS3(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS3(a) "GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS3"
#define device_bar_CAVM_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS3(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS3(a) (a)
#define arguments_CAVM_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS3(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_regbus_err_info_status4
 *
 * GSERC Phy0 Top Regbus Err Info Status4 Register
 */
union cavm_gsercx_phy0_top_regbus_err_info_status4
{
    uint32_t u;
    struct cavm_gsercx_phy0_top_regbus_err_info_status4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t transfer_wr_bit_en    : 8;  /**< [  7:  0](RO/H) Regbus error information register transfer write data bit enable. */
#else /* Word 0 - Little Endian */
        uint32_t transfer_wr_bit_en    : 8;  /**< [  7:  0](RO/H) Regbus error information register transfer write data bit enable. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_top_regbus_err_info_status4_s cn; */
};
typedef union cavm_gsercx_phy0_top_regbus_err_info_status4 cavm_gsercx_phy0_top_regbus_err_info_status4_t;

static inline uint64_t CAVM_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS4(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS4(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8005d60ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005d60ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS4", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS4(a) cavm_gsercx_phy0_top_regbus_err_info_status4_t
#define bustype_CAVM_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS4(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS4(a) "GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS4"
#define device_bar_CAVM_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS4(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS4(a) (a)
#define arguments_CAVM_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS4(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_reset_ctrl_ln0_rsvd
 *
 * GSERC Phy0 Top Reset Ctrl Ln0 Register
 */
union cavm_gsercx_phy0_top_reset_ctrl_ln0_rsvd
{
    uint32_t u;
    struct cavm_gsercx_phy0_top_reset_ctrl_ln0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t cal_sw_reset          : 1;  /**< [  6:  6](R/W/H) Reserved. */
        uint32_t los_sw_reset          : 1;  /**< [  5:  5](R/W/H) Reserved. */
        uint32_t rxdp_sw_reset         : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t txdp_sw_reset         : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t subcore_sw_reset      : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t reg_sw_reset          : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t core_sw_reset         : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t core_sw_reset         : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reg_sw_reset          : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t subcore_sw_reset      : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t txdp_sw_reset         : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t rxdp_sw_reset         : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t los_sw_reset          : 1;  /**< [  5:  5](R/W/H) Reserved. */
        uint32_t cal_sw_reset          : 1;  /**< [  6:  6](R/W/H) Reserved. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_top_reset_ctrl_ln0_rsvd_s cn; */
};
typedef union cavm_gsercx_phy0_top_reset_ctrl_ln0_rsvd cavm_gsercx_phy0_top_reset_ctrl_ln0_rsvd_t;

static inline uint64_t CAVM_GSERCX_PHY0_TOP_RESET_CTRL_LN0_RSVD(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_TOP_RESET_CTRL_LN0_RSVD(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80052a0ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_TOP_RESET_CTRL_LN0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_TOP_RESET_CTRL_LN0_RSVD(a) cavm_gsercx_phy0_top_reset_ctrl_ln0_rsvd_t
#define bustype_CAVM_GSERCX_PHY0_TOP_RESET_CTRL_LN0_RSVD(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_TOP_RESET_CTRL_LN0_RSVD(a) "GSERCX_PHY0_TOP_RESET_CTRL_LN0_RSVD"
#define device_bar_CAVM_GSERCX_PHY0_TOP_RESET_CTRL_LN0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_TOP_RESET_CTRL_LN0_RSVD(a) (a)
#define arguments_CAVM_GSERCX_PHY0_TOP_RESET_CTRL_LN0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_reset_ctrl_ln1_rsvd
 *
 * GSERC Phy0 Top Reset Ctrl Ln1 Register
 */
union cavm_gsercx_phy0_top_reset_ctrl_ln1_rsvd
{
    uint32_t u;
    struct cavm_gsercx_phy0_top_reset_ctrl_ln1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t cal_sw_reset          : 1;  /**< [  6:  6](R/W/H) Reserved. */
        uint32_t los_sw_reset          : 1;  /**< [  5:  5](R/W/H) Reserved. */
        uint32_t rxdp_sw_reset         : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t txdp_sw_reset         : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t subcore_sw_reset      : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t reg_sw_reset          : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t core_sw_reset         : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t core_sw_reset         : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reg_sw_reset          : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t subcore_sw_reset      : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t txdp_sw_reset         : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t rxdp_sw_reset         : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t los_sw_reset          : 1;  /**< [  5:  5](R/W/H) Reserved. */
        uint32_t cal_sw_reset          : 1;  /**< [  6:  6](R/W/H) Reserved. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_top_reset_ctrl_ln1_rsvd_s cn; */
};
typedef union cavm_gsercx_phy0_top_reset_ctrl_ln1_rsvd cavm_gsercx_phy0_top_reset_ctrl_ln1_rsvd_t;

static inline uint64_t CAVM_GSERCX_PHY0_TOP_RESET_CTRL_LN1_RSVD(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_TOP_RESET_CTRL_LN1_RSVD(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80052a8ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_TOP_RESET_CTRL_LN1_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_TOP_RESET_CTRL_LN1_RSVD(a) cavm_gsercx_phy0_top_reset_ctrl_ln1_rsvd_t
#define bustype_CAVM_GSERCX_PHY0_TOP_RESET_CTRL_LN1_RSVD(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_TOP_RESET_CTRL_LN1_RSVD(a) "GSERCX_PHY0_TOP_RESET_CTRL_LN1_RSVD"
#define device_bar_CAVM_GSERCX_PHY0_TOP_RESET_CTRL_LN1_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_TOP_RESET_CTRL_LN1_RSVD(a) (a)
#define arguments_CAVM_GSERCX_PHY0_TOP_RESET_CTRL_LN1_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_sim_ctrl
 *
 * GSERC Phy0 Top Sim Ctrl Register
 */
union cavm_gsercx_phy0_top_sim_ctrl
{
    uint32_t u;
    struct cavm_gsercx_phy0_top_sim_ctrl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t sv_real_model         : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t fast_sim              : 3;  /**< [  3:  1](R/W/H) For simulation use only.  Do not touch this register when working with physical PHY.
                                                                 Set to enable simulation time optimizations in the firmware. Do not set on actual silicon.
                                                                 0 = No fast sim optimizations enabled
                                                                 1 = fast_sim optimizations enabled
                                                                 others = reserved */
        uint32_t sim_1b_model          : 1;  /**< [  0:  0](R/W/H) For simulation use only.  Do not touch this register when working with physical PHY.
                                                                 Set if running a 1b simulation.  Firmware may check this field to discover its
                                                                 runtime context.  Do not set on actual silicon. */
#else /* Word 0 - Little Endian */
        uint32_t sim_1b_model          : 1;  /**< [  0:  0](R/W/H) For simulation use only.  Do not touch this register when working with physical PHY.
                                                                 Set if running a 1b simulation.  Firmware may check this field to discover its
                                                                 runtime context.  Do not set on actual silicon. */
        uint32_t fast_sim              : 3;  /**< [  3:  1](R/W/H) For simulation use only.  Do not touch this register when working with physical PHY.
                                                                 Set to enable simulation time optimizations in the firmware. Do not set on actual silicon.
                                                                 0 = No fast sim optimizations enabled
                                                                 1 = fast_sim optimizations enabled
                                                                 others = reserved */
        uint32_t sv_real_model         : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_top_sim_ctrl_s cn; */
};
typedef union cavm_gsercx_phy0_top_sim_ctrl cavm_gsercx_phy0_top_sim_ctrl_t;

static inline uint64_t CAVM_GSERCX_PHY0_TOP_SIM_CTRL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_TOP_SIM_CTRL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8005e80ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005e80ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_TOP_SIM_CTRL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_TOP_SIM_CTRL(a) cavm_gsercx_phy0_top_sim_ctrl_t
#define bustype_CAVM_GSERCX_PHY0_TOP_SIM_CTRL(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_TOP_SIM_CTRL(a) "GSERCX_PHY0_TOP_SIM_CTRL"
#define device_bar_CAVM_GSERCX_PHY0_TOP_SIM_CTRL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_TOP_SIM_CTRL(a) (a)
#define arguments_CAVM_GSERCX_PHY0_TOP_SIM_CTRL(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_tbus_addr_15_8
 *
 * GSERC Phy0 Top Tbus Addr 15 8 Register
 */
union cavm_gsercx_phy0_top_tbus_addr_15_8
{
    uint32_t u;
    struct cavm_gsercx_phy0_top_tbus_addr_15_8_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Digital test bus TBUS upper 8-bits of the 16-bit address. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Digital test bus TBUS upper 8-bits of the 16-bit address. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_top_tbus_addr_15_8_s cn; */
};
typedef union cavm_gsercx_phy0_top_tbus_addr_15_8 cavm_gsercx_phy0_top_tbus_addr_15_8_t;

static inline uint64_t CAVM_GSERCX_PHY0_TOP_TBUS_ADDR_15_8(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_TOP_TBUS_ADDR_15_8(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8005d88ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005d88ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_TOP_TBUS_ADDR_15_8", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_TOP_TBUS_ADDR_15_8(a) cavm_gsercx_phy0_top_tbus_addr_15_8_t
#define bustype_CAVM_GSERCX_PHY0_TOP_TBUS_ADDR_15_8(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_TOP_TBUS_ADDR_15_8(a) "GSERCX_PHY0_TOP_TBUS_ADDR_15_8"
#define device_bar_CAVM_GSERCX_PHY0_TOP_TBUS_ADDR_15_8(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_TOP_TBUS_ADDR_15_8(a) (a)
#define arguments_CAVM_GSERCX_PHY0_TOP_TBUS_ADDR_15_8(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_tbus_addr_7_0
 *
 * GSERC Phy0 Top Tbus Addr 7 0 Register
 */
union cavm_gsercx_phy0_top_tbus_addr_7_0
{
    uint32_t u;
    struct cavm_gsercx_phy0_top_tbus_addr_7_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Digital test bus TBUS lower 8-bits of the 16-bit address. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Digital test bus TBUS lower 8-bits of the 16-bit address. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_top_tbus_addr_7_0_s cn; */
};
typedef union cavm_gsercx_phy0_top_tbus_addr_7_0 cavm_gsercx_phy0_top_tbus_addr_7_0_t;

static inline uint64_t CAVM_GSERCX_PHY0_TOP_TBUS_ADDR_7_0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_TOP_TBUS_ADDR_7_0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8005d80ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005d80ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_TOP_TBUS_ADDR_7_0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_TOP_TBUS_ADDR_7_0(a) cavm_gsercx_phy0_top_tbus_addr_7_0_t
#define bustype_CAVM_GSERCX_PHY0_TOP_TBUS_ADDR_7_0(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_TOP_TBUS_ADDR_7_0(a) "GSERCX_PHY0_TOP_TBUS_ADDR_7_0"
#define device_bar_CAVM_GSERCX_PHY0_TOP_TBUS_ADDR_7_0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_TOP_TBUS_ADDR_7_0(a) (a)
#define arguments_CAVM_GSERCX_PHY0_TOP_TBUS_ADDR_7_0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_tbus_ctrl0
 *
 * GSERC Phy0 Top Tbus Ctrl0 Register
 */
union cavm_gsercx_phy0_top_tbus_ctrl0
{
    uint32_t u;
    struct cavm_gsercx_phy0_top_tbus_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t clock_gate0           : 8;  /**< [  7:  0](R/W/H) Digital test bus TBUS clock gating enable for clocks going to TBUS. */
#else /* Word 0 - Little Endian */
        uint32_t clock_gate0           : 8;  /**< [  7:  0](R/W/H) Digital test bus TBUS clock gating enable for clocks going to TBUS. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_top_tbus_ctrl0_s cn; */
};
typedef union cavm_gsercx_phy0_top_tbus_ctrl0 cavm_gsercx_phy0_top_tbus_ctrl0_t;

static inline uint64_t CAVM_GSERCX_PHY0_TOP_TBUS_CTRL0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_TOP_TBUS_CTRL0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8005d90ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005d90ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_TOP_TBUS_CTRL0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_TOP_TBUS_CTRL0(a) cavm_gsercx_phy0_top_tbus_ctrl0_t
#define bustype_CAVM_GSERCX_PHY0_TOP_TBUS_CTRL0(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_TOP_TBUS_CTRL0(a) "GSERCX_PHY0_TOP_TBUS_CTRL0"
#define device_bar_CAVM_GSERCX_PHY0_TOP_TBUS_CTRL0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_TOP_TBUS_CTRL0(a) (a)
#define arguments_CAVM_GSERCX_PHY0_TOP_TBUS_CTRL0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_tbus_ctrl1
 *
 * GSERC Phy0 Top Tbus Ctrl1 Register
 */
union cavm_gsercx_phy0_top_tbus_ctrl1
{
    uint32_t u;
    struct cavm_gsercx_phy0_top_tbus_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t clock_gate1           : 4;  /**< [  3:  0](R/W/H) Digital test bus TBUS clock gating enable for clocks going to TBUS. */
#else /* Word 0 - Little Endian */
        uint32_t clock_gate1           : 4;  /**< [  3:  0](R/W/H) Digital test bus TBUS clock gating enable for clocks going to TBUS. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_top_tbus_ctrl1_s cn; */
};
typedef union cavm_gsercx_phy0_top_tbus_ctrl1 cavm_gsercx_phy0_top_tbus_ctrl1_t;

static inline uint64_t CAVM_GSERCX_PHY0_TOP_TBUS_CTRL1(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_TOP_TBUS_CTRL1(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8005d98ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005d98ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_TOP_TBUS_CTRL1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_TOP_TBUS_CTRL1(a) cavm_gsercx_phy0_top_tbus_ctrl1_t
#define bustype_CAVM_GSERCX_PHY0_TOP_TBUS_CTRL1(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_TOP_TBUS_CTRL1(a) "GSERCX_PHY0_TOP_TBUS_CTRL1"
#define device_bar_CAVM_GSERCX_PHY0_TOP_TBUS_CTRL1(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_TOP_TBUS_CTRL1(a) (a)
#define arguments_CAVM_GSERCX_PHY0_TOP_TBUS_CTRL1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_tbus_data_11_8
 *
 * GSERC Phy0 Top Tbus Data 11 8 Register
 */
union cavm_gsercx_phy0_top_tbus_data_11_8
{
    uint32_t u;
    struct cavm_gsercx_phy0_top_tbus_data_11_8_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t data                  : 4;  /**< [  3:  0](RO/H) Digital test bus TBUS output bits [11:8]. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 4;  /**< [  3:  0](RO/H) Digital test bus TBUS output bits [11:8]. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_top_tbus_data_11_8_s cn; */
};
typedef union cavm_gsercx_phy0_top_tbus_data_11_8 cavm_gsercx_phy0_top_tbus_data_11_8_t;

static inline uint64_t CAVM_GSERCX_PHY0_TOP_TBUS_DATA_11_8(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_TOP_TBUS_DATA_11_8(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8005e08ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005e08ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_TOP_TBUS_DATA_11_8", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_TOP_TBUS_DATA_11_8(a) cavm_gsercx_phy0_top_tbus_data_11_8_t
#define bustype_CAVM_GSERCX_PHY0_TOP_TBUS_DATA_11_8(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_TOP_TBUS_DATA_11_8(a) "GSERCX_PHY0_TOP_TBUS_DATA_11_8"
#define device_bar_CAVM_GSERCX_PHY0_TOP_TBUS_DATA_11_8(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_TOP_TBUS_DATA_11_8(a) (a)
#define arguments_CAVM_GSERCX_PHY0_TOP_TBUS_DATA_11_8(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_tbus_data_7_0
 *
 * GSERC Phy0 Top Tbus Data 7 0 Register
 */
union cavm_gsercx_phy0_top_tbus_data_7_0
{
    uint32_t u;
    struct cavm_gsercx_phy0_top_tbus_data_7_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](RO/H) Digital test bus TBUS output bits [7:0]. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](RO/H) Digital test bus TBUS output bits [7:0]. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_phy0_top_tbus_data_7_0_s cn; */
};
typedef union cavm_gsercx_phy0_top_tbus_data_7_0 cavm_gsercx_phy0_top_tbus_data_7_0_t;

static inline uint64_t CAVM_GSERCX_PHY0_TOP_TBUS_DATA_7_0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PHY0_TOP_TBUS_DATA_7_0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8005e00ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005e00ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_PHY0_TOP_TBUS_DATA_7_0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PHY0_TOP_TBUS_DATA_7_0(a) cavm_gsercx_phy0_top_tbus_data_7_0_t
#define bustype_CAVM_GSERCX_PHY0_TOP_TBUS_DATA_7_0(a) CSR_TYPE_RSL32b
#define basename_CAVM_GSERCX_PHY0_TOP_TBUS_DATA_7_0(a) "GSERCX_PHY0_TOP_TBUS_DATA_7_0"
#define device_bar_CAVM_GSERCX_PHY0_TOP_TBUS_DATA_7_0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PHY0_TOP_TBUS_DATA_7_0(a) (a)
#define arguments_CAVM_GSERCX_PHY0_TOP_TBUS_DATA_7_0(a) (a),-1,-1,-1

/**
 * Register (RSL) gserc#_pmem#
 *
 * GSERC Program Memory (96kB) Registers
 */
union cavm_gsercx_pmemx
{
    uint64_t u;
    struct cavm_gsercx_pmemx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) Firmware memory for GSERC microcontroller. */
#else /* Word 0 - Little Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) Firmware memory for GSERC microcontroller. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_pmemx_s cn; */
};
typedef union cavm_gsercx_pmemx cavm_gsercx_pmemx_t;

static inline uint64_t CAVM_GSERCX_PMEMX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_PMEMX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=12287)))
        return 0x87e0a80a0000ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3fff);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=12287)))
        return 0x87e0a80a0000ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3fff);
    __cavm_csr_fatal("GSERCX_PMEMX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_PMEMX(a,b) cavm_gsercx_pmemx_t
#define bustype_CAVM_GSERCX_PMEMX(a,b) CSR_TYPE_RSL
#define basename_CAVM_GSERCX_PMEMX(a,b) "GSERCX_PMEMX"
#define device_bar_CAVM_GSERCX_PMEMX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_PMEMX(a,b) (a)
#define arguments_CAVM_GSERCX_PMEMX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) gserc#_refclk_ctr
 *
 * GSERC Reference Clock Cycle Counter Register
 * A free-running counter of PLL reference clock cycles to enable rough
 * confirmation of reference clock frequency via software. Read the counter; wait some
 * time, e.g., 100ms; read the counter; calculate frequency based on the difference in
 * values during the known wait time.
 */
union cavm_gsercx_refclk_ctr
{
    uint64_t u;
    struct cavm_gsercx_refclk_ctr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t count                 : 64; /**< [ 63:  0](R/W/H) Running count of PLL reference clock cycles. */
#else /* Word 0 - Little Endian */
        uint64_t count                 : 64; /**< [ 63:  0](R/W/H) Running count of PLL reference clock cycles. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_refclk_ctr_s cn; */
};
typedef union cavm_gsercx_refclk_ctr cavm_gsercx_refclk_ctr_t;

static inline uint64_t CAVM_GSERCX_REFCLK_CTR(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_REFCLK_CTR(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8081000ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8081000ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_REFCLK_CTR", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_REFCLK_CTR(a) cavm_gsercx_refclk_ctr_t
#define bustype_CAVM_GSERCX_REFCLK_CTR(a) CSR_TYPE_RSL
#define basename_CAVM_GSERCX_REFCLK_CTR(a) "GSERCX_REFCLK_CTR"
#define device_bar_CAVM_GSERCX_REFCLK_CTR(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_REFCLK_CTR(a) (a)
#define arguments_CAVM_GSERCX_REFCLK_CTR(a) (a),-1,-1,-1

/**
 * Register (RSL) gserc#_rx_term_ctl
 *
 * Receiver Termination Under perst (by lane) Control Register
 */
union cavm_gsercx_rx_term_ctl
{
    uint64_t u;
    struct cavm_gsercx_rx_term_ctl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t term_ctl              : 64; /**< [ 63:  0](R/W) Placeholder until RTL is written. */
#else /* Word 0 - Little Endian */
        uint64_t term_ctl              : 64; /**< [ 63:  0](R/W) Placeholder until RTL is written. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_rx_term_ctl_s cn; */
};
typedef union cavm_gsercx_rx_term_ctl cavm_gsercx_rx_term_ctl_t;

static inline uint64_t CAVM_GSERCX_RX_TERM_CTL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_RX_TERM_CTL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_F95O) && (a<=4))
        return 0x87e0a8080070ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("GSERCX_RX_TERM_CTL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_RX_TERM_CTL(a) cavm_gsercx_rx_term_ctl_t
#define bustype_CAVM_GSERCX_RX_TERM_CTL(a) CSR_TYPE_RSL
#define basename_CAVM_GSERCX_RX_TERM_CTL(a) "GSERCX_RX_TERM_CTL"
#define device_bar_CAVM_GSERCX_RX_TERM_CTL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_RX_TERM_CTL(a) (a)
#define arguments_CAVM_GSERCX_RX_TERM_CTL(a) (a),-1,-1,-1

/**
 * Register (RSL) gserc#_scratch#
 *
 * GSERC Scratch Registers
 */
union cavm_gsercx_scratchx
{
    uint64_t u;
    struct cavm_gsercx_scratchx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t scratch               : 64; /**< [ 63:  0](R/W) Scratch registers for software use, no hardware impact. */
#else /* Word 0 - Little Endian */
        uint64_t scratch               : 64; /**< [ 63:  0](R/W) Scratch registers for software use, no hardware impact. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_scratchx_s cn; */
};
typedef union cavm_gsercx_scratchx cavm_gsercx_scratchx_t;

static inline uint64_t CAVM_GSERCX_SCRATCHX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_SCRATCHX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=7)))
        return 0x87e0a8080000ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=7)))
        return 0x87e0a8080000ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x7);
    __cavm_csr_fatal("GSERCX_SCRATCHX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_SCRATCHX(a,b) cavm_gsercx_scratchx_t
#define bustype_CAVM_GSERCX_SCRATCHX(a,b) CSR_TYPE_RSL
#define basename_CAVM_GSERCX_SCRATCHX(a,b) "GSERCX_SCRATCHX"
#define device_bar_CAVM_GSERCX_SCRATCHX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_SCRATCHX(a,b) (a)
#define arguments_CAVM_GSERCX_SCRATCHX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) gserc#_scratch_dom_rst#
 *
 * GSERC Scratch Registers
 */
union cavm_gsercx_scratch_dom_rstx
{
    uint64_t u;
    struct cavm_gsercx_scratch_dom_rstx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t scratch               : 64; /**< [ 63:  0](R/W) Scratch registers for software use, no hardware impact. */
#else /* Word 0 - Little Endian */
        uint64_t scratch               : 64; /**< [ 63:  0](R/W) Scratch registers for software use, no hardware impact. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_gsercx_scratch_dom_rstx_s cn; */
};
typedef union cavm_gsercx_scratch_dom_rstx cavm_gsercx_scratch_dom_rstx_t;

static inline uint64_t CAVM_GSERCX_SCRATCH_DOM_RSTX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_GSERCX_SCRATCH_DOM_RSTX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_F95O) && ((a<=4) && (b<=1)))
        return 0x87e0a80810d0ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80810d0ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x1);
    __cavm_csr_fatal("GSERCX_SCRATCH_DOM_RSTX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_GSERCX_SCRATCH_DOM_RSTX(a,b) cavm_gsercx_scratch_dom_rstx_t
#define bustype_CAVM_GSERCX_SCRATCH_DOM_RSTX(a,b) CSR_TYPE_RSL
#define basename_CAVM_GSERCX_SCRATCH_DOM_RSTX(a,b) "GSERCX_SCRATCH_DOM_RSTX"
#define device_bar_CAVM_GSERCX_SCRATCH_DOM_RSTX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_GSERCX_SCRATCH_DOM_RSTX(a,b) (a)
#define arguments_CAVM_GSERCX_SCRATCH_DOM_RSTX(a,b) (a),(b),-1,-1

#endif /* __CAVM_CSRS_GSERC_H__ */
